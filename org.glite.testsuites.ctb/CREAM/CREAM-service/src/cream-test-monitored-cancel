#!/usr/bin/python

import os,sys
import re, string
import getopt
import log4py
import threading
import time
import popen2
import tempfile

from CREAMTestUtils import testsuite_utils, job_utils
from CREAMTestUtils.submit_pool import JobSubmitterPool

def usage():
    manPage = testsuite_utils.ManPage()
    
    manPage.shortDescr = 'submit and cancel a sequence of jobs'
    manPage.synopsis = '[OPTION]'
    manPage.description = '''Submit a sequence of simple jobs with a specified rate \
and then try to cancel them'''

    manPage.parameters.append(('-h', '--help' , '', 'print this message and exit'))
    manPage.parameters.append(('-r', '--rate', 'SLEEP_TIME', '''\
the sleep time in seconds between two consecutive submissions(Default 30s, Min 5s)'''))
    manPage.parameters.append(('-n', '--numberOfJob', 'NUM', 'the number of jobs to submit (Default 1)'))
    manPage.parameters.append(('-m', '--maxRunningJobs', 'NUM', '''\
the max number of job which can be enqueued in the service (Default 100)'''))
    manPage.parameters.append(('-d', '--delegationID', 'DELEGATIONID','''\
disable the auto-delegation for each submission and reuse the specified delegation ID'''))
    manPage.parameters.append(('-R', '--resourceURI', 'RESOURCEURI','''\
define the URI of the resource under testing, the format is \
<host>[:<port>]/cream-<lrms>-<queue>. \
This option is mandatory and no default value is defined'''))
    manPage.parameters.append(('-C', '--maxConcurrentSubmit', 'NUM', '''\
define the number of concurrent submit, (DEFAULT is 1)'''))
    manPage.parameters.append(('-j', '--jdl', 'JDLFILE', '''\
define the path for the jdl file, if omitted a predefined jdl will \
be used with simple sleep as executable'''))
    
    manPage.env.append(('GLITE_LOCATION', 'location of gLite packages (DEFAULT=/opt/glite)'))
    manPage.env.append(('X509_USER_PROXY', 'location of the user proxy'))
    manPage.env.append(('MONITORED_CANCEL_CONFIG_FILE','''\
location of the configuration file for this test'''))
    
    manPage.display()
    
    sys.exit(0)





class JobPoller(threading.Thread):

    logger = log4py.Logger().get_instance(classid="JobPoller")
    
    runningStates = ['IDLE', 'RUNNING', 'REALLY-RUNNING']
    finalStates = ['DONE-OK', 'DONE-FAILED', 'ABORTED', 'CANCELLED']
    
    def __init__(self, parameters, cmds):
        threading.Thread.__init__(self)
        self.table = {}
        self.lock = threading.Lock()
        self.parameters = parameters
        self.cmdTable = cmds
        
        self.jobRE = re.compile("JobID=\[([^\]]+)")
        self.statusRE = re.compile('Status\s*=\s*\[([^\]]+)')
        self.failureRE = re.compile('FailureReason\s*=\s*\[([^\]]+)')
        
        self.pool = JobSubmitterPool(parameters, cmds, self)
        self.tableOfResults = {'DONE-OK': 0, 'DONE-FAILED': 0, \
                               'ABORTED': 0, 'CANCELLED': 0}

    def run(self):

        minTS = time.time()

        serviceHost = self.parameters.resourceURI[:string.find(self.parameters.resourceURI,'/')]
                
        jobLeft = self.parameters.numberOfJob
        jobProcessed = 0
        
        while jobProcessed<self.parameters.numberOfJob:
            
            ts = time.time()

            runningJobs = []
            finishedJobs = []

            statusCmd = self.cmdTable['status'] + \
                        " -L 0 -f \"" + time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime(minTS)) \
                        + "\" -e " + serviceHost + " --all"
            JobPoller.logger.debug('Command line: ' + statusCmd)
            statusProc = popen2.Popen4(statusCmd, True)
            
            self.lock.acquire()
            try:
                
                currId = None
                
                for line in statusProc.fromchild:
                    if 'ERROR' in line or 'FATAL' in line:
                        JobPoller.logger.error(line[24:])
                        continue
                    
                    tmpm = self.jobRE.search(line)
                    if tmpm<>None:
                        currId = tmpm.group(1)
                        continue
                    
                    tmpm = self.statusRE.search(line)
                    if tmpm<>None and currId<>None:
                        jobStatus = tmpm.group(1)
                        
                        if not currId in self.table:
                            currId = None
                            continue
                        
                        if jobStatus in JobPoller.runningStates and not self.table[currId][1]:
                            self.table[currId] = (self.table[currId][0], True)
                            runningJobs.append(currId)
                        elif jobStatus in JobPoller.finalStates:
                            del(self.table[currId])
                            finishedJobs.append(currId)
                            jobProcessed += 1
                            self.tableOfResults[jobStatus] += 1
                            JobPoller.logger.info("Execution terminated for job: %s with status %s"  \
                                                  % (currId, jobStatus))
                        continue
                    
                    tmpm = self.failureRE.search(line)
                    if tmpm<>None and currId<>None:
                        jobFailure = tmpm.group(1)
                        JobPoller.logger.debug("Failure reason for job %s: %s" %(jobId, jobFailure)) 
                        continue

                statusProc.fromchild.close()

                if len(finishedJobs)>0 and len(self.table):
                    minTS = min(self.table.values())[0] - 1
                    
            finally:
                self.lock.release()

            job_utils.eraseJobs(runningJobs, self.cmdTable['cancel'], JobPoller.logger)
            job_utils.eraseJobs(finishedJobs, self.cmdTable['purge'], JobPoller.logger)

            #TODO: imcremental pool feeding
            jobToSend = min(jobLeft, self.parameters.maxRunningJobs - len(self.table))
            self.pool.submit(jobToSend)
            jobLeft = self.parameters.numberOfJob - self.pool.getSuccesses()
            JobPoller.logger.debug("Job left: " + str(jobLeft) + " job processed: " + str(jobProcessed))
            
            timeToSleep = self.parameters.rate - int(time.time() - ts)
            if timeToSleep>0:
                time.sleep(timeToSleep)

    def put(self, uri, timestamp):
        self.lock.acquire()
        JobPoller.logger.info("Submitted job: " + uri)
        self.table[uri] = (timestamp, False)
        self.lock.release()

    def size(self):
        self.lock.acquire()
        result = len(self.table)
        self.lock.release()
        return result
    
    def shutdown(self):
        self.pool.shutdown()
        for key in self.tableOfResults:
            JobPoller.logger.info("Job with status %s: %d" % (key, self.tableOfResults[key]))
        if self.tableOfResults['CANCELLED']<>self.parameters.numberOfJob:
            return 1
        return 0



def main():
    logger = log4py.Logger().get_instance(classid="main")
    
    parameters = testsuite_utils.Parameters()
    parameters.register('rate', 'd', 30, testsuite_utils.checkRate)
    parameters.register('numberOfJob', 'd', 1, testsuite_utils.atLeastOne)
    parameters.register('maxRunningJobs', 'd', 100, testsuite_utils.atLeastOne)
    parameters.register('delegationID', 's')
    parameters.register('resourceURI', 's', optChar='R')
    parameters.register('maxConcurrentSubmit', 'd', 1, testsuite_utils.atLeastOne, 'C')
    parameters.register('jdl', 's')
    parameters.register('help', 'b')

    if os.environ.has_key("MONITORED_CANCEL_CONFIG_FILE"):
        confFileName = os.environ["MONITORED_CANCEL_CONFIG_FILE"]
        try:
            parameters.parseConfigFile(confFileName)
        except IOError, ioError:
            failure("Cannot read configuration file: " + confFileName + " " + str(ioError))
        except Exception, exception:
            failure("Cannot parse configuration file: " + confFileName + " " + str(exception))

    try:
        optlist, args = getopt.getopt(sys.argv[1:], parameters.getShortOptString(),
                                      parameters.getLongOptList())
        parameters.parseOptList(optlist)
    except getopt.GetoptError:
        print "Wrong arguments\n\nUsage:\n"
        usage()
    except Exception, exception:
        failure("Cannot parse option list " + str(exception))
        
    if parameters.help:
        usage()

    if parameters.resourceURI=='':
        print "Resource URI is not defined"
        usage()

    if parameters.jdl=='':
        parameters.jdl = testsuite_utils.createTempJDL(parameters.rate*10, logger)
        if parameters.jdl==None:
            sys.exit(1)
    
    gliteCeCommand = testsuite_utils.getCECommandTable()

    proxyFile = testsuite_utils.getProxyFile()
        
    pollerThread = JobPoller(parameters, gliteCeCommand)
    pollerThread.start()
    pollerThread.join()
    exitCode = pollerThread.shutdown()
    
    sys.exit(exitCode)
    
if __name__ == "__main__":
    main()
