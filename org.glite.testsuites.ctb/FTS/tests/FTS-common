#!/bin/bash

##############################################################################
# Copyright (c) Members of the EGEE Collaboration. 2004.
# See http://www.eu-egee.org/partners/ for details on the copyright
# holders.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS
# OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
##############################################################################
#
# AUTHORS: Gianni Pucciani, CERN
#
##############################################################################

# Cert config. This is here to allow tests to
# override the default configuration
source ../FTS-certconfig #needed to get CERN_SE and DESY_SE

#Functions definitions for FTS tests

#
# Store the FTS url in FTS_URL and fts host in FTS_HOST or return 1
# SITE_NAME must be set
#
function get_fts_url_and_host()
{


  FTS_URL=`glite-sd-query -s $SITE_NAME -t org.glite.FileTransfer 2>/dev/null | grep Endpoint | sed -e 's/Endpoint://g'`
  FTS_URL=`echo $FTS_URL | awk '{print $1}' | sed -e 's/https:\/\///g' | sed 's/\// /g' | awk '{print $1}' | sed -e 's/:/ /g'`
  FTS_HOST=`echo $FTS_URL | awk '{print $1}'`
    
  if [ -z "$FTS_HOST" ]; then
    echo ""
    echo ">>> NOTE: There is no information for FTS Server of the site: $SITE_NAME on  BDII: $BDII_HOST! <<< "
    echo "" 
    echo "-TEST FAILED-" 
    return 1
  fi

  return 0
}

# Returns in GSIFTP_SOURCE and GSIFTP_DESTINATION the GridFTP
# equivalent URLS
# Parameters:
#   1.- Source SURL
#   2.- Destination SURL
# NOTE: A blank destination file will be created (it is needed)
function get_gsiftp_urls()
{
    # Source is straight-forward
    GSIFTP_SOURCE=`lcg-gt $1 gsiftp`

    # Create a blank file and upload
    local GSIFTP_TMP_FILE="/tmp/FTS_Test_$DATE_blank"
    touch $GSIFTP_TMP_FILE
    echo "Creating blank destination for GSIFTP test"
    local GSIFTP_DEST_GUID=`lcg-cr --vo $VO_NAME -d $2 file://$GSIFTP_TMP_FILE`
    if [ ! $? -eq 0 ]; then
        echo "The blank destination file could not be created!!"
        return 1
    fi
    rm -f $GSIFTP_TMP_FILE

    # Recover GSIFTP
    GSIFTP_DESTINATION=`lcg-gt $2 gsiftp`

    # Warning
    echo "Using GSIFTP URLs!!"
    echo "  Source: $GSIFTP_SOURCE"
    echo "  Destination: $GSIFTP_DESTINATION"
}

#
# get SE1_SRM_LOC, SE2_SRM_LOC and MYPROXY_PASS and submit
# a file transfer. FTS_HOST must be set. The job Id is stored
# in SUBID
#
# If GSIFTP_URL is set to "yes", this will use GridFTP URLs
function file_transfer()
{
    if [ -z $1 ];then
     echo "An SE source SRM location must be given to file_transfer()"
     return 2
    else
     local SE1_SRM_LOC=$1
    fi

    if [ -z $2 ];then
     echo "An SE destination SRM location must be given to file_transfer()"
     return 2
    else
     local SE2_SRM_LOC=$2
    fi

#    if [ -z $3 ];then
#     echo "A MyProxy password must be given to file_transfer()"
#     return 2
#    else
#     local MYPROXY_PASS=$3
#    fi


#    SE1_SRM_LOC=$1
#    SE2_SRM_LOC=$2
#    MYPROXY_PASS=$3
    SUB_FILE_LOC="$HOME/fts-submission-file"
    RESULT_FILE="$HOME/fts-test-results"

    DATE=`date | awk '{print $2"_"$3"_"$4}' | sed -e 's/://g'`
    TMP_FILE="/tmp/FTS_Test_$DATE"
    TEST_FILE_NAME="FTS_Test_$DATE"

    echo "Creating 10MB temporary test file for transfer" 

    echo "" > $TMP_FILE

    dd if=/dev/zero of=$TMP_FILE bs=10MB count=1 2>/dev/null

    echo "Using the 10MB temporary test file: $TMP_FILE" 
    echo "Copy the test file $TMP_FILE on: $SE1_SRM_LOC" 

    GUID=`lcg-cr --vo $VO_NAME -d $SE1_SRM_LOC/$TEST_FILE_NAME file://$TMP_FILE 2>message`

    result=`cat message | wc -l`

    if [ $result -gt 0 ]; then
      echo ">>> NOTE: `cat message`"
      echo ">>> NOTE: lcg-cr command for SRM: $SE1_SRM_LOC failed!"
#      NumberOfSuccFinJob=`expr $NumberOfSuccFinJob - 1`
      return 1
    fi
    echo "Removing the 10MB temporary test file: $TMP_FILE"
    rm -rf $TMP_FILE

    echo "Creating the submission file in $SUB_FILE_LOC"
    i=0
    echo "" > $SUB_FILE_LOC

    # Process the destination and source URLs depending on
    # the GSIFTP_URL environment variable
    if [ "x$GSIFTP_URL" = "xyes" ]; then
        get_gsiftp_urls "$SE1_SRM_LOC/$TEST_FILE_NAME" "$SE2_SRM_LOC/$TEST_FILE_NAME$i"
        if [ ! $? -eq 0 ]; then
            echo "get_gsiftp_urls error!"
            return 1
        fi
        echo "$GSIFTP_SOURCE $GSIFTP_DESTINATION" >> $SUB_FILE_LOC
    else
        echo "$SE1_SRM_LOC/$TEST_FILE_NAME $SE2_SRM_LOC/$TEST_FILE_NAME$i" >> $SUB_FILE_LOC
    fi

    echo "Submitting the transfer"  

    echo "glite-transfer-submit -s https://$FTS_HOST:8443/glite-data-transfer-fts/services/FileTransfer -f $SUB_FILE_LOC" 
    SUBID=`glite-transfer-submit -s https://$FTS_HOST:8443/glite-data-transfer-fts/services/FileTransfer -f $SUB_FILE_LOC`
#    SUBID=`glite-transfer-submit -s https://$FTS_HOST:8443/glite-data-transfer-fts/services/FileTransfer -f $SUB_FILE_LOC -p $MYPROXY_PASS`
    if [ -z "$SUBID" ]; then
       echo "Job submition failed!"
       return 1
    fi
    echo "Job successfully submited"
    echo "Transfer ID: $SUBID. " 

}


#
# as file_transfer but uses tokens description and file size
# Usage: file_transfer_tokens SOURCE_SAPATH DEST_SAPATH SRC_DESCR DEST_DESCR FILE_SIZE
#
# If GSIFTP_URL is set to "yes", this will use GridFTP URLs
function file_transfer_tokens()
{
  if [ $# -ne 5 ]; then
    echo "Error: file_transfer_tokens: expecting 5 arguments, $# received"
    return 1
  fi
  SOURCE_SAPATH=$1
  DEST_SAPATH=$2
  SRC_DESCR=$3
  DEST_DESCR=$4
  FILE_SIZE=$5

  SUB_FILE_LOC="$HOME/fts-submission-file"
  DATE=`date | awk '{print $2"_"$3"_"$4}' | sed -e 's/://g'`
  TMP_FILE="/tmp/FTS_Test_$DATE"
  TEST_FILE_NAME="FTS_Test_$DATE"

  echo "Creating ${FILE_SIZE}KB temporary test file for transfer"
  echo "" > $TMP_FILE
  dd if=/dev/zero of=$TMP_FILE bs=${FILE_SIZE}KB count=1 2>/dev/null
  echo "Copy the test file $TMP_FILE on: $SOURCE_SAPATH"
  GUID=`lcg-cr --vo $VO_NAME -d $SOURCE_SAPATH/$TEST_FILE_NAME file://$TMP_FILE 2>message`
  result=`cat message | wc -l`
  if [ $result -gt 0 ]; then
    echo ">>> NOTE: `cat message`"
    echo ">>> NOTE: lcg-cr command for SRM: $SE1_SRM_LOC failed!"
#    NumberOfSuccFinJob=`expr $NumberOfSuccFinJob - 1`
    return 1
  fi
  echo "Removing the temporary test file: $TMP_FILE"
  rm -rf $TMP_FILE

  echo "Creating the submission file in $SUB_FILE_LOC"
  id=`date +%s`
  echo "" > $SUB_FILE_LOC

    # Process the destination and source URLs depending on
    # the GSIFTP_URL environment variable
    if [ "x$GSIFTP_URL" = "xyes" ]; then
        get_gsiftp_urls "$SOURCE_SAPATH/$TEST_FILE_NAME" "$DEST_SAPATH/$TEST_FILE_NAME$id"
        if [ ! $? -eq 0 ]; then
            echo "get_gsiftp_urls error!"
            return 1
        fi
        echo "$GSIFTP_SOURCE $GSIFTP_DESTINATION" >> $SUB_FILE_LOC
    else
        echo "$SOURCE_SAPATH/$TEST_FILE_NAME $DEST_SAPATH/$TEST_FILE_NAME$id" >> $SUB_FILE_LOC
    fi
  
  
  echo "Submitting the transfer"
  echo "glite-transfer-submit -s https://$FTS_HOST:8443/glite-data-transfer-fts/services/FileTransfer -f $SUB_FILE_LOC --dest-token $DEST_DESCR --source-token $SRC_DESCR"
  SUBID=`glite-transfer-submit -s https://$FTS_HOST:8443/glite-data-transfer-fts/services/FileTransfer -f $SUB_FILE_LOC --dest-token $DEST_DESCR --source-token $SRC_DESCR`
#    SUBID=`glite-transfer-submit -s https://$FTS_HOST:8443/glite-data-transfer-fts/services/FileTransfer -f $SUB_FILE_LOC -p $MYPROXY_PASS`
  if [ -z "$SUBID" ]; then
     echo "Job submition failed!"
     return 1
  fi
  echo "Job successfully submited"
  echo "Transfer ID: $SUBID. "

  return 0
}

#
# as file_transfer but uses --fail-nearline
# Usage: file_transfer_skip_tape SOURCE_SAPATH DEST_SAPATH FILE_SIZE
#
# If GSIFTP_URL is set to "yes", this will use GridFTP URLs
function file_transfer_skip_tape()
{
  if [ $# -ne 3 ]; then
    echo "Error: file_transfer_skip_tape: expecting 3 arguments, $# received"
    return 1
  fi
  SOURCE_SAPATH=$1
  DEST_SAPATH=$2
  FILE_SIZE=$3

  SUB_FILE_LOC="$HOME/fts-submission-file"
  DATE=`date | awk '{print $2"_"$3"_"$4}' | sed -e 's/://g'`
  TMP_FILE="/tmp/FTS_Test_$DATE"
  TEST_FILE_NAME="FTS_Test_$DATE"

  echo "Creating ${FILE_SIZE}KB temporary test file for transfer"
  echo "" > $TMP_FILE
  dd if=/dev/zero of=$TMP_FILE bs=${FILE_SIZE}KB count=1 2>/dev/null
  echo "Copy the test file $TMP_FILE on: $SOURCE_SAPATH"
  GUID=`lcg-cr --vo $VO_NAME -d $SOURCE_SAPATH/$TEST_FILE_NAME file://$TMP_FILE 2>message`
  result=`cat message | wc -l`
  if [ $result -gt 0 ]; then
    echo ">>> NOTE: `cat message`"
    echo ">>> NOTE: lcg-cr command for SRM: $SE1_SRM_LOC failed!"
#    NumberOfSuccFinJob=`expr $NumberOfSuccFinJob - 1`
    return 1
  fi
  echo "Removing the temporary test file: $TMP_FILE"
  rm -rf $TMP_FILE

  echo "Creating the submission file in $SUB_FILE_LOC"
  id=`date +%s`
  echo "" > $SUB_FILE_LOC

    # Process the destination and source URLs depending on
    # the GSIFTP_URL environment variable
    if [ "x$GSIFTP_URL" = "xyes" ]; then
        get_gsiftp_urls "$SOURCE_SAPATH/$TEST_FILE_NAME" "$DEST_SAPATH/$TEST_FILE_NAME$id"
        if [ ! $? -eq 0 ]; then
            echo "get_gsiftp_urls error!"
            return 1
        fi
        echo "$GSIFTP_SOURCE $GSIFTP_DESTINATION" >> $SUB_FILE_LOC
    else
        echo "$SOURCE_SAPATH/$TEST_FILE_NAME $DEST_SAPATH/$TEST_FILE_NAME$id" >> $SUB_FILE_LOC
    fi
  
  echo "Submitting the transfer"
  echo "glite-transfer-submit -s https://$FTS_HOST:8443/glite-data-transfer-fts/services/FileTransfer -f $SUB_FILE_LOC --fail-nearline"
  SUBID=`glite-transfer-submit -s https://$FTS_HOST:8443/glite-data-transfer-fts/services/FileTransfer -f $SUB_FILE_LOC --fail-nearline`
#    SUBID=`glite-transfer-submit -s https://$FTS_HOST:8443/glite-data-transfer-fts/services/FileTransfer -f $SUB_FILE_LOC -p $MYPROXY_PASS`
  if [ -z "$SUBID" ]; then
     echo "Job submition failed!"
     return 1
  fi
  echo "Job successfully submited"
  echo "Transfer ID: $SUBID. "

  return 0
}

#
# get SE1_SRM_LOC, SE2_SRM_LOC and ALGO and an optional 4th argument
# with the checksum option and submit
# a file transfer using the checksum option. 
# FTS_HOST must be set. The job Id is stored in SUBID
#
# If GSIFTP_URL is set to "yes", this will use GridFTP URLs
function file_transfer_with_checksum()
{
    if [ -z $1 ];then
     echo "An SE source SRM location must be given to file_transfer_with_checksum()"
     return 2
    else
     local SE1_SRM_LOC=$1
    fi

    if [ -z $2 ];then
     echo "An SE destination SRM location must be given to file_transfer_with_checksum()"
     return 2
    else
     local SE2_SRM_LOC=$2
    fi

    if [ -z $3 ];then
     echo "A checksum algorithm must be given to file_transfer_with_checksum()"
     return 2
    else
     local ALGO=$3
     if [ "x$ALGO" == "xSHA1" ]; then
       echo "WARNING: SHA1 will not be tested due to bug #..."
       return 0
     fi
   fi

   if [ -z $4 ];then
     echo "No --compare-checksum option will be used"
     OPTION=""
   else
     echo "Using --compare-option" 
     OPTION=$4
   fi

   if [ -z $5 ];then
     echo "" >> /dev/null #do nothing
   else
     echo "Using 3rd scenarios with both --compare-checksum and algorithm"
   fi

    SUB_FILE_LOC="$HOME/fts-submission-file"
    RESULT_FILE="$HOME/fts-test-results"

    DATE=`date | awk '{print $2"_"$3"_"$4}' | sed -e 's/://g'`
    TMP_FILE="/tmp/FTS_Test_$DATE"
    TEST_FILE_NAME="FTS_Test_$DATE"

    echo "Creating 10MB local temporary test file for transfer" 

    echo "" > $TMP_FILE

    dd if=/dev/zero of=$TMP_FILE bs=10MB count=1 2>/dev/null

    echo "Using the 10MB temporary test file: $TMP_FILE" 
    echo "Copy and register the test file $TMP_FILE on: $SE1_SRM_LOC using $ALGO checksum" 

    GUID=`lcg-cr --checksum --checksum-type $ALGO --vo $VO_NAME -d $SE1_SRM_LOC/$TEST_FILE_NAME file://$TMP_FILE 2>message`

    result=`cat message | wc -l`

    if [ $result -gt 0 ]; then
      echo ">>> NOTE: `cat message`"
      echo ">>> NOTE: lcg-cr command for SRM: $SE1_SRM_LOC failed!"
#      NumberOfSuccFinJob=`expr $NumberOfSuccFinJob - 1`
      return 1
    fi
    echo "Removing the 10MB temporary test file: $TMP_FILE"
    rm -rf $TMP_FILE

    echo "Retrieving the SURL for guid: $GUID"
    SURL=`lcg-lr $GUID`

    if [ "x$OPTION" == "x" ]; then
      echo "Retrieving the checksum for $SURL"
      CHECKSUM=`lcg-get-checksum --checksum-type $ALGO $SURL | awk '{print $1}'`
      echo "Creating the submission file with $ALGO:$CHECKSUM in $SUB_FILE_LOC"
      i=0
      echo "" > $SUB_FILE_LOC

    # Process the destination and source URLs depending on
    # the GSIFTP_URL environment variable
    if [ "x$GSIFTP_URL" = "xyes" ]; then
        get_gsiftp_urls "$SE1_SRM_LOC/$TEST_FILE_NAME" "$SE2_SRM_LOC/$TEST_FILE_NAME$i"
        if [ ! $? -eq 0 ]; then
            echo "get_gsiftp_urls error!"
            return 1
        fi
        echo "$GSIFTP_SOURCE $GSIFTP_DESTINATION $ALGO:$CHECKSUM" >> $SUB_FILE_LOC
    else
        echo "$SE1_SRM_LOC/$TEST_FILE_NAME $SE2_SRM_LOC/$TEST_FILE_NAME$i $ALGO:$CHECKSUM" >> $SUB_FILE_LOC
    fi

      echo "Submitting the transfer"  
      echo "glite-transfer-submit -s https://$FTS_HOST:8443/glite-data-transfer-fts/services/FileTransfer -f $SUB_FILE_LOC" 
      SUBID=`glite-transfer-submit -s https://$FTS_HOST:8443/glite-data-transfer-fts/services/FileTransfer -f $SUB_FILE_LOC`
      if [ -z "$SUBID" ]; then
         echo "Job submition failed!"
         return 1
      fi
    elif [ "x$5" == "x" ]; then
      echo "Creating the submission file in $SUB_FILE_LOC"
      i=0
      echo "" > $SUB_FILE_LOC

    # Process the destination and source URLs depending on
    # the GSIFTP_URL environment variable
    if [ "x$GSIFTP_URL" = "xyes" ]; then
        get_gsiftp_urls "$SE1_SRM_LOC/$TEST_FILE_NAME" "$SE2_SRM_LOC/$TEST_FILE_NAME$i"
        if [ ! $? -eq 0 ]; then
            echo "get_gsiftp_urls error!"
            return 1
        fi
        echo "$GSIFTP_SOURCE $GSIFTP_DESTINATION" >> $SUB_FILE_LOC
    else
        echo "$SE1_SRM_LOC/$TEST_FILE_NAME $SE2_SRM_LOC/$TEST_FILE_NAME$i" >> $SUB_FILE_LOC
    fi
      
      echo "Submitting the transfer with $OPTION"  
      echo "glite-transfer-submit -s https://$FTS_HOST:8443/glite-data-transfer-fts/services/FileTransfer $OPTION -f $SUB_FILE_LOC" 
      SUBID=`glite-transfer-submit -s https://$FTS_HOST:8443/glite-data-transfer-fts/services/FileTransfer $OPTION -f $SUB_FILE_LOC`
      if [ -z "$SUBID" ]; then
         echo "Job submition failed!"
         return 1
      fi
    else
      echo "Retrieving the checksum for $SURL"
      CHECKSUM=`lcg-get-checksum --checksum-type $ALGO $SURL | awk '{print $1}'`
      echo "Creating the submission file with $ALGO:$CHECKSUM in $SUB_FILE_LOC"
      i=0
      echo "" > $SUB_FILE_LOC


    # Process the destination and source URLs depending on
    # the GSIFTP_URL environment variable
    if [ "x$GSIFTP_URL" = "xyes" ]; then
        get_gsiftp_urls "$SE1_SRM_LOC/$TEST_FILE_NAME" "$SE2_SRM_LOC/$TEST_FILE_NAME$i"
        if [ ! $? -eq 0 ]; then
            echo "get_gsiftp_urls error!"
            return 1
        fi
        echo "$GSIFTP_SOURCE $GSIFTP_DESTINATION $ALGO:$CHECKSUM" >> $SUB_FILE_LOC
    else
        echo "$SE1_SRM_LOC/$TEST_FILE_NAME $SE2_SRM_LOC/$TEST_FILE_NAME$i $ALGO:$CHECKSUM" >> $SUB_FILE_LOC
    fi

      echo "Submitting the transfer with $OPTION"  
      echo "glite-transfer-submit -s https://$FTS_HOST:8443/glite-data-transfer-fts/services/FileTransfer $OPTION -f $SUB_FILE_LOC" 
      SUBID=`glite-transfer-submit -s https://$FTS_HOST:8443/glite-data-transfer-fts/services/FileTransfer $OPTION -f $SUB_FILE_LOC`
      if [ -z "$SUBID" ]; then
         echo "Job submition failed!"
         return 1
      fi

    fi

    echo "Job successfully submited"
    echo "Transfer ID: $SUBID. " 

}

#
# Get a Submission Id and check the status of the file transfer.
# Return codes:
#              - 0 transfer finished
#              - 1 error
#              - 2 bad input arguments
#              - 3 job failed
#              - 4 job is holded
#              - 5 job is in cancelling process
#              - 6 job is canceled 
#
function get_status_result()
{

    if [ -z $1 ];then
      echo "A submission Id must be provided to get_status_result()"
      return 2
    else
      local SubId=$1
    fi

    export GLITE_SD_SITE=$SITE_NAME
    export LCG_CATALOG_TYPE='lfc'

    previous_status="None"

    status=`glite-transfer-status -s https://$FTS_HOST:8443/glite-data-transfer-fts/services/FileTransfer $SubId 2>message`

    result=`cat message | wc -l`

    if [ $result -gt 0 ]; then
      echo ">>> NOTE: `cat message`"
      echo ""
      return
    fi


#    echo "status is $status"
    if test $status == "Finished"
    then
      echo "Job is successfully finished." 
      return 0
    
    elif test $status == "Failed"
    then
      echo "Job is Failed" 
      return 3 

    elif test $status == "Hold"
    then
      echo "Job is Hold"
      return 4

    elif test $status == "Submitted"
    then
      echo "Job is Submitted"
      return 4

    elif test $status == "Ready"
    then
      echo "Job is Ready"
      return 4

    elif test $status == "Pending"
    then
      echo "Job is Pending"
      return 4

    elif test $status == "Done"
    then
      echo "Job is Done"
      return 4

    elif test $status == "Active"
    then
      echo "Job is Active"
      return 4

    elif test $status == "Finishing"
    then
      echo "Job is Finishing"
      return 4
     
    elif test $status == "Canceling"
    then
      echo "Job is Canceling"
      return 5
    elif test $status == "Canceled"
    then
      echo "Job is Canceled"
      return 6

    else
      echo "Job status unknown: $status"
      return 1
    fi 

}

#
# get SUBID and TIMEOUT and poll the status until it is done (0), failed (3)
# or failed for timeout exceeded (4). 1 ir returned on error and 2 for bad
# input parameters
#
function poll_status_with_timeout()
{
  if [ -z $1 ];then
    echo "A submission Id must be provided to poll_status_with_timeout()"
    return 2
  else
    local SUBID=$1
  fi

  if [ -z $2 ];then
    echo "A timeout must be provided to poll_status_with_timeout()"
    return 2
  else
    local Timeout=$2
  fi

  echo "Checking status for job ID: $SUBID" 

  previous_status="None"
  t=0
  while test $t -lt $Timeout
  do
    get_status_result $SUBID
    status=$?

    if [ "$status" -eq 1 ]; then
      echo "error retrieving the status with get_status_result()"
      return 1
    fi

    if [ "$status" -eq 0 ]; then
      echo "Job done"
      return 0
    fi
     
    if [ "$status" -eq 3 ]; then
      echo "Job failed"
      return 3
    fi

    if [ "$status" -eq 4 ]; then
      echo "Waiting for status changes" 
      sleep 10
      t=`expr $t + 10`
      echo "Time is $t timeout is $Timeout"  
    fi

    if [ "$t" -eq "$Timeout" ]; then
      echo "Exceded timeout of $Timeout seconds"
      return 4
    else
      continue
    fi
  done

}

function remove_space()
{
  if [ $# -ne 2 ]; then
    echo "Error: remove_space: expecting 2 arguments, $# were given"
    return 1
  fi
  
  SAPATH=$1
  TOKEN=$2
  echo "remove_space: removing space in $SAPATH with token $TOKEN"
  if [ `echo $SAPATH | grep dpm` ]; then
    #release space using dpm client
    dpm-releasespace --space_token $TOKEN
    if [ $? -ne 0 ]; then
      echo "Error: remove_space function: error calling dpm-releasespace --token_desc $TOKEN"
      return 1
    fi
    elif [ `echo $SAPATH | grep desy` ]; then
    #release space using dcache client
    srm-release-space $SAPATH --space_token=$TOKEN
    if [ $? -ne 0 ]; then
      echo "Error: remove_space function: error calling srm-release-space $SAPATH -space_token=$TOKEN"
      return 1
    fi
  else echo "Error: remove_space: I cannot retrieve the SE type"
  fi
  echo "remove_space: space released on $SAPATH"
  return 0

}

#
# Fill $Channel_List with channels retrieved from glite-transfer-channel-list
# FTS_HOST must be set
#
function get_channels()
{
#  export GLITE_SD_SITE=$SITE_NAME
#  export LCG_CATALOG_TYPE='lfc'

  Channel_List=`glite-transfer-channel-list -s https://$FTS_HOST:8443/glite-data-transfer-fts/services/ChannelManagement 2>message`
  
  result=`cat message|wc -l`
  if [ $result -gt 0 ]; then
     echo ""
     echo ">>> NOTE:  `cat message`."
     echo "-TEST FAILED-"
     echo ""
     return 1
  fi
  return 0
}

#
# channel-exists <CHANNEL NAME>
# returns 0 is channel exists, 1 otherwise.
#
function channel-exists()
{
    echo "is-channel-exists($1)"
    CHANNEL=$1

    #Get Channels list
    echo
    echo "Retrieving channels list..."
    get_channels
    echo "List=$Channel_List"
    if [ "x$Channel_List" == "x" ]; then
    echo "No channels retrieved"
    return 1
    fi

    for Channel in $Channel_List
    do
        if [ "$Channel" == "$CHANNEL" ];then
            echo "Channel exists"
            return 0
    fi
    done
    return 1
}


#
# is_channel_active <CHANNEL NAME>
# Returns 0 if active or 1 if not active
#
function is_channel_active()
{
#  export GLITE_SD_SITE=$SITE_NAME
#  export LCG_CATALOG_TYPE='lfc'

  if [ -z $1 ];then
    echo "A channel name must be provided to is_channel_active()"
    return 2
  else
    local Channel_Name=$1
  fi

  isChannelActive=`glite-transfer-channel-list -s https://$FTS_HOST:8443/glite-data-transfer-fts/services/ChannelManagement $Channel_Name | grep "State: Active" |wc -l`
  if [ $isChannelActive -eq 0 ];then
    echo "The channel: $Channel_Name is not Active! " 
    return 1
  fi
  return 0
}

# FTS_HOST must be set.
# Added by Victor Galaktionov 24/11/209
function channel-drop()
{
    echo "channel-drop($1)"
    glite-transfer-channel-drop  -s https://$FTS_HOST:8443/glite-data-transfer-fts/services/ChannelManagement $1 2> message
    if [ $? != 0 ]; then
    echo "Drop channel command - failed"
    cat message
    return 1
    fi
    return 0
}

# FTS_HOST must be set.
# Added by Victor Galaktionov 24/11/209
function simple-channel-add()
{   
    
    echo "simple-channel-add($1, $2, $3)"
    if [ -z $1 ]; then
     echo "Channel name must be given to channel-add()"
     return 1
    fi 
    
    local CHANNEL=$1
    local SITE_S=$2
    local SITE_D=$3
      
    echo "Add channel: $CHANNEL $SITE_S $SITE_D"
    glite-transfer-channel-add  -s https://$FTS_HOST:8443/glite-data-transfer-fts/services/ChannelManagement \
     $CHANNEL $SITE_S $SITE_D
    if [ $? != 0 ]; then
      glite-transfer-channel-list  -s https://$FTS_HOST:8443/glite-data-transfer-fts/services/ChannelManagement
      echo "Add channel - failed"
      return 1
    fi
    return 0
}

# Added by Victor Galaktionov 08/12/2009
function special-channel-signal()
{
    echo "special-channel-signal()"
    echo "glite-transfer-channel-signal -h"
    glite-transfer-channel-signal -h > /dev/null
    if [ $? != 0 ]; then
    echo "glite-transfer-setpriority -h command - failed"
    return 1
    fi

    echo "glite-transfer-channel-signal -V"
    glite-transfer-channel-signal -V
    if [ $? != 0 ]; then
    echo "glite-transfer-channel-signal -V command - failed"
    return 1
    fi

    echo "glite-transfer-channel-signal"
    glite-transfer-channel-signal
    if [ $? == 0 ]; then
    echo "glite-transfer-channel-signal command - failed"
    return 1
    fi
    return 0

}

#
# Added by Victor Galaktionov 08/12/2009
function channel-signal() 
{   
    echo "Set signal '$2' to job $1"
    echo "glite-transfer-channel-signal -v -s https://$FTS_HOST:8443/glite-data-transfer-fts/services/ChannelManagement  -j $1 $2"
    glite-transfer-channel-signal -s https://$FTS_HOST:8443/glite-data-transfer-fts/services/ChannelManagement  -j $1 $2
    if [ $? != 0 ]; then
      echo "glite-transfer-channel-signal command - failed"
      return 1
    fi
    echo "OK, check job status glite-transfer-status --verbose  -s https://$FTS_HOST:8443/glite-data-transfer-fts/services/FileTransfer $"  
    glite-transfer-status --verbose  -s https://$FTS_HOST:8443/glite-data-transfer-fts/services/FileTransfer $1 > message
    return 0
}



#
# Store source site in $Source_Site and dest site in $Destin_Site
#
function get_source_dest_from_channel()
{

  if [ -z $1 ];then
    echo "A channel name must be provided to get_source_dest_from_channel()"
    return 2
  else
    local Channel_Name=$1
  fi

  Channel_Between=`glite-transfer-channel-list -s https://$FTS_HOST:8443/glite-data-transfer-fts/services/ChannelManagement $Channel_Name | grep Between | sed -e 's/*/star/g' | sed -e 's/Between://g' | sed -e 's/and//g'`


#    unset GLITE_SD_SITE
#    unset LCG_CATALOG_TYPE

  Source_Site=`echo $Channel_Between |  awk '{print $1}' |  tr 'A-Z' 'a-z'`
  Destin_Site=`echo $Channel_Between |  awk '{print $2}' |  tr 'A-Z' 'a-z'`

  return 0
}


#
# Get default SE from site
# The second parameter (optional) can be the source SE, so
# an alternative SE will be selected for the destination if
# the source site and the destination site are the same
#
function get_def_se_from_site()
{
  if [ -z $1 ];then
    echo "A site name must be provided to get_def_se_from_site()"
    return 2
  else
    local Site_Name=$1
  fi
  if [ $Site_Name == "cert-tb-cern" ]; then
    if [ ! -z $2 ] && [ ! -z $CERN_SE2 ]; then
        SE_HOST=$CERN_SE2
    else
        SE_HOST=$CERN_SE
    fi
  elif [ $Site_Name == "desycerttb" ]; then
    if [ ! -z $2 ] && [ ! -z $CERN_SE2 ]; then
        SE_HOST=$DESY_SE2
    else
        SE_HOST=$DESY_SE
    fi
  else
    echo "get_def_se_from_site: no SE defined for site $Site_Name"
    return 1
  fi
  return 0
}
   


#
# Get a site name and store the first good SE in SE_HOST or return 1
#
function get_good_se_from_site()
{
  if [ -z $1 ];then
    echo "A site name must be provided to get_good_se_from_site()"
    return 2
  else
    local Site_Name=$1
  fi

  Site_SEs=`glite-sd-query -s $Site_Name -t SRM 2>/dev/null  | grep Name | sed -e 's/Name: httpg:\/\///g' | sed -e 's/:/ /g' | cut -d ' ' -f1`
#   Site_SEs=`glite-sd-query -s $Site_Name -t SRM 2>/dev/null  | grep Name | sed -e 's/Name: httpg:\/\///g' | sed -e 's/:/ /g' | awk '{print $1}'`

#   echo "DEBUG: $Site_SEs"
  goodSE=0
  for Site_SE in $Site_SEs
  do
#     lcg-ls srm://$Site_SE/ 2>message 1>/dev/null
     echo "to be fixed" 2>message 1>/dev/null
#     echo "lcg-ls srm://$Site_SE/ 2>message 1>/dev/null" 
     result=`cat message | wc -l`
     if [ $result -gt 0 ];then
        continue
     else
        goodSE=1
        SE_HOST=$Site_SE
        break
     fi
  done
  if [ $goodSE -eq 0 ]; then
     echo "No good SRM found on site: $Site_Name"
     echo "glite-sd-query -s $Site_Name -t SRM 2>/dev/null  | grep Name | sed -e 's/Name: httpg:\/\///g' | sed -e 's/:/ /g' | cut -d ' ' -f1"
     return 1
  else
     echo "Found SE $SE_HOST at site $Site_Name"
  fi
  return 0
}

#
# Get an SE hostname and return the SE srm url including vopath in SE_SRM_LOC
# BDII_HOST and VO_NAME must be set
#  
function get_se_path()
{

  if [ -z $1 ];then
    echo "An SE hostname must be provided to get_se_path()"
    return 2
  else
    local SE_HOST=$1
  fi

  #Need to do two different queries for dcache and dpm
  echo $SE_HOST | grep -q desy
  #if [ $? == 0 ]; then
  #  query="ldapsearch -x -h $BDII_HOST -p 2170 -b \"mds-vo-name=local,o=grid\" -LLL \"(&(GlueChunkKey=GlueSEUniqueID=ennis.desy.de)(GlueVOInfoLocalID=dteam*))\" GlueVOInfoPath | grep -m 1 GlueVOInfoPath | sed -e 's/GlueVOInfoPath: //'"
  #  SE_VOPATH=`ldapsearch -x -h $BDII_HOST -p 2170 -b "mds-vo-name=local,o=grid" -LLL "(&(GlueChunkKey=GlueSEUniqueID=ennis.desy.de)(GlueVOInfoLocalID=dteam*))" GlueVOInfoPath | grep -m 1 GlueVOInfoPath | sed -e 's/GlueVOInfoPath: //'`
  #else
  #  query="ldapsearch -x -h $BDII_HOST -p 2170 -b \"mds-vo-name=local,o=grid\" -LLL \"(&(GlueSALocalID:dn:=$VO_NAME)(GlueSEUniqueID:dn:=$SE_HOST))\" GlueSAPath  | grep \"GlueSAPath: \" | sed -e 's/GlueSAPath: //'"
  #  SE_VOPATH=`ldapsearch -x -h $BDII_HOST -p 2170 -b "mds-vo-name=local,o=grid" -LLL "(&(GlueSALocalID:dn:=$VO_NAME)(GlueSEUniqueID:dn:=$SE_HOST))" GlueSAPath  | grep "GlueSAPath: " | sed -e 's/GlueSAPath: //'`
  #fi
  if [ $? == 0 ]; then
    SE_VOPATH="/dpm/desy.de/home/dteam"
  else
    SE_VOPATH="/dpm/cern.ch/home/dteam"
  fi

  if [ -z $SE_VOPATH ];then 
    echo "LDAP query failed"
    echo $query
    return 1
  fi
  SE_SRM_LOC="srm://$SE_HOST$SE_VOPATH"
  return 0
}

#
# Store all the SRMs found in the top level BDII and store them in SRMs
#
function get_all_SEs()
{

      SRMs=`glite-sd-query -t SRM  2>/dev/null | grep Name | sed -e 's/Name: httpg:\/\///g' | sed -e 's/:/ /g' | awk '{print $1}'`
      SRMs=`echo $SRMs | sed -e 's/\n//g'`
}

#
# Reserve a space on the given host and return token in $TOKEN
#Usage reserveSpace DEST_SAPATH SIZE(in bytes) DESCR
#Note: assumptions are made on the SAPATH to choose the SE type!
#
function reserveSpace() 
{
if [ $# -ne 3 ]; then
  echo "Error: reserveSpace wants 3 arguments, $# were given"
  return 1
fi
SAPATH=$1
SIZE=$2
DESCR=$3

if [ `echo $SAPATH | grep dpm` ]; then 
  #reserve space using dpm client
  token=`dpm-reservespace --gspace $SIZE --token_desc $DESCR`
  if [ $? -ne 0 ]; then
    echo "Error: reserveSpace function: error calling --gspace $SIZE --token_desc $DESCR"
    echo "$token"
    return 1
  else
    export TOKEN="$token"
  fi
elif [ `echo $SAPATH | grep desy` ]; then
  #reserve space using dcache client
  token=`srm-reserve-space -desired_size=$SIZE  -srm_protocol_version=2  -retention_policy=REPLICA -access_latency=ONLINE -guaranteed_size=$SIZE -lifetime=36000 $SAPATH -space_desc=$DESCR | grep 'Space token' | awk -F'=' '{print \$2}'`
  if [ $? -ne 0 ]; then
    echo "Error: reserveSpace function: error calling srm-reserve-space -desired_size=$SIZE  -srm_protocol_version=2  -retention_policy=REPLICA -access_latency=ONLINE -guaranteed_size=$SIZE -lifetime=36000 $SAPATH -space_desc=$DESCR"
    return 1
  else
    export TOKEN=$token
    #cross-check whether space was correctly reserved
    token_check=`dpm-getspacetokens --token_desc $DESCR`
    if [ "x$token" != "x$token_check" ]; then
      echo "Error checking token description: dpm-getspacetokens --token_desc $DESCR"
      return 1
    else
      echo "Token cross-check passed"
    fi
  fi
else 
  echo "Error: reserveSpace: cannot retrieve the SE type"
fi

return 0

}

#
# Returns the unused space in $UNUSED
# Usage get_unused_space <SPACE_TOKEN> <SA_PATH>
#
function get_unused_space() 
{
if [ $# -ne 2 ]; then
  echo "Error: get_unused_space wants 2 arguments, $# were given"
  return 1
fi
token=$1
sa_path=$2

if [ `echo $sa_path | grep dpm` ]; then 
  #get space using dpm client
  unused=`dpm-getspacemd --space_token $token | awk '{if (NR==3) print $2}'`
  if [ "x$unused" == "x" ]; then
    echo "Error: get_unused_space: no field retrieved"
    return 1
  fi
  export UNUSED=$unused
  echo "Unsed space for token $token: $unused"
  return 0
elif [ `echo $sa_path | grep desy` ]; then
  #get space using dcache client
  unused=`srm-get-space-metadata -space_tokens=$token $sa_path | awk -F":" '/unusedSize/ {print $2}'`
  if [ "x$unused" == "x" ]; then
    echo "Error: get_unused_space: no field retrieved"
    return 1
  fi
  export UNUSED=$unused
  echo "Unsed space for token $token: $unused"
  return 0
else 
  echo "Error: get_unused_space: I cannot retrieve the SE type: sa_path=$sa_path"
  return 1
fi

unused=`dpm-getspacemd --space_token $token | awk '{if (NR==3) print $2}'`
}

#
#Copy a file of a desired size in a given space on a given SE in order to 
# reduce the unused space
#Usage fill_space <size in KB> <SAPATH> <space token description>
#
function fill_space()
{
if [ $# -ne 3 ]; then
  echo "Error: fill_space wants 3 arguments, $# were given"
  return 1
fi
size=$1
sapath=$2
token_desc=$3

DATE=`date | awk '{print $2"_"$3"_"$4}' | sed -e 's/://g'`
FILENAME=FTS_Test_$DATE
TMP_FILE="/tmp/$FILENAME"
dd if=/dev/zero of=$TMP_FILE bs=${size}KB count=1 2>/dev/null

echo "Copy the test file $TMP_FILE on: $sapath/$FILENAME" 

GUID=`lcg-cr --vo $VO_NAME -d $sapath/$FILENAME -s $token_desc file://$TMP_FILE 2>message`
result=`cat message | wc -l`
if [ $result -gt 0 ]; then
  echo ">>> NOTE: `cat message`"
  echo ">>> NOTE: lcg-cr command for SRM: $sapath failed!"
  return 1
fi
echo "Removing the ${size}KB temporary test file: $TMP_FILE"
rm -rf $TMP_FILE
return 0
}


