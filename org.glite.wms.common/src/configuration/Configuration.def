%style wide

class ConfBase {

  wrapper {
    context = configuration::Configuration::instance();
  }

  section normal {

    parameter int( LogLevel );
    parameter unsigned int( LogRotationMaxFileNumber = 5 );
    parameter std::streamsize( LogFileMaxSize = 100000000 );

    template( bool )
    inline @ATTRTYPE@ @.@( @ATTRTYPE@ def = @ATTRDEF@ ) <const> { return this->getBool( @ATTRNAME@, def ); }

    template( int )
    inline @ATTRTYPE@ @.@( @ATTRTYPE@ def = @ATTRDEF@ ) <const> { return this->getInt( @ATTRNAME@, def ); }

    template( unsigned int, long, size_t, std::streamsize )
    inline @ATTRTYPE@ @.@( @ATTRTYPE@ def = @ATTRDEF@ ) <const> { return static_cast<@ATTRTYPE@>( this->getInt(@ATTRNAME@, def) ); }

    template( double )
    inline @ATTRTYPE@ @.@( @ATTRTYPE@ def = @ATTRDEF@ ) <const> { return this->getDouble( @ATTRNAME@, def ); }

    template( std::string )
    inline @ATTRTYPE@ @.@( const @ATTRTYPE@ &def = @ATTRDEF@ ) <const> { return this->getString( @ATTRNAME@, def ); }

    template( std::vector<std::string> )
    inline @ATTRTYPE@ @.@( void ) <const> { return this->getVector(@ATTRNAME@); }

    template( classad::ExprTree* )
    inline @ATTRTYPE@ @.@( void ) <const> { return this->getExpression( @ATTRNAME@ ); }

    template( classad::ClassAd* )
    inline @ATTRTYPE@ @.@( void ) <const> { return this->getClassAd( @ATTRNAME@ ); }


    ctemplate( bool -> int, std::streamsize -> long, unsigned int, int, long, size_t, double )
    @ATTRTYPE@ @CLASSPREFIX@@.@( config_error_t *error )
    {
      const configuration::Configuration   *general = @CLASSCONTEXT@;
      @CONTEXTTYPE@  config;
      @ATTRTYPE@     res( 0 );

      if( general == NULL ) {
        edg_wlcc_SetConfigurationError( "Configuration not initialized" );
        *error = edg_wlcc_uninitialized;
      }
      else {
        config = general->@CONTEXTFUNC@();

        res = static_cast<@ATTRTYPE@>( config->@FUNCNAME@() );
        *error = edg_wlcc_OK;
      }
 
      return res;
    }

    ctemplate( std::string -> char * )
    @ATTRTYPE@ @CLASSPREFIX@@.@( @ATTRTYPE@ copy, size_t *len, config_error_t *error )
    {
      const configuration::Configuration   *general = @CLASSCONTEXT@;
      @CONTEXTTYPE@ config;
      string  attr;

      if( general == NULL ) {
        edg_wlcc_SetConfigurationError( "Configuration not initialized" );
        *error = edg_wlcc_uninitialized;

        copy = NULL;
      }
      else {
        config = general->@CONTEXTFUNC@();

        attr.assign( config->@FUNCNAME@() );
        *error = edg_wlcc_OK;

        if( copy == NULL ) {
          copy = reinterpret_cast<char *>(malloc(attr.length() + 1));
          *len = attr.length();
          strcpy( copy, attr.c_str() );
        }
        else if( *len < attr.length() ) {
          copy = NULL;
          edg_wlcc_SetConfigurationError( "Must reallocate output string." );
          *error = edg_wlcc_mustrealloc;
        }
        else {
          strcpy( copy, attr.c_str() );
          *len = attr.length();
        }
      }

      return copy;
    }
  }

  section fileparse {

    parameter std::string( LogFile );
    parameter std::string( LogRotationBaseFile = "[[LogFile]]" );
    parameter std::string( LockFile );

    template( std::string )
    inline @ATTRTYPE@ @.@( const @ATTRTYPE@ &def = @ATTRDEF@ ) <const> { return this->getAndParseFileName(@ATTRNAME@, def); }

    ctemplate( std::string -> char * )
    @ATTRTYPE@ @CLASSPREFIX@@.@( @ATTRTYPE@ copy, size_t *len, config_error_t *error )
    {
      const configuration::Configuration   *general = @CLASSCONTEXT@;
      @CONTEXTTYPE@ config;
      string  attr;

      if( general == NULL ) {
        edg_wlcc_SetConfigurationError( "Configuration not initialized" );
        *error = edg_wlcc_uninitialized;

        copy = NULL;
      }
      else {
        config = general->@CONTEXTFUNC@();

        attr.assign( config->@FUNCNAME@() );
        *error = edg_wlcc_OK;

        if( copy == NULL ) {
          copy = reinterpret_cast<char *>(malloc(attr.length() + 1));
          *len = attr.length();
          strcpy( copy, attr.c_str() );
        }
        else if( *len < attr.length() ) {
          copy = NULL;
          edg_wlcc_SetConfigurationError( "Must reallocate output string." );
          *error = edg_wlcc_mustrealloc;
        }
        else {
          strcpy( copy, attr.c_str() );
          *len = attr.length();
        }
      }

      return copy;
    }
  }

  section parse {

    template( std::string )
    inline @ATTRTYPE@ @.@( const @ATTRTYPE@ &def = @ATTRDEF@ ) <const> { return this->getAndParseString(@ATTRNAME@, def); }

    ctemplate( std::string -> char * )
    @ATTRTYPE@ @CLASSPREFIX@@.@( @ATTRTYPE@ copy, size_t *len, config_error_t *error )
    {
      const configuration::Configuration  *general = @CLASSCONTEXT@;
      @CONTEXTTYPE@ config;
      string  attr;

      if( general == NULL ) {
        edg_wlcc_SetConfigurationError( "Configuration not initialized" );
        *error = edg_wlcc_uninitialized;

        copy = NULL;
      }
      else {
        config = general->@CONTEXTFUNC@();

        attr.assign( config->@FUNCNAME@() );
        *error = edg_wlcc_OK;

        if( copy == NULL ) {
          copy = reinterpret_cast<char *>(malloc(attr.length() + 1));
          *len = attr.length();
          strcpy( copy, attr.c_str() );
        }
        else if( *len < attr.length() ) {
          copy = NULL;
          edg_wlcc_SetConfigurationError( "Must reallocate output string." );
          *error = edg_wlcc_mustrealloc;
        }
        else {
          strcpy( copy, attr.c_str() );
          *len = attr.length();
        }
      }

      return copy;
    }
  }

}

class CommonConfiguration {

  defaultvalue int = 0;
  defaultvalue std::string = "";

  wrapper {
    prefix = edg_wlcc_Common_;
    contexttype = const configuration::CommonConfiguration *;
    contextfunc = common;
  }

  copy ConfBase.parse;
  copy ConfBase.fileparse;
  copy ConfBase.normal;

  parameter std::string( DGUser = "dguser" ) section parse;
  parameter std::string( HostProxyFile ) section fileparse;
  parameter bool( UseCacheInsteadOfGris = false ) section normal; 
}

class JCConfiguration {

  defaultvalue bool = false;
  defaultvalue int = 0;
  defaultvalue std::string = "";

  wrapper {
    prefix = edg_wlcc_JobController_;
    contexttype = const configuration::JCConfiguration *;
    contextfunc = jc;
  }

  copy ConfBase.parse;
  copy ConfBase.fileparse;
  copy ConfBase.normal;

  parameter bool( UseFakeForProxy ) section normal;
  parameter bool( UseFakeForReal ) section normal;

  parameter int( ContainerRefreshThreshold = 1000 ) section normal;

  parameter std::string( CondorSubmit ) section fileparse;
  parameter std::string( CondorRemove ) section fileparse;
  parameter std::string( CondorDagman ) section fileparse;
  parameter int( DagmanLogLevel ) section normal;
  parameter int( DagmanLogRotate ) section normal;
  parameter int( MaximumTimeAllowedForCondorMatch = 900 ) section normal;

  parameter std::string( Input ) section fileparse;
  parameter std::string( SubmitFileDir ) section fileparse;
  parameter std::string( OutputFileDir ) section fileparse;
}

class LMConfiguration {

  defaultvalue bool = true;
  defaultvalue int = 0;
  defaultvalue size_t = 0;
  defaultvalue std::string = "";

  wrapper {
    prefix = edg_wlcc_LogMonitor_;
    contexttype = const configuration::LMConfiguration *;
    contextfunc = lm;
  }

  copy ConfBase.normal;
  copy ConfBase.parse;
  copy ConfBase.fileparse;

  parameter bool( RemoveJobFiles = true ) section normal;
  parameter bool( UseMaradonaFile = true ) section normal;
  parameter int( JobsPerCondorLog = 1000 ) section normal;
  parameter int( MainLoopDuration = 3 ) section normal;
  parameter int( AbortedJobsTimeout = 600 ) section normal;
  parameter int( GlobusDownTimeout = 600 ) section normal;
  parameter int( ForceCancellationRetries = 10 ) section normal;
  parameter size_t( ContainersCompactThreshold = 1000 ) section normal;
  parameter std::string( CondorLogDir ) section fileparse;
  parameter std::string( CondorLogRecycleDir ) section fileparse;
  parameter std::string( ExternalLogFile ) section fileparse;
  parameter std::string( MonitorInternalDir ) section fileparse;
  parameter std::string( IdRepositoryName ) section fileparse;
  parameter std::string( MaradonaTransportProtocol = "gsiftp://${HOSTNAME}" ) section parse; 
}

class NSConfiguration {

  defaultvalue int = 0;
  defaultvalue std::string = "";
  defaultvalue bool = false;
  defaultvalue double = 0.0;

  wrapper {
    prefix = edg_wlcc_NetworkServer_;
    contexttype = const configuration::NSConfiguration *;
    contextfunc = ns;
  }

  copy ConfBase.normal;
  copy ConfBase.parse;
  copy ConfBase.fileparse;

  parameter int( BacklogSize = 16 ) section normal;
  parameter int( ListeningPort ) section normal;
  parameter int( MasterThreads ) section normal;
  parameter int( DispatcherThreads ) section normal;
  parameter long( ConnectionTimeout = 120 ) section normal;

  parameter std::string( SandboxStagingPath = "${GLITE_WMS_TMP}/SandboxDir" ) section fileparse;
  parameter std::string( ListMatchRootPath = "/tmp" ) section fileparse;

  parameter double( MaxInputSandboxSize = 10000000 ) section normal;
  parameter bool( EnableQuotaManagement = false ) section normal; 
  parameter bool( EnableDynamicQuotaAdjustment = false) section normal;
  parameter long( QuotaAdjustmentAmount = 10000 ) section normal;
  parameter double( QuotaInsensibleDiskPortion = 0.0 ) section normal;  

#
#  Parameters to query the II for the schema...
#
  parameter int( II_Port = 2170 ) section normal;
  parameter int( Gris_Port = 2135 ) section normal;
  parameter int( II_Timeout = 60 ) section normal;
  parameter int( GrisTimeout = 60 ) section normal;
  parameter std::string( II_DN ) section normal;
  parameter std::string( Gris_DN ) section normal;
  parameter std::string( II_Contact ) section normal;
#
# If RLS should used for a VO, the following vector determines
# whether a certain VO uses RLS. Example usage:
# RLSCatalog = { "lhcb","cms","anotherVo"};
# Should probably be moved out of NSi config, like the II config above.
#
  parameter std::vector<std::string> ( RLSCatalog ) section normal;

# Remote catalog connection and IO timeout
  parameter int ( DLI_SI_CatalogTimeout = 0 ) section normal;

}

class WMConfiguration {

  defaultvalue bool = false;
  defaultvalue int = 0;
  defaultvalue std::string = "";

  wrapper {
    prefix = edg_wlcc_WorkloadManager_;
    contexttype = const configuration::WMConfiguration *;
    contextfunc = wm;
  }

  copy ConfBase.normal;
  copy ConfBase.parse;
  copy ConfBase.fileparse;

  parameter bool(Fake = false) section normal;
  parameter int(PipeDepth = 10) section normal;
  parameter int(WorkerThreads = 1) section normal;
  parameter int(InputIterations = 1) section normal;
  parameter int(MaxRetryCount = 10) section normal;
  parameter int(MaxShallowRetryCount = 10) section normal;
  parameter bool(EnableRecovery = false) section normal;
  parameter std::string(Input = "${EDG_WL_TMP}/workload_manager/input.fl") section fileparse;
  parameter std::string(IsmDump = "${GLITE_WMS_TMP}/workload_manager/ismdump.fl") section fileparse;
  parameter bool(EnableIsmDump = true) section normal;
  parameter int(IsmUpdateRate = 50) section normal;
  parameter int(IsmDumpRate = 50) section normal;
  parameter std::vector<std::string>(IsmBlackList) section normal;
  parameter std::string(DispatcherType = "filelist") section normal;
  parameter std::vector<std::string>(CeMonitorServices) section normal;
  parameter int(CeMonitorAsynchPort = -1) section normal;
  parameter int(IsmIiPurchasingRate = 240) section normal;
  parameter int(IsmCEMonPurchasingRate = 120) section normal;
  parameter int(IsmCEMonAsynchPurchasingRate = 30) section normal;
  parameter bool(DisablePurchasingFromGris = false) section normal;
  parameter bool(EnablePurchasingFromRgma = false) section normal;
  parameter int(RgmaQueryTimeout = 30) section normal;
  parameter int(RgmaConsumerTtl = 300) section normal;
  parameter int(RgmaConsumerLifeCycle = 30) section normal;
  parameter int(IsmRgmaPurchasingRate = 120) section normal;
  parameter std::string(TokenFile = "token.txt") section fileparse;
  parameter std::string(DliServiceName = "data-location-interface") section normal;
  parameter std::string(SiServiceName = "org.glite.SEIndex") section normal;
  parameter std::string(JobWrapperTemplateDir = "${GLITE_WMS_LOCATION}/etc/templates") section fileparse;
  parameter std::string(PboxHostName) section fileparse;
  parameter int(PboxPortNum = 6699) section normal;
  parameter bool(PboxSafeMode = false) section normal;
}
class WMCConfiguration {

  defaultvalue bool = false;
  defaultvalue int = 0;
  defaultvalue std::string = "";

  wrapper {
    prefix = edg_wlcc_WmsClient_;
    contexttype = const configuration::WMCConfiguration *;
    contextfunc = wc;
  }

  copy ConfBase.normal;
  copy ConfBase.parse;
  copy ConfBase.fileparse;

#  parameter std::string(VirtualOrganisation) section normal;
#  parameter int(RetryCount = 3) section normal;
#  parameter int(ShallowRetryCount = 3) section normal;
#  parameter classad::ExprTree*(requirements) section normal;
#  parameter classad::ExprTree*(rank) section normal;
#  parameter std::string(HLRLocation) section normal;
#  parameter std::string(MyProxyServer) section normal;
#  parameter std::string(JobProvenance) section normal;
#  parameter bool(PerusalFileEnable=false) section normal;
#  parameter bool(AllowZippedISB=false) section normal;

# Minimal value for proxy validity (in minutes)
  parameter int(DefaultProxyValidity= 5) section normal;
  parameter int(DefaultStatusLevel  = 1) section normal;
  parameter int(DefaultLoggingLevel = 0) section normal;
  parameter std::string(ErrorStorage=   "/var/tmp") section normal;
  parameter std::string(OutputStorage=  "/tmp") section normal;
  parameter std::string(ListenerStorage="/tmp") section normal;

  parameter std::vector<std::string>(WmProxyEndPoints) section normal;
# LB WS-based interface not yet used:
# parameter std::vector<std::string>(LBEndPoints) section normal;
  parameter classad::ClassAd*(JdlDefaultAttributes) section normal;
}
class WMPConfiguration {

  defaultvalue bool = false;
  defaultvalue int = 0;
  defaultvalue std::string = "";

  wrapper {
    prefix = edg_wlcc_WorkloadManagerProxy_;
    contexttype = const configuration::WMPConfiguration *;
    contextfunc = wp;
  }

  copy ConfBase.normal;
  copy ConfBase.parse;
  copy ConfBase.fileparse;

  parameter int ( HTTPSPort ) section normal;
  parameter int ( GridFTPPort ) section normal;

  parameter int ( MinPerusalTimeInterval ) section normal;

  parameter std::string ( DefaultProtocol ) section normal;

  parameter double ( MaxInputSandboxSize = 10000000 ) section normal;
  parameter std::string ( SandboxStagingPath = "${GLITE_WMS_TMP}/SandboxDir" ) section fileparse;
  parameter std::string ( ListMatchRootPath = "/tmp" ) section fileparse;

  parameter bool ( LBProxy = true ) section normal;
  parameter std::string ( LBServer ) section normal;
  parameter std::string ( LBLocalLogger ) section normal;

  parameter bool ( AsyncJobStart = true ) section normal;
}
