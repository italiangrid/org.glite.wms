/* soapC.cpp
   Generated by gSOAP 2.7.16 from wm.h
   Copyright(C) 2000-2010, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.16 2012-11-09 09:45:19 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_jsdl__CreationFlagEnumeration:
		return soap_in_jsdl__CreationFlagEnumeration(soap, NULL, NULL, "jsdl:CreationFlagEnumeration");
	case SOAP_TYPE_jsdl__FileSystemTypeEnumeration:
		return soap_in_jsdl__FileSystemTypeEnumeration(soap, NULL, NULL, "jsdl:FileSystemTypeEnumeration");
	case SOAP_TYPE_jsdl__OperatingSystemTypeEnumeration:
		return soap_in_jsdl__OperatingSystemTypeEnumeration(soap, NULL, NULL, "jsdl:OperatingSystemTypeEnumeration");
	case SOAP_TYPE_jsdl__ProcessorArchitectureEnumeration:
		return soap_in_jsdl__ProcessorArchitectureEnumeration(soap, NULL, NULL, "jsdl:ProcessorArchitectureEnumeration");
	case SOAP_TYPE_ns1__JdlType:
		return soap_in_ns1__JdlType(soap, NULL, NULL, "ns1:JdlType");
	case SOAP_TYPE_ns1__JobType:
		return soap_in_ns1__JobType(soap, NULL, NULL, "ns1:JobType");
	case SOAP_TYPE_ns1__ObjectType:
		return soap_in_ns1__ObjectType(soap, NULL, NULL, "ns1:ObjectType");
	case SOAP_TYPE_jsdl__Description_USCOREType:
		return soap_in_jsdl__Description_USCOREType(soap, NULL, NULL, "jsdl:Description_Type");
	case SOAP_TYPE_delegation1__DelegationExceptionType:
		return soap_in_delegation1__DelegationExceptionType(soap, NULL, NULL, "delegation1:DelegationExceptionType");
	case SOAP_TYPE_delegationns__NewProxyReq:
		return soap_in_delegationns__NewProxyReq(soap, NULL, NULL, "delegationns:NewProxyReq");
	case SOAP_TYPE_jsdlposix__POSIXApplication_USCOREType:
		return soap_in_jsdlposix__POSIXApplication_USCOREType(soap, NULL, NULL, "jsdlposix:POSIXApplication_Type");
	case SOAP_TYPE_jsdlposix__GroupName_USCOREType:
		return soap_in_jsdlposix__GroupName_USCOREType(soap, NULL, NULL, "jsdlposix:GroupName_Type");
	case SOAP_TYPE_jsdlposix__UserName_USCOREType:
		return soap_in_jsdlposix__UserName_USCOREType(soap, NULL, NULL, "jsdlposix:UserName_Type");
	case SOAP_TYPE_jsdlposix__Limits_USCOREType:
		return soap_in_jsdlposix__Limits_USCOREType(soap, NULL, NULL, "jsdlposix:Limits_Type");
	case SOAP_TYPE_jsdlposix__DirectoryName_USCOREType:
		return soap_in_jsdlposix__DirectoryName_USCOREType(soap, NULL, NULL, "jsdlposix:DirectoryName_Type");
	case SOAP_TYPE_jsdlposix__FileName_USCOREType:
		return soap_in_jsdlposix__FileName_USCOREType(soap, NULL, NULL, "jsdlposix:FileName_Type");
	case SOAP_TYPE_jsdlposix__Argument_USCOREType:
		return soap_in_jsdlposix__Argument_USCOREType(soap, NULL, NULL, "jsdlposix:Argument_Type");
	case SOAP_TYPE_jsdlposix__Environment_USCOREType:
		return soap_in_jsdlposix__Environment_USCOREType(soap, NULL, NULL, "jsdlposix:Environment_Type");
	case SOAP_TYPE_jsdl__SourceTarget_USCOREType:
		return soap_in_jsdl__SourceTarget_USCOREType(soap, NULL, NULL, "jsdl:SourceTarget_Type");
	case SOAP_TYPE_jsdl__DataStaging_USCOREType:
		return soap_in_jsdl__DataStaging_USCOREType(soap, NULL, NULL, "jsdl:DataStaging_Type");
	case SOAP_TYPE_jsdl__OperatingSystemType_USCOREType:
		return soap_in_jsdl__OperatingSystemType_USCOREType(soap, NULL, NULL, "jsdl:OperatingSystemType_Type");
	case SOAP_TYPE_jsdl__OperatingSystem_USCOREType:
		return soap_in_jsdl__OperatingSystem_USCOREType(soap, NULL, NULL, "jsdl:OperatingSystem_Type");
	case SOAP_TYPE_jsdl__FileSystem_USCOREType:
		return soap_in_jsdl__FileSystem_USCOREType(soap, NULL, NULL, "jsdl:FileSystem_Type");
	case SOAP_TYPE_jsdl__CPUArchitecture_USCOREType:
		return soap_in_jsdl__CPUArchitecture_USCOREType(soap, NULL, NULL, "jsdl:CPUArchitecture_Type");
	case SOAP_TYPE_jsdl__CandidateHosts_USCOREType:
		return soap_in_jsdl__CandidateHosts_USCOREType(soap, NULL, NULL, "jsdl:CandidateHosts_Type");
	case SOAP_TYPE_jsdl__Resources_USCOREType:
		return soap_in_jsdl__Resources_USCOREType(soap, NULL, NULL, "jsdl:Resources_Type");
	case SOAP_TYPE_jsdl__Application_USCOREType:
		return soap_in_jsdl__Application_USCOREType(soap, NULL, NULL, "jsdl:Application_Type");
	case SOAP_TYPE_jsdl__JobIdentification_USCOREType:
		return soap_in_jsdl__JobIdentification_USCOREType(soap, NULL, NULL, "jsdl:JobIdentification_Type");
	case SOAP_TYPE_jsdl__JobDescription_USCOREType:
		return soap_in_jsdl__JobDescription_USCOREType(soap, NULL, NULL, "jsdl:JobDescription_Type");
	case SOAP_TYPE_jsdl__JobDefinition_USCOREType:
		return soap_in_jsdl__JobDefinition_USCOREType(soap, NULL, NULL, "jsdl:JobDefinition_Type");
	case SOAP_TYPE_jsdl__RangeValue_USCOREType:
		return soap_in_jsdl__RangeValue_USCOREType(soap, NULL, NULL, "jsdl:RangeValue_Type");
	case SOAP_TYPE_jsdl__Range_USCOREType:
		return soap_in_jsdl__Range_USCOREType(soap, NULL, NULL, "jsdl:Range_Type");
	case SOAP_TYPE_jsdl__Exact_USCOREType:
		return soap_in_jsdl__Exact_USCOREType(soap, NULL, NULL, "jsdl:Exact_Type");
	case SOAP_TYPE_jsdl__Boundary_USCOREType:
		return soap_in_jsdl__Boundary_USCOREType(soap, NULL, NULL, "jsdl:Boundary_Type");
	case SOAP_TYPE_ns1__ServerOverloadedFaultType:
		return soap_in_ns1__ServerOverloadedFaultType(soap, NULL, NULL, "ns1:ServerOverloadedFaultType");
	case SOAP_TYPE_ns1__OperationNotAllowedFaultType:
		return soap_in_ns1__OperationNotAllowedFaultType(soap, NULL, NULL, "ns1:OperationNotAllowedFaultType");
	case SOAP_TYPE_ns1__JobUnknownFaultType:
		return soap_in_ns1__JobUnknownFaultType(soap, NULL, NULL, "ns1:JobUnknownFaultType");
	case SOAP_TYPE_ns1__NoSuitableResourcesFaultType:
		return soap_in_ns1__NoSuitableResourcesFaultType(soap, NULL, NULL, "ns1:NoSuitableResourcesFaultType");
	case SOAP_TYPE_ns1__GetQuotaManagementFaultType:
		return soap_in_ns1__GetQuotaManagementFaultType(soap, NULL, NULL, "ns1:GetQuotaManagementFaultType");
	case SOAP_TYPE_ns1__InvalidArgumentFaultType:
		return soap_in_ns1__InvalidArgumentFaultType(soap, NULL, NULL, "ns1:InvalidArgumentFaultType");
	case SOAP_TYPE_ns1__AuthorizationFaultType:
		return soap_in_ns1__AuthorizationFaultType(soap, NULL, NULL, "ns1:AuthorizationFaultType");
	case SOAP_TYPE_ns1__AuthenticationFaultType:
		return soap_in_ns1__AuthenticationFaultType(soap, NULL, NULL, "ns1:AuthenticationFaultType");
	case SOAP_TYPE_ns1__GenericFaultType:
		return soap_in_ns1__GenericFaultType(soap, NULL, NULL, "ns1:GenericFaultType");
	case SOAP_TYPE_ns1__BaseFaultType:
		return soap_in_ns1__BaseFaultType(soap, NULL, NULL, "ns1:BaseFaultType");
	case SOAP_TYPE_ns1__ProxyInfoStructType:
		return soap_in_ns1__ProxyInfoStructType(soap, NULL, NULL, "ns1:ProxyInfoStructType");
	case SOAP_TYPE_ns1__VOProxyInfoStructType:
		return soap_in_ns1__VOProxyInfoStructType(soap, NULL, NULL, "ns1:VOProxyInfoStructType");
	case SOAP_TYPE_ns1__GraphStructType:
		return soap_in_ns1__GraphStructType(soap, NULL, NULL, "ns1:GraphStructType");
	case SOAP_TYPE_ns1__JobIdStructType:
		return soap_in_ns1__JobIdStructType(soap, NULL, NULL, "ns1:JobIdStructType");
	case SOAP_TYPE_ns1__JobStatusStructType:
		return soap_in_ns1__JobStatusStructType(soap, NULL, NULL, "ns1:JobStatusStructType");
	case SOAP_TYPE_ns1__StringAndLongList:
		return soap_in_ns1__StringAndLongList(soap, NULL, NULL, "ns1:StringAndLongList");
	case SOAP_TYPE_ns1__StringAndLongType:
		return soap_in_ns1__StringAndLongType(soap, NULL, NULL, "ns1:StringAndLongType");
	case SOAP_TYPE_ns1__DestURIsStructType:
		return soap_in_ns1__DestURIsStructType(soap, NULL, NULL, "ns1:DestURIsStructType");
	case SOAP_TYPE_ns1__DestURIStructType:
		return soap_in_ns1__DestURIStructType(soap, NULL, NULL, "ns1:DestURIStructType");
	case SOAP_TYPE_ns1__StringList:
		return soap_in_ns1__StringList(soap, NULL, NULL, "ns1:StringList");
	case SOAP_TYPE_ns1__JobTypeList:
		return soap_in_ns1__JobTypeList(soap, NULL, NULL, "ns1:JobTypeList");
	case SOAP_TYPE_xsd__normalizedString:
		return soap_in_xsd__normalizedString(soap, NULL, NULL, "xsd:normalizedString");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__anyURI:
		return soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_xsd__NCName:
		return soap_in_xsd__NCName(soap, NULL, NULL, "xsd:NCName");
	case SOAP_TYPE_xsd__ID:
		return soap_in_xsd__ID(soap, NULL, NULL, "xsd:ID");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns1__getJobStatus:
		return soap_in_ns1__getJobStatus(soap, NULL, NULL, "ns1:getJobStatus");
	case SOAP_TYPE_ns1__getJobStatusResponse:
		return soap_in_ns1__getJobStatusResponse(soap, NULL, NULL, "ns1:getJobStatusResponse");
	case SOAP_TYPE_ns1__getTransferProtocols:
		return soap_in_ns1__getTransferProtocols(soap, NULL, NULL, "ns1:getTransferProtocols");
	case SOAP_TYPE_ns1__getTransferProtocolsResponse:
		return soap_in_ns1__getTransferProtocolsResponse(soap, NULL, NULL, "ns1:getTransferProtocolsResponse");
	case SOAP_TYPE_ns1__getPerusalFiles:
		return soap_in_ns1__getPerusalFiles(soap, NULL, NULL, "ns1:getPerusalFiles");
	case SOAP_TYPE_ns1__getPerusalFilesResponse:
		return soap_in_ns1__getPerusalFilesResponse(soap, NULL, NULL, "ns1:getPerusalFilesResponse");
	case SOAP_TYPE_ns1__enableFilePerusal:
		return soap_in_ns1__enableFilePerusal(soap, NULL, NULL, "ns1:enableFilePerusal");
	case SOAP_TYPE_ns1__enableFilePerusalResponse:
		return soap_in_ns1__enableFilePerusalResponse(soap, NULL, NULL, "ns1:enableFilePerusalResponse");
	case SOAP_TYPE_ns1__getJobProxyInfo:
		return soap_in_ns1__getJobProxyInfo(soap, NULL, NULL, "ns1:getJobProxyInfo");
	case SOAP_TYPE_ns1__getJobProxyInfoResponse:
		return soap_in_ns1__getJobProxyInfoResponse(soap, NULL, NULL, "ns1:getJobProxyInfoResponse");
	case SOAP_TYPE_ns1__getDelegatedProxyInfo:
		return soap_in_ns1__getDelegatedProxyInfo(soap, NULL, NULL, "ns1:getDelegatedProxyInfo");
	case SOAP_TYPE_ns1__getDelegatedProxyInfoResponse:
		return soap_in_ns1__getDelegatedProxyInfoResponse(soap, NULL, NULL, "ns1:getDelegatedProxyInfoResponse");
	case SOAP_TYPE_ns1__removeACLItem:
		return soap_in_ns1__removeACLItem(soap, NULL, NULL, "ns1:removeACLItem");
	case SOAP_TYPE_ns1__removeACLItemResponse:
		return soap_in_ns1__removeACLItemResponse(soap, NULL, NULL, "ns1:removeACLItemResponse");
	case SOAP_TYPE_ns1__addACLItems:
		return soap_in_ns1__addACLItems(soap, NULL, NULL, "ns1:addACLItems");
	case SOAP_TYPE_ns1__addACLItemsResponse:
		return soap_in_ns1__addACLItemsResponse(soap, NULL, NULL, "ns1:addACLItemsResponse");
	case SOAP_TYPE_ns1__getACLItems:
		return soap_in_ns1__getACLItems(soap, NULL, NULL, "ns1:getACLItems");
	case SOAP_TYPE_ns1__getACLItemsResponse:
		return soap_in_ns1__getACLItemsResponse(soap, NULL, NULL, "ns1:getACLItemsResponse");
	case SOAP_TYPE_ns1__getStringParametricJobTemplate:
		return soap_in_ns1__getStringParametricJobTemplate(soap, NULL, NULL, "ns1:getStringParametricJobTemplate");
	case SOAP_TYPE_ns1__getStringParametricJobTemplateResponse:
		return soap_in_ns1__getStringParametricJobTemplateResponse(soap, NULL, NULL, "ns1:getStringParametricJobTemplateResponse");
	case SOAP_TYPE_ns1__getIntParametricJobTemplate:
		return soap_in_ns1__getIntParametricJobTemplate(soap, NULL, NULL, "ns1:getIntParametricJobTemplate");
	case SOAP_TYPE_ns1__getIntParametricJobTemplateResponse:
		return soap_in_ns1__getIntParametricJobTemplateResponse(soap, NULL, NULL, "ns1:getIntParametricJobTemplateResponse");
	case SOAP_TYPE_ns1__getCollectionTemplate:
		return soap_in_ns1__getCollectionTemplate(soap, NULL, NULL, "ns1:getCollectionTemplate");
	case SOAP_TYPE_ns1__getCollectionTemplateResponse:
		return soap_in_ns1__getCollectionTemplateResponse(soap, NULL, NULL, "ns1:getCollectionTemplateResponse");
	case SOAP_TYPE_ns1__getDAGTemplate:
		return soap_in_ns1__getDAGTemplate(soap, NULL, NULL, "ns1:getDAGTemplate");
	case SOAP_TYPE_ns1__getDAGTemplateResponse:
		return soap_in_ns1__getDAGTemplateResponse(soap, NULL, NULL, "ns1:getDAGTemplateResponse");
	case SOAP_TYPE_ns1__getJobTemplate:
		return soap_in_ns1__getJobTemplate(soap, NULL, NULL, "ns1:getJobTemplate");
	case SOAP_TYPE_ns1__getJobTemplateResponse:
		return soap_in_ns1__getJobTemplateResponse(soap, NULL, NULL, "ns1:getJobTemplateResponse");
	case SOAP_TYPE_ns1__jobListMatchJSDL:
		return soap_in_ns1__jobListMatchJSDL(soap, NULL, NULL, "ns1:jobListMatchJSDL");
	case SOAP_TYPE_ns1__jobListMatchJSDLResponse:
		return soap_in_ns1__jobListMatchJSDLResponse(soap, NULL, NULL, "ns1:jobListMatchJSDLResponse");
	case SOAP_TYPE_ns1__jobListMatch:
		return soap_in_ns1__jobListMatch(soap, NULL, NULL, "ns1:jobListMatch");
	case SOAP_TYPE_ns1__jobListMatchResponse:
		return soap_in_ns1__jobListMatchResponse(soap, NULL, NULL, "ns1:jobListMatchResponse");
	case SOAP_TYPE_ns1__getOutputFileList:
		return soap_in_ns1__getOutputFileList(soap, NULL, NULL, "ns1:getOutputFileList");
	case SOAP_TYPE_ns1__getOutputFileListResponse:
		return soap_in_ns1__getOutputFileListResponse(soap, NULL, NULL, "ns1:getOutputFileListResponse");
	case SOAP_TYPE_ns1__jobPurge:
		return soap_in_ns1__jobPurge(soap, NULL, NULL, "ns1:jobPurge");
	case SOAP_TYPE_ns1__jobPurgeResponse:
		return soap_in_ns1__jobPurgeResponse(soap, NULL, NULL, "ns1:jobPurgeResponse");
	case SOAP_TYPE_ns1__getFreeQuota:
		return soap_in_ns1__getFreeQuota(soap, NULL, NULL, "ns1:getFreeQuota");
	case SOAP_TYPE_ns1__getFreeQuotaResponse:
		return soap_in_ns1__getFreeQuotaResponse(soap, NULL, NULL, "ns1:getFreeQuotaResponse");
	case SOAP_TYPE_ns1__getTotalQuota:
		return soap_in_ns1__getTotalQuota(soap, NULL, NULL, "ns1:getTotalQuota");
	case SOAP_TYPE_ns1__getTotalQuotaResponse:
		return soap_in_ns1__getTotalQuotaResponse(soap, NULL, NULL, "ns1:getTotalQuotaResponse");
	case SOAP_TYPE_ns1__getSandboxBulkDestURI:
		return soap_in_ns1__getSandboxBulkDestURI(soap, NULL, NULL, "ns1:getSandboxBulkDestURI");
	case SOAP_TYPE_ns1__getSandboxBulkDestURIResponse:
		return soap_in_ns1__getSandboxBulkDestURIResponse(soap, NULL, NULL, "ns1:getSandboxBulkDestURIResponse");
	case SOAP_TYPE_ns1__getSandboxDestURI:
		return soap_in_ns1__getSandboxDestURI(soap, NULL, NULL, "ns1:getSandboxDestURI");
	case SOAP_TYPE_ns1__getSandboxDestURIResponse:
		return soap_in_ns1__getSandboxDestURIResponse(soap, NULL, NULL, "ns1:getSandboxDestURIResponse");
	case SOAP_TYPE_ns1__getMaxInputSandboxSize:
		return soap_in_ns1__getMaxInputSandboxSize(soap, NULL, NULL, "ns1:getMaxInputSandboxSize");
	case SOAP_TYPE_ns1__getMaxInputSandboxSizeResponse:
		return soap_in_ns1__getMaxInputSandboxSizeResponse(soap, NULL, NULL, "ns1:getMaxInputSandboxSizeResponse");
	case SOAP_TYPE_ns1__jobCancel:
		return soap_in_ns1__jobCancel(soap, NULL, NULL, "ns1:jobCancel");
	case SOAP_TYPE_ns1__jobCancelResponse:
		return soap_in_ns1__jobCancelResponse(soap, NULL, NULL, "ns1:jobCancelResponse");
	case SOAP_TYPE_ns1__jobSubmitJSDL:
		return soap_in_ns1__jobSubmitJSDL(soap, NULL, NULL, "ns1:jobSubmitJSDL");
	case SOAP_TYPE_ns1__jobSubmitJSDLResponse:
		return soap_in_ns1__jobSubmitJSDLResponse(soap, NULL, NULL, "ns1:jobSubmitJSDLResponse");
	case SOAP_TYPE_ns1__jobSubmit:
		return soap_in_ns1__jobSubmit(soap, NULL, NULL, "ns1:jobSubmit");
	case SOAP_TYPE_ns1__jobSubmitResponse:
		return soap_in_ns1__jobSubmitResponse(soap, NULL, NULL, "ns1:jobSubmitResponse");
	case SOAP_TYPE_ns1__jobStart:
		return soap_in_ns1__jobStart(soap, NULL, NULL, "ns1:jobStart");
	case SOAP_TYPE_ns1__jobStartResponse:
		return soap_in_ns1__jobStartResponse(soap, NULL, NULL, "ns1:jobStartResponse");
	case SOAP_TYPE_ns1__jobRegisterJSDL:
		return soap_in_ns1__jobRegisterJSDL(soap, NULL, NULL, "ns1:jobRegisterJSDL");
	case SOAP_TYPE_ns1__jobRegisterJSDLResponse:
		return soap_in_ns1__jobRegisterJSDLResponse(soap, NULL, NULL, "ns1:jobRegisterJSDLResponse");
	case SOAP_TYPE_ns1__jobRegister:
		return soap_in_ns1__jobRegister(soap, NULL, NULL, "ns1:jobRegister");
	case SOAP_TYPE_ns1__jobRegisterResponse:
		return soap_in_ns1__jobRegisterResponse(soap, NULL, NULL, "ns1:jobRegisterResponse");
	case SOAP_TYPE_ns1__getJDL:
		return soap_in_ns1__getJDL(soap, NULL, NULL, "ns1:getJDL");
	case SOAP_TYPE_ns1__getJDLResponse:
		return soap_in_ns1__getJDLResponse(soap, NULL, NULL, "ns1:getJDLResponse");
	case SOAP_TYPE_ns1__getVersion:
		return soap_in_ns1__getVersion(soap, NULL, NULL, "ns1:getVersion");
	case SOAP_TYPE_ns1__getVersionResponse:
		return soap_in_ns1__getVersionResponse(soap, NULL, NULL, "ns1:getVersionResponse");
	case SOAP_TYPE_ns1__putProxy:
		return soap_in_ns1__putProxy(soap, NULL, NULL, "ns1:putProxy");
	case SOAP_TYPE_ns1__putProxyResponse:
		return soap_in_ns1__putProxyResponse(soap, NULL, NULL, "ns1:putProxyResponse");
	case SOAP_TYPE_ns1__getProxyReq:
		return soap_in_ns1__getProxyReq(soap, NULL, NULL, "ns1:getProxyReq");
	case SOAP_TYPE_ns1__getProxyReqResponse:
		return soap_in_ns1__getProxyReqResponse(soap, NULL, NULL, "ns1:getProxyReqResponse");
	case SOAP_TYPE_delegationns__destroy:
		return soap_in_delegationns__destroy(soap, NULL, NULL, "delegationns:destroy");
	case SOAP_TYPE_delegationns__destroyResponse:
		return soap_in_delegationns__destroyResponse(soap, NULL, NULL, "delegationns:destroyResponse");
	case SOAP_TYPE_delegationns__getTerminationTime:
		return soap_in_delegationns__getTerminationTime(soap, NULL, NULL, "delegationns:getTerminationTime");
	case SOAP_TYPE_delegationns__getTerminationTimeResponse:
		return soap_in_delegationns__getTerminationTimeResponse(soap, NULL, NULL, "delegationns:getTerminationTimeResponse");
	case SOAP_TYPE_delegationns__putProxy:
		return soap_in_delegationns__putProxy(soap, NULL, NULL, "delegationns:putProxy");
	case SOAP_TYPE_delegationns__putProxyResponse:
		return soap_in_delegationns__putProxyResponse(soap, NULL, NULL, "delegationns:putProxyResponse");
	case SOAP_TYPE_delegationns__renewProxyReq:
		return soap_in_delegationns__renewProxyReq(soap, NULL, NULL, "delegationns:renewProxyReq");
	case SOAP_TYPE_delegationns__renewProxyReqResponse:
		return soap_in_delegationns__renewProxyReqResponse(soap, NULL, NULL, "delegationns:renewProxyReqResponse");
	case SOAP_TYPE_delegationns__getNewProxyReq:
		return soap_in_delegationns__getNewProxyReq(soap, NULL, NULL, "delegationns:getNewProxyReq");
	case SOAP_TYPE_delegationns__getNewProxyReqResponse:
		return soap_in_delegationns__getNewProxyReqResponse(soap, NULL, NULL, "delegationns:getNewProxyReqResponse");
	case SOAP_TYPE_delegationns__getProxyReq:
		return soap_in_delegationns__getProxyReq(soap, NULL, NULL, "delegationns:getProxyReq");
	case SOAP_TYPE_delegationns__getProxyReqResponse:
		return soap_in_delegationns__getProxyReqResponse(soap, NULL, NULL, "delegationns:getProxyReqResponse");
	case SOAP_TYPE_delegationns__getServiceMetadata:
		return soap_in_delegationns__getServiceMetadata(soap, NULL, NULL, "delegationns:getServiceMetadata");
	case SOAP_TYPE_delegationns__getServiceMetadataResponse:
		return soap_in_delegationns__getServiceMetadataResponse(soap, NULL, NULL, "delegationns:getServiceMetadataResponse");
	case SOAP_TYPE_delegationns__getInterfaceVersion:
		return soap_in_delegationns__getInterfaceVersion(soap, NULL, NULL, "delegationns:getInterfaceVersion");
	case SOAP_TYPE_delegationns__getInterfaceVersionResponse:
		return soap_in_delegationns__getInterfaceVersionResponse(soap, NULL, NULL, "delegationns:getInterfaceVersionResponse");
	case SOAP_TYPE_delegationns__getVersion:
		return soap_in_delegationns__getVersion(soap, NULL, NULL, "delegationns:getVersion");
	case SOAP_TYPE_delegationns__getVersionResponse:
		return soap_in_delegationns__getVersionResponse(soap, NULL, NULL, "delegationns:getVersionResponse");
	case SOAP_TYPE_delegation1__putProxy:
		return soap_in_delegation1__putProxy(soap, NULL, NULL, "delegation1:putProxy");
	case SOAP_TYPE_delegation1__putProxyResponse:
		return soap_in_delegation1__putProxyResponse(soap, NULL, NULL, "delegation1:putProxyResponse");
	case SOAP_TYPE_delegation1__getProxyReq:
		return soap_in_delegation1__getProxyReq(soap, NULL, NULL, "delegation1:getProxyReq");
	case SOAP_TYPE_delegation1__getProxyReqResponse:
		return soap_in_delegation1__getProxyReqResponse(soap, NULL, NULL, "delegation1:getProxyReqResponse");
	case SOAP_TYPE_PointerTons1__ProxyInfoStructType:
		return soap_in_PointerTons1__ProxyInfoStructType(soap, NULL, NULL, "ns1:ProxyInfoStructType");
	case SOAP_TYPE_PointerTons1__JobTypeList:
		return soap_in_PointerTons1__JobTypeList(soap, NULL, NULL, "ns1:JobTypeList");
	case SOAP_TYPE_PointerTons1__StringAndLongList:
		return soap_in_PointerTons1__StringAndLongList(soap, NULL, NULL, "ns1:StringAndLongList");
	case SOAP_TYPE_PointerTons1__DestURIsStructType:
		return soap_in_PointerTons1__DestURIsStructType(soap, NULL, NULL, "ns1:DestURIsStructType");
	case SOAP_TYPE_PointerTons1__StringList:
		return soap_in_PointerTons1__StringList(soap, NULL, NULL, "ns1:StringList");
	case SOAP_TYPE_PointerTojsdl__JobDefinition_USCOREType:
		return soap_in_PointerTojsdl__JobDefinition_USCOREType(soap, NULL, NULL, "jsdl:JobDefinition_Type");
	case SOAP_TYPE_PointerTodelegationns__NewProxyReq:
		return soap_in_PointerTodelegationns__NewProxyReq(soap, NULL, NULL, "delegationns:NewProxyReq");
	case SOAP_TYPE_PointerTons1__ServerOverloadedFaultType:
		return soap_in_PointerTons1__ServerOverloadedFaultType(soap, NULL, NULL, "ns1:ServerOverloadedFaultType");
	case SOAP_TYPE_PointerTons1__OperationNotAllowedFaultType:
		return soap_in_PointerTons1__OperationNotAllowedFaultType(soap, NULL, NULL, "ns1:OperationNotAllowedFaultType");
	case SOAP_TYPE_PointerTons1__NoSuitableResourcesFaultType:
		return soap_in_PointerTons1__NoSuitableResourcesFaultType(soap, NULL, NULL, "ns1:NoSuitableResourcesFaultType");
	case SOAP_TYPE_PointerTons1__JobUnknownFaultType:
		return soap_in_PointerTons1__JobUnknownFaultType(soap, NULL, NULL, "ns1:JobUnknownFaultType");
	case SOAP_TYPE_PointerTons1__InvalidArgumentFaultType:
		return soap_in_PointerTons1__InvalidArgumentFaultType(soap, NULL, NULL, "ns1:InvalidArgumentFaultType");
	case SOAP_TYPE_PointerTons1__GetQuotaManagementFaultType:
		return soap_in_PointerTons1__GetQuotaManagementFaultType(soap, NULL, NULL, "ns1:GetQuotaManagementFaultType");
	case SOAP_TYPE_PointerTons1__GenericFaultType:
		return soap_in_PointerTons1__GenericFaultType(soap, NULL, NULL, "ns1:GenericFaultType");
	case SOAP_TYPE_PointerTons1__AuthorizationFaultType:
		return soap_in_PointerTons1__AuthorizationFaultType(soap, NULL, NULL, "ns1:AuthorizationFaultType");
	case SOAP_TYPE_PointerTons1__AuthenticationFaultType:
		return soap_in_PointerTons1__AuthenticationFaultType(soap, NULL, NULL, "ns1:AuthenticationFaultType");
	case SOAP_TYPE_PointerTo_delegationns__DelegationException:
		return soap_in_PointerTo_delegationns__DelegationException(soap, NULL, NULL, "delegationns:DelegationException");
	case SOAP_TYPE_PointerTodelegation1__DelegationExceptionType:
		return soap_in_PointerTodelegation1__DelegationExceptionType(soap, NULL, NULL, "delegation1:DelegationExceptionType");
	case SOAP_TYPE_PointerTodouble:
		return soap_in_PointerTodouble(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_PointerTojsdlposix__GroupName_USCOREType:
		return soap_in_PointerTojsdlposix__GroupName_USCOREType(soap, NULL, NULL, "jsdlposix:GroupName_Type");
	case SOAP_TYPE_PointerTojsdlposix__UserName_USCOREType:
		return soap_in_PointerTojsdlposix__UserName_USCOREType(soap, NULL, NULL, "jsdlposix:UserName_Type");
	case SOAP_TYPE_PointerTojsdlposix__Limits_USCOREType:
		return soap_in_PointerTojsdlposix__Limits_USCOREType(soap, NULL, NULL, "jsdlposix:Limits_Type");
	case SOAP_TYPE_PointerTojsdlposix__Environment_USCOREType:
		return soap_in_PointerTojsdlposix__Environment_USCOREType(soap, NULL, NULL, "jsdlposix:Environment_Type");
	case SOAP_TYPE_PointerTojsdlposix__DirectoryName_USCOREType:
		return soap_in_PointerTojsdlposix__DirectoryName_USCOREType(soap, NULL, NULL, "jsdlposix:DirectoryName_Type");
	case SOAP_TYPE_PointerTojsdlposix__Argument_USCOREType:
		return soap_in_PointerTojsdlposix__Argument_USCOREType(soap, NULL, NULL, "jsdlposix:Argument_Type");
	case SOAP_TYPE_PointerTojsdlposix__FileName_USCOREType:
		return soap_in_PointerTojsdlposix__FileName_USCOREType(soap, NULL, NULL, "jsdlposix:FileName_Type");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_in_PointerToxsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_PointerTojsdl__SourceTarget_USCOREType:
		return soap_in_PointerTojsdl__SourceTarget_USCOREType(soap, NULL, NULL, "jsdl:SourceTarget_Type");
	case SOAP_TYPE_PointerToxsd__NCName:
		return soap_in_PointerToxsd__NCName(soap, NULL, NULL, "xsd:NCName");
	case SOAP_TYPE_PointerTojsdl__OperatingSystemType_USCOREType:
		return soap_in_PointerTojsdl__OperatingSystemType_USCOREType(soap, NULL, NULL, "jsdl:OperatingSystemType_Type");
	case SOAP_TYPE_PointerTojsdl__FileSystemTypeEnumeration:
		return soap_in_PointerTojsdl__FileSystemTypeEnumeration(soap, NULL, NULL, "jsdl:FileSystemTypeEnumeration");
	case SOAP_TYPE_PointerTojsdl__RangeValue_USCOREType:
		return soap_in_PointerTojsdl__RangeValue_USCOREType(soap, NULL, NULL, "jsdl:RangeValue_Type");
	case SOAP_TYPE_PointerTojsdl__CPUArchitecture_USCOREType:
		return soap_in_PointerTojsdl__CPUArchitecture_USCOREType(soap, NULL, NULL, "jsdl:CPUArchitecture_Type");
	case SOAP_TYPE_PointerTojsdl__OperatingSystem_USCOREType:
		return soap_in_PointerTojsdl__OperatingSystem_USCOREType(soap, NULL, NULL, "jsdl:OperatingSystem_Type");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTojsdl__FileSystem_USCOREType:
		return soap_in_PointerTojsdl__FileSystem_USCOREType(soap, NULL, NULL, "jsdl:FileSystem_Type");
	case SOAP_TYPE_PointerTojsdl__CandidateHosts_USCOREType:
		return soap_in_PointerTojsdl__CandidateHosts_USCOREType(soap, NULL, NULL, "jsdl:CandidateHosts_Type");
	case SOAP_TYPE_PointerTojsdl__Description_USCOREType:
		return soap_in_PointerTojsdl__Description_USCOREType(soap, NULL, NULL, "jsdl:Description_Type");
	case SOAP_TYPE_PointerTojsdl__DataStaging_USCOREType:
		return soap_in_PointerTojsdl__DataStaging_USCOREType(soap, NULL, NULL, "jsdl:DataStaging_Type");
	case SOAP_TYPE_PointerTojsdl__Resources_USCOREType:
		return soap_in_PointerTojsdl__Resources_USCOREType(soap, NULL, NULL, "jsdl:Resources_Type");
	case SOAP_TYPE_PointerTojsdl__Application_USCOREType:
		return soap_in_PointerTojsdl__Application_USCOREType(soap, NULL, NULL, "jsdl:Application_Type");
	case SOAP_TYPE_PointerTojsdl__JobIdentification_USCOREType:
		return soap_in_PointerTojsdl__JobIdentification_USCOREType(soap, NULL, NULL, "jsdl:JobIdentification_Type");
	case SOAP_TYPE_PointerToxsd__ID:
		return soap_in_PointerToxsd__ID(soap, NULL, NULL, "xsd:ID");
	case SOAP_TYPE_PointerTojsdl__JobDescription_USCOREType:
		return soap_in_PointerTojsdl__JobDescription_USCOREType(soap, NULL, NULL, "jsdl:JobDescription_Type");
	case SOAP_TYPE_PointerTojsdl__Range_USCOREType:
		return soap_in_PointerTojsdl__Range_USCOREType(soap, NULL, NULL, "jsdl:Range_Type");
	case SOAP_TYPE_PointerTojsdl__Exact_USCOREType:
		return soap_in_PointerTojsdl__Exact_USCOREType(soap, NULL, NULL, "jsdl:Exact_Type");
	case SOAP_TYPE_PointerTojsdl__Boundary_USCOREType:
		return soap_in_PointerTojsdl__Boundary_USCOREType(soap, NULL, NULL, "jsdl:Boundary_Type");
	case SOAP_TYPE_PointerTons1__VOProxyInfoStructType:
		return soap_in_PointerTons1__VOProxyInfoStructType(soap, NULL, NULL, "ns1:VOProxyInfoStructType");
	case SOAP_TYPE_PointerTons1__GraphStructType:
		return soap_in_PointerTons1__GraphStructType(soap, NULL, NULL, "ns1:GraphStructType");
	case SOAP_TYPE_PointerTons1__JobIdStructType:
		return soap_in_PointerTons1__JobIdStructType(soap, NULL, NULL, "ns1:JobIdStructType");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTons1__JobStatusStructType:
		return soap_in_PointerTons1__JobStatusStructType(soap, NULL, NULL, "ns1:JobStatusStructType");
	case SOAP_TYPE_PointerTons1__StringAndLongType:
		return soap_in_PointerTons1__StringAndLongType(soap, NULL, NULL, "ns1:StringAndLongType");
	case SOAP_TYPE_PointerTons1__DestURIStructType:
		return soap_in_PointerTons1__DestURIStructType(soap, NULL, NULL, "ns1:DestURIStructType");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "jsdl:Description_Type"))
		{	*type = SOAP_TYPE_jsdl__Description_USCOREType;
			return soap_in_jsdl__Description_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation1:DelegationExceptionType"))
		{	*type = SOAP_TYPE_delegation1__DelegationExceptionType;
			return soap_in_delegation1__DelegationExceptionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegationns:NewProxyReq"))
		{	*type = SOAP_TYPE_delegationns__NewProxyReq;
			return soap_in_delegationns__NewProxyReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdlposix:POSIXApplication_Type"))
		{	*type = SOAP_TYPE_jsdlposix__POSIXApplication_USCOREType;
			return soap_in_jsdlposix__POSIXApplication_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdlposix:GroupName_Type"))
		{	*type = SOAP_TYPE_jsdlposix__GroupName_USCOREType;
			return soap_in_jsdlposix__GroupName_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdlposix:UserName_Type"))
		{	*type = SOAP_TYPE_jsdlposix__UserName_USCOREType;
			return soap_in_jsdlposix__UserName_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdlposix:Limits_Type"))
		{	*type = SOAP_TYPE_jsdlposix__Limits_USCOREType;
			return soap_in_jsdlposix__Limits_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdlposix:DirectoryName_Type"))
		{	*type = SOAP_TYPE_jsdlposix__DirectoryName_USCOREType;
			return soap_in_jsdlposix__DirectoryName_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdlposix:FileName_Type"))
		{	*type = SOAP_TYPE_jsdlposix__FileName_USCOREType;
			return soap_in_jsdlposix__FileName_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdlposix:Argument_Type"))
		{	*type = SOAP_TYPE_jsdlposix__Argument_USCOREType;
			return soap_in_jsdlposix__Argument_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdlposix:Environment_Type"))
		{	*type = SOAP_TYPE_jsdlposix__Environment_USCOREType;
			return soap_in_jsdlposix__Environment_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:SourceTarget_Type"))
		{	*type = SOAP_TYPE_jsdl__SourceTarget_USCOREType;
			return soap_in_jsdl__SourceTarget_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:DataStaging_Type"))
		{	*type = SOAP_TYPE_jsdl__DataStaging_USCOREType;
			return soap_in_jsdl__DataStaging_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:OperatingSystemType_Type"))
		{	*type = SOAP_TYPE_jsdl__OperatingSystemType_USCOREType;
			return soap_in_jsdl__OperatingSystemType_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:OperatingSystem_Type"))
		{	*type = SOAP_TYPE_jsdl__OperatingSystem_USCOREType;
			return soap_in_jsdl__OperatingSystem_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:FileSystem_Type"))
		{	*type = SOAP_TYPE_jsdl__FileSystem_USCOREType;
			return soap_in_jsdl__FileSystem_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:CPUArchitecture_Type"))
		{	*type = SOAP_TYPE_jsdl__CPUArchitecture_USCOREType;
			return soap_in_jsdl__CPUArchitecture_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:CandidateHosts_Type"))
		{	*type = SOAP_TYPE_jsdl__CandidateHosts_USCOREType;
			return soap_in_jsdl__CandidateHosts_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:Resources_Type"))
		{	*type = SOAP_TYPE_jsdl__Resources_USCOREType;
			return soap_in_jsdl__Resources_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:Application_Type"))
		{	*type = SOAP_TYPE_jsdl__Application_USCOREType;
			return soap_in_jsdl__Application_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:JobIdentification_Type"))
		{	*type = SOAP_TYPE_jsdl__JobIdentification_USCOREType;
			return soap_in_jsdl__JobIdentification_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:JobDescription_Type"))
		{	*type = SOAP_TYPE_jsdl__JobDescription_USCOREType;
			return soap_in_jsdl__JobDescription_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:JobDefinition_Type"))
		{	*type = SOAP_TYPE_jsdl__JobDefinition_USCOREType;
			return soap_in_jsdl__JobDefinition_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:RangeValue_Type"))
		{	*type = SOAP_TYPE_jsdl__RangeValue_USCOREType;
			return soap_in_jsdl__RangeValue_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:Range_Type"))
		{	*type = SOAP_TYPE_jsdl__Range_USCOREType;
			return soap_in_jsdl__Range_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:Exact_Type"))
		{	*type = SOAP_TYPE_jsdl__Exact_USCOREType;
			return soap_in_jsdl__Exact_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:Boundary_Type"))
		{	*type = SOAP_TYPE_jsdl__Boundary_USCOREType;
			return soap_in_jsdl__Boundary_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ServerOverloadedFaultType"))
		{	*type = SOAP_TYPE_ns1__ServerOverloadedFaultType;
			return soap_in_ns1__ServerOverloadedFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OperationNotAllowedFaultType"))
		{	*type = SOAP_TYPE_ns1__OperationNotAllowedFaultType;
			return soap_in_ns1__OperationNotAllowedFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:JobUnknownFaultType"))
		{	*type = SOAP_TYPE_ns1__JobUnknownFaultType;
			return soap_in_ns1__JobUnknownFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NoSuitableResourcesFaultType"))
		{	*type = SOAP_TYPE_ns1__NoSuitableResourcesFaultType;
			return soap_in_ns1__NoSuitableResourcesFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetQuotaManagementFaultType"))
		{	*type = SOAP_TYPE_ns1__GetQuotaManagementFaultType;
			return soap_in_ns1__GetQuotaManagementFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InvalidArgumentFaultType"))
		{	*type = SOAP_TYPE_ns1__InvalidArgumentFaultType;
			return soap_in_ns1__InvalidArgumentFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AuthorizationFaultType"))
		{	*type = SOAP_TYPE_ns1__AuthorizationFaultType;
			return soap_in_ns1__AuthorizationFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AuthenticationFaultType"))
		{	*type = SOAP_TYPE_ns1__AuthenticationFaultType;
			return soap_in_ns1__AuthenticationFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GenericFaultType"))
		{	*type = SOAP_TYPE_ns1__GenericFaultType;
			return soap_in_ns1__GenericFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BaseFaultType"))
		{	*type = SOAP_TYPE_ns1__BaseFaultType;
			return soap_in_ns1__BaseFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ProxyInfoStructType"))
		{	*type = SOAP_TYPE_ns1__ProxyInfoStructType;
			return soap_in_ns1__ProxyInfoStructType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:VOProxyInfoStructType"))
		{	*type = SOAP_TYPE_ns1__VOProxyInfoStructType;
			return soap_in_ns1__VOProxyInfoStructType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GraphStructType"))
		{	*type = SOAP_TYPE_ns1__GraphStructType;
			return soap_in_ns1__GraphStructType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:JobIdStructType"))
		{	*type = SOAP_TYPE_ns1__JobIdStructType;
			return soap_in_ns1__JobIdStructType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:JobStatusStructType"))
		{	*type = SOAP_TYPE_ns1__JobStatusStructType;
			return soap_in_ns1__JobStatusStructType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StringAndLongList"))
		{	*type = SOAP_TYPE_ns1__StringAndLongList;
			return soap_in_ns1__StringAndLongList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StringAndLongType"))
		{	*type = SOAP_TYPE_ns1__StringAndLongType;
			return soap_in_ns1__StringAndLongType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DestURIsStructType"))
		{	*type = SOAP_TYPE_ns1__DestURIsStructType;
			return soap_in_ns1__DestURIsStructType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DestURIStructType"))
		{	*type = SOAP_TYPE_ns1__DestURIStructType;
			return soap_in_ns1__DestURIStructType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StringList"))
		{	*type = SOAP_TYPE_ns1__StringList;
			return soap_in_ns1__StringList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:JobTypeList"))
		{	*type = SOAP_TYPE_ns1__JobTypeList;
			return soap_in_ns1__JobTypeList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:normalizedString"))
		{	*type = SOAP_TYPE_xsd__normalizedString;
			return soap_in_xsd__normalizedString(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:nonNegativeInteger"))
		{	*type = SOAP_TYPE_xsd__nonNegativeInteger;
			return soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_xsd__anyURI;
			return soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:NCName"))
		{	*type = SOAP_TYPE_xsd__NCName;
			return soap_in_xsd__NCName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:ID"))
		{	*type = SOAP_TYPE_xsd__ID;
			return soap_in_xsd__ID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:CreationFlagEnumeration"))
		{	*type = SOAP_TYPE_jsdl__CreationFlagEnumeration;
			return soap_in_jsdl__CreationFlagEnumeration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:FileSystemTypeEnumeration"))
		{	*type = SOAP_TYPE_jsdl__FileSystemTypeEnumeration;
			return soap_in_jsdl__FileSystemTypeEnumeration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:OperatingSystemTypeEnumeration"))
		{	*type = SOAP_TYPE_jsdl__OperatingSystemTypeEnumeration;
			return soap_in_jsdl__OperatingSystemTypeEnumeration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:ProcessorArchitectureEnumeration"))
		{	*type = SOAP_TYPE_jsdl__ProcessorArchitectureEnumeration;
			return soap_in_jsdl__ProcessorArchitectureEnumeration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:JdlType"))
		{	*type = SOAP_TYPE_ns1__JdlType;
			return soap_in_ns1__JdlType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:JobType"))
		{	*type = SOAP_TYPE_ns1__JobType;
			return soap_in_ns1__JobType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ObjectType"))
		{	*type = SOAP_TYPE_ns1__ObjectType;
			return soap_in_ns1__ObjectType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getJobStatus"))
		{	*type = SOAP_TYPE_ns1__getJobStatus;
			return soap_in_ns1__getJobStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getJobStatusResponse"))
		{	*type = SOAP_TYPE_ns1__getJobStatusResponse;
			return soap_in_ns1__getJobStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTransferProtocols"))
		{	*type = SOAP_TYPE_ns1__getTransferProtocols;
			return soap_in_ns1__getTransferProtocols(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTransferProtocolsResponse"))
		{	*type = SOAP_TYPE_ns1__getTransferProtocolsResponse;
			return soap_in_ns1__getTransferProtocolsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPerusalFiles"))
		{	*type = SOAP_TYPE_ns1__getPerusalFiles;
			return soap_in_ns1__getPerusalFiles(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPerusalFilesResponse"))
		{	*type = SOAP_TYPE_ns1__getPerusalFilesResponse;
			return soap_in_ns1__getPerusalFilesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:enableFilePerusal"))
		{	*type = SOAP_TYPE_ns1__enableFilePerusal;
			return soap_in_ns1__enableFilePerusal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:enableFilePerusalResponse"))
		{	*type = SOAP_TYPE_ns1__enableFilePerusalResponse;
			return soap_in_ns1__enableFilePerusalResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getJobProxyInfo"))
		{	*type = SOAP_TYPE_ns1__getJobProxyInfo;
			return soap_in_ns1__getJobProxyInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getJobProxyInfoResponse"))
		{	*type = SOAP_TYPE_ns1__getJobProxyInfoResponse;
			return soap_in_ns1__getJobProxyInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDelegatedProxyInfo"))
		{	*type = SOAP_TYPE_ns1__getDelegatedProxyInfo;
			return soap_in_ns1__getDelegatedProxyInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDelegatedProxyInfoResponse"))
		{	*type = SOAP_TYPE_ns1__getDelegatedProxyInfoResponse;
			return soap_in_ns1__getDelegatedProxyInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeACLItem"))
		{	*type = SOAP_TYPE_ns1__removeACLItem;
			return soap_in_ns1__removeACLItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeACLItemResponse"))
		{	*type = SOAP_TYPE_ns1__removeACLItemResponse;
			return soap_in_ns1__removeACLItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addACLItems"))
		{	*type = SOAP_TYPE_ns1__addACLItems;
			return soap_in_ns1__addACLItems(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addACLItemsResponse"))
		{	*type = SOAP_TYPE_ns1__addACLItemsResponse;
			return soap_in_ns1__addACLItemsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getACLItems"))
		{	*type = SOAP_TYPE_ns1__getACLItems;
			return soap_in_ns1__getACLItems(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getACLItemsResponse"))
		{	*type = SOAP_TYPE_ns1__getACLItemsResponse;
			return soap_in_ns1__getACLItemsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getStringParametricJobTemplate"))
		{	*type = SOAP_TYPE_ns1__getStringParametricJobTemplate;
			return soap_in_ns1__getStringParametricJobTemplate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getStringParametricJobTemplateResponse"))
		{	*type = SOAP_TYPE_ns1__getStringParametricJobTemplateResponse;
			return soap_in_ns1__getStringParametricJobTemplateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getIntParametricJobTemplate"))
		{	*type = SOAP_TYPE_ns1__getIntParametricJobTemplate;
			return soap_in_ns1__getIntParametricJobTemplate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getIntParametricJobTemplateResponse"))
		{	*type = SOAP_TYPE_ns1__getIntParametricJobTemplateResponse;
			return soap_in_ns1__getIntParametricJobTemplateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCollectionTemplate"))
		{	*type = SOAP_TYPE_ns1__getCollectionTemplate;
			return soap_in_ns1__getCollectionTemplate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCollectionTemplateResponse"))
		{	*type = SOAP_TYPE_ns1__getCollectionTemplateResponse;
			return soap_in_ns1__getCollectionTemplateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDAGTemplate"))
		{	*type = SOAP_TYPE_ns1__getDAGTemplate;
			return soap_in_ns1__getDAGTemplate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDAGTemplateResponse"))
		{	*type = SOAP_TYPE_ns1__getDAGTemplateResponse;
			return soap_in_ns1__getDAGTemplateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getJobTemplate"))
		{	*type = SOAP_TYPE_ns1__getJobTemplate;
			return soap_in_ns1__getJobTemplate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getJobTemplateResponse"))
		{	*type = SOAP_TYPE_ns1__getJobTemplateResponse;
			return soap_in_ns1__getJobTemplateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jobListMatchJSDL"))
		{	*type = SOAP_TYPE_ns1__jobListMatchJSDL;
			return soap_in_ns1__jobListMatchJSDL(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jobListMatchJSDLResponse"))
		{	*type = SOAP_TYPE_ns1__jobListMatchJSDLResponse;
			return soap_in_ns1__jobListMatchJSDLResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jobListMatch"))
		{	*type = SOAP_TYPE_ns1__jobListMatch;
			return soap_in_ns1__jobListMatch(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jobListMatchResponse"))
		{	*type = SOAP_TYPE_ns1__jobListMatchResponse;
			return soap_in_ns1__jobListMatchResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getOutputFileList"))
		{	*type = SOAP_TYPE_ns1__getOutputFileList;
			return soap_in_ns1__getOutputFileList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getOutputFileListResponse"))
		{	*type = SOAP_TYPE_ns1__getOutputFileListResponse;
			return soap_in_ns1__getOutputFileListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jobPurge"))
		{	*type = SOAP_TYPE_ns1__jobPurge;
			return soap_in_ns1__jobPurge(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jobPurgeResponse"))
		{	*type = SOAP_TYPE_ns1__jobPurgeResponse;
			return soap_in_ns1__jobPurgeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFreeQuota"))
		{	*type = SOAP_TYPE_ns1__getFreeQuota;
			return soap_in_ns1__getFreeQuota(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFreeQuotaResponse"))
		{	*type = SOAP_TYPE_ns1__getFreeQuotaResponse;
			return soap_in_ns1__getFreeQuotaResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTotalQuota"))
		{	*type = SOAP_TYPE_ns1__getTotalQuota;
			return soap_in_ns1__getTotalQuota(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTotalQuotaResponse"))
		{	*type = SOAP_TYPE_ns1__getTotalQuotaResponse;
			return soap_in_ns1__getTotalQuotaResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSandboxBulkDestURI"))
		{	*type = SOAP_TYPE_ns1__getSandboxBulkDestURI;
			return soap_in_ns1__getSandboxBulkDestURI(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSandboxBulkDestURIResponse"))
		{	*type = SOAP_TYPE_ns1__getSandboxBulkDestURIResponse;
			return soap_in_ns1__getSandboxBulkDestURIResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSandboxDestURI"))
		{	*type = SOAP_TYPE_ns1__getSandboxDestURI;
			return soap_in_ns1__getSandboxDestURI(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSandboxDestURIResponse"))
		{	*type = SOAP_TYPE_ns1__getSandboxDestURIResponse;
			return soap_in_ns1__getSandboxDestURIResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMaxInputSandboxSize"))
		{	*type = SOAP_TYPE_ns1__getMaxInputSandboxSize;
			return soap_in_ns1__getMaxInputSandboxSize(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMaxInputSandboxSizeResponse"))
		{	*type = SOAP_TYPE_ns1__getMaxInputSandboxSizeResponse;
			return soap_in_ns1__getMaxInputSandboxSizeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jobCancel"))
		{	*type = SOAP_TYPE_ns1__jobCancel;
			return soap_in_ns1__jobCancel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jobCancelResponse"))
		{	*type = SOAP_TYPE_ns1__jobCancelResponse;
			return soap_in_ns1__jobCancelResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jobSubmitJSDL"))
		{	*type = SOAP_TYPE_ns1__jobSubmitJSDL;
			return soap_in_ns1__jobSubmitJSDL(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jobSubmitJSDLResponse"))
		{	*type = SOAP_TYPE_ns1__jobSubmitJSDLResponse;
			return soap_in_ns1__jobSubmitJSDLResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jobSubmit"))
		{	*type = SOAP_TYPE_ns1__jobSubmit;
			return soap_in_ns1__jobSubmit(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jobSubmitResponse"))
		{	*type = SOAP_TYPE_ns1__jobSubmitResponse;
			return soap_in_ns1__jobSubmitResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jobStart"))
		{	*type = SOAP_TYPE_ns1__jobStart;
			return soap_in_ns1__jobStart(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jobStartResponse"))
		{	*type = SOAP_TYPE_ns1__jobStartResponse;
			return soap_in_ns1__jobStartResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jobRegisterJSDL"))
		{	*type = SOAP_TYPE_ns1__jobRegisterJSDL;
			return soap_in_ns1__jobRegisterJSDL(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jobRegisterJSDLResponse"))
		{	*type = SOAP_TYPE_ns1__jobRegisterJSDLResponse;
			return soap_in_ns1__jobRegisterJSDLResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jobRegister"))
		{	*type = SOAP_TYPE_ns1__jobRegister;
			return soap_in_ns1__jobRegister(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jobRegisterResponse"))
		{	*type = SOAP_TYPE_ns1__jobRegisterResponse;
			return soap_in_ns1__jobRegisterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getJDL"))
		{	*type = SOAP_TYPE_ns1__getJDL;
			return soap_in_ns1__getJDL(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getJDLResponse"))
		{	*type = SOAP_TYPE_ns1__getJDLResponse;
			return soap_in_ns1__getJDLResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getVersion"))
		{	*type = SOAP_TYPE_ns1__getVersion;
			return soap_in_ns1__getVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getVersionResponse"))
		{	*type = SOAP_TYPE_ns1__getVersionResponse;
			return soap_in_ns1__getVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:putProxy"))
		{	*type = SOAP_TYPE_ns1__putProxy;
			return soap_in_ns1__putProxy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:putProxyResponse"))
		{	*type = SOAP_TYPE_ns1__putProxyResponse;
			return soap_in_ns1__putProxyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProxyReq"))
		{	*type = SOAP_TYPE_ns1__getProxyReq;
			return soap_in_ns1__getProxyReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProxyReqResponse"))
		{	*type = SOAP_TYPE_ns1__getProxyReqResponse;
			return soap_in_ns1__getProxyReqResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegationns:destroy"))
		{	*type = SOAP_TYPE_delegationns__destroy;
			return soap_in_delegationns__destroy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegationns:destroyResponse"))
		{	*type = SOAP_TYPE_delegationns__destroyResponse;
			return soap_in_delegationns__destroyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegationns:getTerminationTime"))
		{	*type = SOAP_TYPE_delegationns__getTerminationTime;
			return soap_in_delegationns__getTerminationTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegationns:getTerminationTimeResponse"))
		{	*type = SOAP_TYPE_delegationns__getTerminationTimeResponse;
			return soap_in_delegationns__getTerminationTimeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegationns:putProxy"))
		{	*type = SOAP_TYPE_delegationns__putProxy;
			return soap_in_delegationns__putProxy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegationns:putProxyResponse"))
		{	*type = SOAP_TYPE_delegationns__putProxyResponse;
			return soap_in_delegationns__putProxyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegationns:renewProxyReq"))
		{	*type = SOAP_TYPE_delegationns__renewProxyReq;
			return soap_in_delegationns__renewProxyReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegationns:renewProxyReqResponse"))
		{	*type = SOAP_TYPE_delegationns__renewProxyReqResponse;
			return soap_in_delegationns__renewProxyReqResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegationns:getNewProxyReq"))
		{	*type = SOAP_TYPE_delegationns__getNewProxyReq;
			return soap_in_delegationns__getNewProxyReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegationns:getNewProxyReqResponse"))
		{	*type = SOAP_TYPE_delegationns__getNewProxyReqResponse;
			return soap_in_delegationns__getNewProxyReqResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegationns:getProxyReq"))
		{	*type = SOAP_TYPE_delegationns__getProxyReq;
			return soap_in_delegationns__getProxyReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegationns:getProxyReqResponse"))
		{	*type = SOAP_TYPE_delegationns__getProxyReqResponse;
			return soap_in_delegationns__getProxyReqResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegationns:getServiceMetadata"))
		{	*type = SOAP_TYPE_delegationns__getServiceMetadata;
			return soap_in_delegationns__getServiceMetadata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegationns:getServiceMetadataResponse"))
		{	*type = SOAP_TYPE_delegationns__getServiceMetadataResponse;
			return soap_in_delegationns__getServiceMetadataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegationns:getInterfaceVersion"))
		{	*type = SOAP_TYPE_delegationns__getInterfaceVersion;
			return soap_in_delegationns__getInterfaceVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegationns:getInterfaceVersionResponse"))
		{	*type = SOAP_TYPE_delegationns__getInterfaceVersionResponse;
			return soap_in_delegationns__getInterfaceVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegationns:getVersion"))
		{	*type = SOAP_TYPE_delegationns__getVersion;
			return soap_in_delegationns__getVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegationns:getVersionResponse"))
		{	*type = SOAP_TYPE_delegationns__getVersionResponse;
			return soap_in_delegationns__getVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation1:putProxy"))
		{	*type = SOAP_TYPE_delegation1__putProxy;
			return soap_in_delegation1__putProxy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation1:putProxyResponse"))
		{	*type = SOAP_TYPE_delegation1__putProxyResponse;
			return soap_in_delegation1__putProxyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation1:getProxyReq"))
		{	*type = SOAP_TYPE_delegation1__getProxyReq;
			return soap_in_delegation1__getProxyReq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "delegation1:getProxyReqResponse"))
		{	*type = SOAP_TYPE_delegation1__getProxyReqResponse;
			return soap_in_delegation1__getProxyReqResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "delegationns:DelegationException"))
		{	*type = SOAP_TYPE__delegationns__DelegationException;
			return soap_in__delegationns__DelegationException(soap, NULL, NULL, NULL);
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_jsdl__CreationFlagEnumeration:
		return soap_out_jsdl__CreationFlagEnumeration(soap, tag, id, (const enum jsdl__CreationFlagEnumeration *)ptr, "jsdl:CreationFlagEnumeration");
	case SOAP_TYPE_jsdl__FileSystemTypeEnumeration:
		return soap_out_jsdl__FileSystemTypeEnumeration(soap, tag, id, (const enum jsdl__FileSystemTypeEnumeration *)ptr, "jsdl:FileSystemTypeEnumeration");
	case SOAP_TYPE_jsdl__OperatingSystemTypeEnumeration:
		return soap_out_jsdl__OperatingSystemTypeEnumeration(soap, tag, id, (const enum jsdl__OperatingSystemTypeEnumeration *)ptr, "jsdl:OperatingSystemTypeEnumeration");
	case SOAP_TYPE_jsdl__ProcessorArchitectureEnumeration:
		return soap_out_jsdl__ProcessorArchitectureEnumeration(soap, tag, id, (const enum jsdl__ProcessorArchitectureEnumeration *)ptr, "jsdl:ProcessorArchitectureEnumeration");
	case SOAP_TYPE_ns1__JdlType:
		return soap_out_ns1__JdlType(soap, tag, id, (const enum ns1__JdlType *)ptr, "ns1:JdlType");
	case SOAP_TYPE_ns1__JobType:
		return soap_out_ns1__JobType(soap, tag, id, (const enum ns1__JobType *)ptr, "ns1:JobType");
	case SOAP_TYPE_ns1__ObjectType:
		return soap_out_ns1__ObjectType(soap, tag, id, (const enum ns1__ObjectType *)ptr, "ns1:ObjectType");
	case SOAP_TYPE_jsdl__Description_USCOREType:
		return soap_out_jsdl__Description_USCOREType(soap, tag, id, (const std::string *)ptr, "jsdl:Description_Type");
	case SOAP_TYPE_delegation1__DelegationExceptionType:
		return ((delegation1__DelegationExceptionType *)ptr)->soap_out(soap, tag, id, "delegation1:DelegationExceptionType");
	case SOAP_TYPE__delegationns__DelegationException:
		return ((_delegationns__DelegationException *)ptr)->soap_out(soap, "delegationns:DelegationException", id, NULL);
	case SOAP_TYPE_delegationns__NewProxyReq:
		return ((delegationns__NewProxyReq *)ptr)->soap_out(soap, tag, id, "delegationns:NewProxyReq");
	case SOAP_TYPE_jsdlposix__POSIXApplication_USCOREType:
		return ((jsdlposix__POSIXApplication_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdlposix:POSIXApplication_Type");
	case SOAP_TYPE_jsdlposix__GroupName_USCOREType:
		return ((jsdlposix__GroupName_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdlposix:GroupName_Type");
	case SOAP_TYPE_jsdlposix__UserName_USCOREType:
		return ((jsdlposix__UserName_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdlposix:UserName_Type");
	case SOAP_TYPE_jsdlposix__Limits_USCOREType:
		return ((jsdlposix__Limits_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdlposix:Limits_Type");
	case SOAP_TYPE_jsdlposix__DirectoryName_USCOREType:
		return ((jsdlposix__DirectoryName_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdlposix:DirectoryName_Type");
	case SOAP_TYPE_jsdlposix__FileName_USCOREType:
		return ((jsdlposix__FileName_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdlposix:FileName_Type");
	case SOAP_TYPE_jsdlposix__Argument_USCOREType:
		return ((jsdlposix__Argument_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdlposix:Argument_Type");
	case SOAP_TYPE_jsdlposix__Environment_USCOREType:
		return ((jsdlposix__Environment_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdlposix:Environment_Type");
	case SOAP_TYPE_jsdl__SourceTarget_USCOREType:
		return ((jsdl__SourceTarget_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:SourceTarget_Type");
	case SOAP_TYPE_jsdl__DataStaging_USCOREType:
		return ((jsdl__DataStaging_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:DataStaging_Type");
	case SOAP_TYPE_jsdl__OperatingSystemType_USCOREType:
		return ((jsdl__OperatingSystemType_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:OperatingSystemType_Type");
	case SOAP_TYPE_jsdl__OperatingSystem_USCOREType:
		return ((jsdl__OperatingSystem_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:OperatingSystem_Type");
	case SOAP_TYPE_jsdl__FileSystem_USCOREType:
		return ((jsdl__FileSystem_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:FileSystem_Type");
	case SOAP_TYPE_jsdl__CPUArchitecture_USCOREType:
		return ((jsdl__CPUArchitecture_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:CPUArchitecture_Type");
	case SOAP_TYPE_jsdl__CandidateHosts_USCOREType:
		return ((jsdl__CandidateHosts_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:CandidateHosts_Type");
	case SOAP_TYPE_jsdl__Resources_USCOREType:
		return ((jsdl__Resources_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:Resources_Type");
	case SOAP_TYPE_jsdl__Application_USCOREType:
		return ((jsdl__Application_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:Application_Type");
	case SOAP_TYPE_jsdl__JobIdentification_USCOREType:
		return ((jsdl__JobIdentification_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:JobIdentification_Type");
	case SOAP_TYPE_jsdl__JobDescription_USCOREType:
		return ((jsdl__JobDescription_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:JobDescription_Type");
	case SOAP_TYPE_jsdl__JobDefinition_USCOREType:
		return ((jsdl__JobDefinition_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:JobDefinition_Type");
	case SOAP_TYPE_jsdl__RangeValue_USCOREType:
		return ((jsdl__RangeValue_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:RangeValue_Type");
	case SOAP_TYPE_jsdl__Range_USCOREType:
		return ((jsdl__Range_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:Range_Type");
	case SOAP_TYPE_jsdl__Exact_USCOREType:
		return ((jsdl__Exact_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:Exact_Type");
	case SOAP_TYPE_jsdl__Boundary_USCOREType:
		return ((jsdl__Boundary_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:Boundary_Type");
	case SOAP_TYPE_ns1__ServerOverloadedFaultType:
		return ((ns1__ServerOverloadedFaultType *)ptr)->soap_out(soap, tag, id, "ns1:ServerOverloadedFaultType");
	case SOAP_TYPE_ns1__OperationNotAllowedFaultType:
		return ((ns1__OperationNotAllowedFaultType *)ptr)->soap_out(soap, tag, id, "ns1:OperationNotAllowedFaultType");
	case SOAP_TYPE_ns1__JobUnknownFaultType:
		return ((ns1__JobUnknownFaultType *)ptr)->soap_out(soap, tag, id, "ns1:JobUnknownFaultType");
	case SOAP_TYPE_ns1__NoSuitableResourcesFaultType:
		return ((ns1__NoSuitableResourcesFaultType *)ptr)->soap_out(soap, tag, id, "ns1:NoSuitableResourcesFaultType");
	case SOAP_TYPE_ns1__GetQuotaManagementFaultType:
		return ((ns1__GetQuotaManagementFaultType *)ptr)->soap_out(soap, tag, id, "ns1:GetQuotaManagementFaultType");
	case SOAP_TYPE_ns1__InvalidArgumentFaultType:
		return ((ns1__InvalidArgumentFaultType *)ptr)->soap_out(soap, tag, id, "ns1:InvalidArgumentFaultType");
	case SOAP_TYPE_ns1__AuthorizationFaultType:
		return ((ns1__AuthorizationFaultType *)ptr)->soap_out(soap, tag, id, "ns1:AuthorizationFaultType");
	case SOAP_TYPE_ns1__AuthenticationFaultType:
		return ((ns1__AuthenticationFaultType *)ptr)->soap_out(soap, tag, id, "ns1:AuthenticationFaultType");
	case SOAP_TYPE_ns1__GenericFaultType:
		return ((ns1__GenericFaultType *)ptr)->soap_out(soap, tag, id, "ns1:GenericFaultType");
	case SOAP_TYPE_ns1__BaseFaultType:
		return ((ns1__BaseFaultType *)ptr)->soap_out(soap, tag, id, "ns1:BaseFaultType");
	case SOAP_TYPE_ns1__ProxyInfoStructType:
		return ((ns1__ProxyInfoStructType *)ptr)->soap_out(soap, tag, id, "ns1:ProxyInfoStructType");
	case SOAP_TYPE_ns1__VOProxyInfoStructType:
		return ((ns1__VOProxyInfoStructType *)ptr)->soap_out(soap, tag, id, "ns1:VOProxyInfoStructType");
	case SOAP_TYPE_ns1__GraphStructType:
		return ((ns1__GraphStructType *)ptr)->soap_out(soap, tag, id, "ns1:GraphStructType");
	case SOAP_TYPE_ns1__JobIdStructType:
		return ((ns1__JobIdStructType *)ptr)->soap_out(soap, tag, id, "ns1:JobIdStructType");
	case SOAP_TYPE_ns1__JobStatusStructType:
		return ((ns1__JobStatusStructType *)ptr)->soap_out(soap, tag, id, "ns1:JobStatusStructType");
	case SOAP_TYPE_ns1__StringAndLongList:
		return ((ns1__StringAndLongList *)ptr)->soap_out(soap, tag, id, "ns1:StringAndLongList");
	case SOAP_TYPE_ns1__StringAndLongType:
		return ((ns1__StringAndLongType *)ptr)->soap_out(soap, tag, id, "ns1:StringAndLongType");
	case SOAP_TYPE_ns1__DestURIsStructType:
		return ((ns1__DestURIsStructType *)ptr)->soap_out(soap, tag, id, "ns1:DestURIsStructType");
	case SOAP_TYPE_ns1__DestURIStructType:
		return ((ns1__DestURIStructType *)ptr)->soap_out(soap, tag, id, "ns1:DestURIStructType");
	case SOAP_TYPE_ns1__StringList:
		return ((ns1__StringList *)ptr)->soap_out(soap, tag, id, "ns1:StringList");
	case SOAP_TYPE_ns1__JobTypeList:
		return ((ns1__JobTypeList *)ptr)->soap_out(soap, tag, id, "ns1:JobTypeList");
	case SOAP_TYPE_xsd__normalizedString:
		return soap_out_xsd__normalizedString(soap, tag, id, (const std::string *)ptr, "xsd:normalizedString");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_out_xsd__nonNegativeInteger(soap, tag, id, (const std::string *)ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_xsd__anyURI(soap, tag, id, (const std::string *)ptr, "xsd:anyURI");
	case SOAP_TYPE_xsd__NCName:
		return soap_out_xsd__NCName(soap, tag, id, (const std::string *)ptr, "xsd:NCName");
	case SOAP_TYPE_xsd__ID:
		return soap_out_xsd__ID(soap, tag, id, (const std::string *)ptr, "xsd:ID");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_ns1__getJobStatus:
		return soap_out_ns1__getJobStatus(soap, tag, id, (const struct ns1__getJobStatus *)ptr, "ns1:getJobStatus");
	case SOAP_TYPE_ns1__getJobStatusResponse:
		return soap_out_ns1__getJobStatusResponse(soap, tag, id, (const struct ns1__getJobStatusResponse *)ptr, "ns1:getJobStatusResponse");
	case SOAP_TYPE_ns1__getTransferProtocols:
		return soap_out_ns1__getTransferProtocols(soap, tag, id, (const struct ns1__getTransferProtocols *)ptr, "ns1:getTransferProtocols");
	case SOAP_TYPE_ns1__getTransferProtocolsResponse:
		return soap_out_ns1__getTransferProtocolsResponse(soap, tag, id, (const struct ns1__getTransferProtocolsResponse *)ptr, "ns1:getTransferProtocolsResponse");
	case SOAP_TYPE_ns1__getPerusalFiles:
		return soap_out_ns1__getPerusalFiles(soap, tag, id, (const struct ns1__getPerusalFiles *)ptr, "ns1:getPerusalFiles");
	case SOAP_TYPE_ns1__getPerusalFilesResponse:
		return soap_out_ns1__getPerusalFilesResponse(soap, tag, id, (const struct ns1__getPerusalFilesResponse *)ptr, "ns1:getPerusalFilesResponse");
	case SOAP_TYPE_ns1__enableFilePerusal:
		return soap_out_ns1__enableFilePerusal(soap, tag, id, (const struct ns1__enableFilePerusal *)ptr, "ns1:enableFilePerusal");
	case SOAP_TYPE_ns1__enableFilePerusalResponse:
		return soap_out_ns1__enableFilePerusalResponse(soap, tag, id, (const struct ns1__enableFilePerusalResponse *)ptr, "ns1:enableFilePerusalResponse");
	case SOAP_TYPE_ns1__getJobProxyInfo:
		return soap_out_ns1__getJobProxyInfo(soap, tag, id, (const struct ns1__getJobProxyInfo *)ptr, "ns1:getJobProxyInfo");
	case SOAP_TYPE_ns1__getJobProxyInfoResponse:
		return soap_out_ns1__getJobProxyInfoResponse(soap, tag, id, (const struct ns1__getJobProxyInfoResponse *)ptr, "ns1:getJobProxyInfoResponse");
	case SOAP_TYPE_ns1__getDelegatedProxyInfo:
		return soap_out_ns1__getDelegatedProxyInfo(soap, tag, id, (const struct ns1__getDelegatedProxyInfo *)ptr, "ns1:getDelegatedProxyInfo");
	case SOAP_TYPE_ns1__getDelegatedProxyInfoResponse:
		return soap_out_ns1__getDelegatedProxyInfoResponse(soap, tag, id, (const struct ns1__getDelegatedProxyInfoResponse *)ptr, "ns1:getDelegatedProxyInfoResponse");
	case SOAP_TYPE_ns1__removeACLItem:
		return soap_out_ns1__removeACLItem(soap, tag, id, (const struct ns1__removeACLItem *)ptr, "ns1:removeACLItem");
	case SOAP_TYPE_ns1__removeACLItemResponse:
		return soap_out_ns1__removeACLItemResponse(soap, tag, id, (const struct ns1__removeACLItemResponse *)ptr, "ns1:removeACLItemResponse");
	case SOAP_TYPE_ns1__addACLItems:
		return soap_out_ns1__addACLItems(soap, tag, id, (const struct ns1__addACLItems *)ptr, "ns1:addACLItems");
	case SOAP_TYPE_ns1__addACLItemsResponse:
		return soap_out_ns1__addACLItemsResponse(soap, tag, id, (const struct ns1__addACLItemsResponse *)ptr, "ns1:addACLItemsResponse");
	case SOAP_TYPE_ns1__getACLItems:
		return soap_out_ns1__getACLItems(soap, tag, id, (const struct ns1__getACLItems *)ptr, "ns1:getACLItems");
	case SOAP_TYPE_ns1__getACLItemsResponse:
		return soap_out_ns1__getACLItemsResponse(soap, tag, id, (const struct ns1__getACLItemsResponse *)ptr, "ns1:getACLItemsResponse");
	case SOAP_TYPE_ns1__getStringParametricJobTemplate:
		return soap_out_ns1__getStringParametricJobTemplate(soap, tag, id, (const struct ns1__getStringParametricJobTemplate *)ptr, "ns1:getStringParametricJobTemplate");
	case SOAP_TYPE_ns1__getStringParametricJobTemplateResponse:
		return soap_out_ns1__getStringParametricJobTemplateResponse(soap, tag, id, (const struct ns1__getStringParametricJobTemplateResponse *)ptr, "ns1:getStringParametricJobTemplateResponse");
	case SOAP_TYPE_ns1__getIntParametricJobTemplate:
		return soap_out_ns1__getIntParametricJobTemplate(soap, tag, id, (const struct ns1__getIntParametricJobTemplate *)ptr, "ns1:getIntParametricJobTemplate");
	case SOAP_TYPE_ns1__getIntParametricJobTemplateResponse:
		return soap_out_ns1__getIntParametricJobTemplateResponse(soap, tag, id, (const struct ns1__getIntParametricJobTemplateResponse *)ptr, "ns1:getIntParametricJobTemplateResponse");
	case SOAP_TYPE_ns1__getCollectionTemplate:
		return soap_out_ns1__getCollectionTemplate(soap, tag, id, (const struct ns1__getCollectionTemplate *)ptr, "ns1:getCollectionTemplate");
	case SOAP_TYPE_ns1__getCollectionTemplateResponse:
		return soap_out_ns1__getCollectionTemplateResponse(soap, tag, id, (const struct ns1__getCollectionTemplateResponse *)ptr, "ns1:getCollectionTemplateResponse");
	case SOAP_TYPE_ns1__getDAGTemplate:
		return soap_out_ns1__getDAGTemplate(soap, tag, id, (const struct ns1__getDAGTemplate *)ptr, "ns1:getDAGTemplate");
	case SOAP_TYPE_ns1__getDAGTemplateResponse:
		return soap_out_ns1__getDAGTemplateResponse(soap, tag, id, (const struct ns1__getDAGTemplateResponse *)ptr, "ns1:getDAGTemplateResponse");
	case SOAP_TYPE_ns1__getJobTemplate:
		return soap_out_ns1__getJobTemplate(soap, tag, id, (const struct ns1__getJobTemplate *)ptr, "ns1:getJobTemplate");
	case SOAP_TYPE_ns1__getJobTemplateResponse:
		return soap_out_ns1__getJobTemplateResponse(soap, tag, id, (const struct ns1__getJobTemplateResponse *)ptr, "ns1:getJobTemplateResponse");
	case SOAP_TYPE_ns1__jobListMatchJSDL:
		return soap_out_ns1__jobListMatchJSDL(soap, tag, id, (const struct ns1__jobListMatchJSDL *)ptr, "ns1:jobListMatchJSDL");
	case SOAP_TYPE_ns1__jobListMatchJSDLResponse:
		return soap_out_ns1__jobListMatchJSDLResponse(soap, tag, id, (const struct ns1__jobListMatchJSDLResponse *)ptr, "ns1:jobListMatchJSDLResponse");
	case SOAP_TYPE_ns1__jobListMatch:
		return soap_out_ns1__jobListMatch(soap, tag, id, (const struct ns1__jobListMatch *)ptr, "ns1:jobListMatch");
	case SOAP_TYPE_ns1__jobListMatchResponse:
		return soap_out_ns1__jobListMatchResponse(soap, tag, id, (const struct ns1__jobListMatchResponse *)ptr, "ns1:jobListMatchResponse");
	case SOAP_TYPE_ns1__getOutputFileList:
		return soap_out_ns1__getOutputFileList(soap, tag, id, (const struct ns1__getOutputFileList *)ptr, "ns1:getOutputFileList");
	case SOAP_TYPE_ns1__getOutputFileListResponse:
		return soap_out_ns1__getOutputFileListResponse(soap, tag, id, (const struct ns1__getOutputFileListResponse *)ptr, "ns1:getOutputFileListResponse");
	case SOAP_TYPE_ns1__jobPurge:
		return soap_out_ns1__jobPurge(soap, tag, id, (const struct ns1__jobPurge *)ptr, "ns1:jobPurge");
	case SOAP_TYPE_ns1__jobPurgeResponse:
		return soap_out_ns1__jobPurgeResponse(soap, tag, id, (const struct ns1__jobPurgeResponse *)ptr, "ns1:jobPurgeResponse");
	case SOAP_TYPE_ns1__getFreeQuota:
		return soap_out_ns1__getFreeQuota(soap, tag, id, (const struct ns1__getFreeQuota *)ptr, "ns1:getFreeQuota");
	case SOAP_TYPE_ns1__getFreeQuotaResponse:
		return soap_out_ns1__getFreeQuotaResponse(soap, tag, id, (const struct ns1__getFreeQuotaResponse *)ptr, "ns1:getFreeQuotaResponse");
	case SOAP_TYPE_ns1__getTotalQuota:
		return soap_out_ns1__getTotalQuota(soap, tag, id, (const struct ns1__getTotalQuota *)ptr, "ns1:getTotalQuota");
	case SOAP_TYPE_ns1__getTotalQuotaResponse:
		return soap_out_ns1__getTotalQuotaResponse(soap, tag, id, (const struct ns1__getTotalQuotaResponse *)ptr, "ns1:getTotalQuotaResponse");
	case SOAP_TYPE_ns1__getSandboxBulkDestURI:
		return soap_out_ns1__getSandboxBulkDestURI(soap, tag, id, (const struct ns1__getSandboxBulkDestURI *)ptr, "ns1:getSandboxBulkDestURI");
	case SOAP_TYPE_ns1__getSandboxBulkDestURIResponse:
		return soap_out_ns1__getSandboxBulkDestURIResponse(soap, tag, id, (const struct ns1__getSandboxBulkDestURIResponse *)ptr, "ns1:getSandboxBulkDestURIResponse");
	case SOAP_TYPE_ns1__getSandboxDestURI:
		return soap_out_ns1__getSandboxDestURI(soap, tag, id, (const struct ns1__getSandboxDestURI *)ptr, "ns1:getSandboxDestURI");
	case SOAP_TYPE_ns1__getSandboxDestURIResponse:
		return soap_out_ns1__getSandboxDestURIResponse(soap, tag, id, (const struct ns1__getSandboxDestURIResponse *)ptr, "ns1:getSandboxDestURIResponse");
	case SOAP_TYPE_ns1__getMaxInputSandboxSize:
		return soap_out_ns1__getMaxInputSandboxSize(soap, tag, id, (const struct ns1__getMaxInputSandboxSize *)ptr, "ns1:getMaxInputSandboxSize");
	case SOAP_TYPE_ns1__getMaxInputSandboxSizeResponse:
		return soap_out_ns1__getMaxInputSandboxSizeResponse(soap, tag, id, (const struct ns1__getMaxInputSandboxSizeResponse *)ptr, "ns1:getMaxInputSandboxSizeResponse");
	case SOAP_TYPE_ns1__jobCancel:
		return soap_out_ns1__jobCancel(soap, tag, id, (const struct ns1__jobCancel *)ptr, "ns1:jobCancel");
	case SOAP_TYPE_ns1__jobCancelResponse:
		return soap_out_ns1__jobCancelResponse(soap, tag, id, (const struct ns1__jobCancelResponse *)ptr, "ns1:jobCancelResponse");
	case SOAP_TYPE_ns1__jobSubmitJSDL:
		return soap_out_ns1__jobSubmitJSDL(soap, tag, id, (const struct ns1__jobSubmitJSDL *)ptr, "ns1:jobSubmitJSDL");
	case SOAP_TYPE_ns1__jobSubmitJSDLResponse:
		return soap_out_ns1__jobSubmitJSDLResponse(soap, tag, id, (const struct ns1__jobSubmitJSDLResponse *)ptr, "ns1:jobSubmitJSDLResponse");
	case SOAP_TYPE_ns1__jobSubmit:
		return soap_out_ns1__jobSubmit(soap, tag, id, (const struct ns1__jobSubmit *)ptr, "ns1:jobSubmit");
	case SOAP_TYPE_ns1__jobSubmitResponse:
		return soap_out_ns1__jobSubmitResponse(soap, tag, id, (const struct ns1__jobSubmitResponse *)ptr, "ns1:jobSubmitResponse");
	case SOAP_TYPE_ns1__jobStart:
		return soap_out_ns1__jobStart(soap, tag, id, (const struct ns1__jobStart *)ptr, "ns1:jobStart");
	case SOAP_TYPE_ns1__jobStartResponse:
		return soap_out_ns1__jobStartResponse(soap, tag, id, (const struct ns1__jobStartResponse *)ptr, "ns1:jobStartResponse");
	case SOAP_TYPE_ns1__jobRegisterJSDL:
		return soap_out_ns1__jobRegisterJSDL(soap, tag, id, (const struct ns1__jobRegisterJSDL *)ptr, "ns1:jobRegisterJSDL");
	case SOAP_TYPE_ns1__jobRegisterJSDLResponse:
		return soap_out_ns1__jobRegisterJSDLResponse(soap, tag, id, (const struct ns1__jobRegisterJSDLResponse *)ptr, "ns1:jobRegisterJSDLResponse");
	case SOAP_TYPE_ns1__jobRegister:
		return soap_out_ns1__jobRegister(soap, tag, id, (const struct ns1__jobRegister *)ptr, "ns1:jobRegister");
	case SOAP_TYPE_ns1__jobRegisterResponse:
		return soap_out_ns1__jobRegisterResponse(soap, tag, id, (const struct ns1__jobRegisterResponse *)ptr, "ns1:jobRegisterResponse");
	case SOAP_TYPE_ns1__getJDL:
		return soap_out_ns1__getJDL(soap, tag, id, (const struct ns1__getJDL *)ptr, "ns1:getJDL");
	case SOAP_TYPE_ns1__getJDLResponse:
		return soap_out_ns1__getJDLResponse(soap, tag, id, (const struct ns1__getJDLResponse *)ptr, "ns1:getJDLResponse");
	case SOAP_TYPE_ns1__getVersion:
		return soap_out_ns1__getVersion(soap, tag, id, (const struct ns1__getVersion *)ptr, "ns1:getVersion");
	case SOAP_TYPE_ns1__getVersionResponse:
		return soap_out_ns1__getVersionResponse(soap, tag, id, (const struct ns1__getVersionResponse *)ptr, "ns1:getVersionResponse");
	case SOAP_TYPE_ns1__putProxy:
		return soap_out_ns1__putProxy(soap, tag, id, (const struct ns1__putProxy *)ptr, "ns1:putProxy");
	case SOAP_TYPE_ns1__putProxyResponse:
		return soap_out_ns1__putProxyResponse(soap, tag, id, (const struct ns1__putProxyResponse *)ptr, "ns1:putProxyResponse");
	case SOAP_TYPE_ns1__getProxyReq:
		return soap_out_ns1__getProxyReq(soap, tag, id, (const struct ns1__getProxyReq *)ptr, "ns1:getProxyReq");
	case SOAP_TYPE_ns1__getProxyReqResponse:
		return soap_out_ns1__getProxyReqResponse(soap, tag, id, (const struct ns1__getProxyReqResponse *)ptr, "ns1:getProxyReqResponse");
	case SOAP_TYPE_delegationns__destroy:
		return soap_out_delegationns__destroy(soap, tag, id, (const struct delegationns__destroy *)ptr, "delegationns:destroy");
	case SOAP_TYPE_delegationns__destroyResponse:
		return soap_out_delegationns__destroyResponse(soap, tag, id, (const struct delegationns__destroyResponse *)ptr, "delegationns:destroyResponse");
	case SOAP_TYPE_delegationns__getTerminationTime:
		return soap_out_delegationns__getTerminationTime(soap, tag, id, (const struct delegationns__getTerminationTime *)ptr, "delegationns:getTerminationTime");
	case SOAP_TYPE_delegationns__getTerminationTimeResponse:
		return soap_out_delegationns__getTerminationTimeResponse(soap, tag, id, (const struct delegationns__getTerminationTimeResponse *)ptr, "delegationns:getTerminationTimeResponse");
	case SOAP_TYPE_delegationns__putProxy:
		return soap_out_delegationns__putProxy(soap, tag, id, (const struct delegationns__putProxy *)ptr, "delegationns:putProxy");
	case SOAP_TYPE_delegationns__putProxyResponse:
		return soap_out_delegationns__putProxyResponse(soap, tag, id, (const struct delegationns__putProxyResponse *)ptr, "delegationns:putProxyResponse");
	case SOAP_TYPE_delegationns__renewProxyReq:
		return soap_out_delegationns__renewProxyReq(soap, tag, id, (const struct delegationns__renewProxyReq *)ptr, "delegationns:renewProxyReq");
	case SOAP_TYPE_delegationns__renewProxyReqResponse:
		return soap_out_delegationns__renewProxyReqResponse(soap, tag, id, (const struct delegationns__renewProxyReqResponse *)ptr, "delegationns:renewProxyReqResponse");
	case SOAP_TYPE_delegationns__getNewProxyReq:
		return soap_out_delegationns__getNewProxyReq(soap, tag, id, (const struct delegationns__getNewProxyReq *)ptr, "delegationns:getNewProxyReq");
	case SOAP_TYPE_delegationns__getNewProxyReqResponse:
		return soap_out_delegationns__getNewProxyReqResponse(soap, tag, id, (const struct delegationns__getNewProxyReqResponse *)ptr, "delegationns:getNewProxyReqResponse");
	case SOAP_TYPE_delegationns__getProxyReq:
		return soap_out_delegationns__getProxyReq(soap, tag, id, (const struct delegationns__getProxyReq *)ptr, "delegationns:getProxyReq");
	case SOAP_TYPE_delegationns__getProxyReqResponse:
		return soap_out_delegationns__getProxyReqResponse(soap, tag, id, (const struct delegationns__getProxyReqResponse *)ptr, "delegationns:getProxyReqResponse");
	case SOAP_TYPE_delegationns__getServiceMetadata:
		return soap_out_delegationns__getServiceMetadata(soap, tag, id, (const struct delegationns__getServiceMetadata *)ptr, "delegationns:getServiceMetadata");
	case SOAP_TYPE_delegationns__getServiceMetadataResponse:
		return soap_out_delegationns__getServiceMetadataResponse(soap, tag, id, (const struct delegationns__getServiceMetadataResponse *)ptr, "delegationns:getServiceMetadataResponse");
	case SOAP_TYPE_delegationns__getInterfaceVersion:
		return soap_out_delegationns__getInterfaceVersion(soap, tag, id, (const struct delegationns__getInterfaceVersion *)ptr, "delegationns:getInterfaceVersion");
	case SOAP_TYPE_delegationns__getInterfaceVersionResponse:
		return soap_out_delegationns__getInterfaceVersionResponse(soap, tag, id, (const struct delegationns__getInterfaceVersionResponse *)ptr, "delegationns:getInterfaceVersionResponse");
	case SOAP_TYPE_delegationns__getVersion:
		return soap_out_delegationns__getVersion(soap, tag, id, (const struct delegationns__getVersion *)ptr, "delegationns:getVersion");
	case SOAP_TYPE_delegationns__getVersionResponse:
		return soap_out_delegationns__getVersionResponse(soap, tag, id, (const struct delegationns__getVersionResponse *)ptr, "delegationns:getVersionResponse");
	case SOAP_TYPE_delegation1__putProxy:
		return soap_out_delegation1__putProxy(soap, tag, id, (const struct delegation1__putProxy *)ptr, "delegation1:putProxy");
	case SOAP_TYPE_delegation1__putProxyResponse:
		return soap_out_delegation1__putProxyResponse(soap, tag, id, (const struct delegation1__putProxyResponse *)ptr, "delegation1:putProxyResponse");
	case SOAP_TYPE_delegation1__getProxyReq:
		return soap_out_delegation1__getProxyReq(soap, tag, id, (const struct delegation1__getProxyReq *)ptr, "delegation1:getProxyReq");
	case SOAP_TYPE_delegation1__getProxyReqResponse:
		return soap_out_delegation1__getProxyReqResponse(soap, tag, id, (const struct delegation1__getProxyReqResponse *)ptr, "delegation1:getProxyReqResponse");
	case SOAP_TYPE_PointerTons1__ProxyInfoStructType:
		return soap_out_PointerTons1__ProxyInfoStructType(soap, tag, id, (ns1__ProxyInfoStructType *const*)ptr, "ns1:ProxyInfoStructType");
	case SOAP_TYPE_PointerTons1__JobTypeList:
		return soap_out_PointerTons1__JobTypeList(soap, tag, id, (ns1__JobTypeList *const*)ptr, "ns1:JobTypeList");
	case SOAP_TYPE_PointerTons1__StringAndLongList:
		return soap_out_PointerTons1__StringAndLongList(soap, tag, id, (ns1__StringAndLongList *const*)ptr, "ns1:StringAndLongList");
	case SOAP_TYPE_PointerTons1__DestURIsStructType:
		return soap_out_PointerTons1__DestURIsStructType(soap, tag, id, (ns1__DestURIsStructType *const*)ptr, "ns1:DestURIsStructType");
	case SOAP_TYPE_PointerTons1__StringList:
		return soap_out_PointerTons1__StringList(soap, tag, id, (ns1__StringList *const*)ptr, "ns1:StringList");
	case SOAP_TYPE_PointerTojsdl__JobDefinition_USCOREType:
		return soap_out_PointerTojsdl__JobDefinition_USCOREType(soap, tag, id, (jsdl__JobDefinition_USCOREType *const*)ptr, "jsdl:JobDefinition_Type");
	case SOAP_TYPE_PointerTodelegationns__NewProxyReq:
		return soap_out_PointerTodelegationns__NewProxyReq(soap, tag, id, (delegationns__NewProxyReq *const*)ptr, "delegationns:NewProxyReq");
	case SOAP_TYPE_PointerTons1__ServerOverloadedFaultType:
		return soap_out_PointerTons1__ServerOverloadedFaultType(soap, tag, id, (ns1__ServerOverloadedFaultType *const*)ptr, "ns1:ServerOverloadedFaultType");
	case SOAP_TYPE_PointerTons1__OperationNotAllowedFaultType:
		return soap_out_PointerTons1__OperationNotAllowedFaultType(soap, tag, id, (ns1__OperationNotAllowedFaultType *const*)ptr, "ns1:OperationNotAllowedFaultType");
	case SOAP_TYPE_PointerTons1__NoSuitableResourcesFaultType:
		return soap_out_PointerTons1__NoSuitableResourcesFaultType(soap, tag, id, (ns1__NoSuitableResourcesFaultType *const*)ptr, "ns1:NoSuitableResourcesFaultType");
	case SOAP_TYPE_PointerTons1__JobUnknownFaultType:
		return soap_out_PointerTons1__JobUnknownFaultType(soap, tag, id, (ns1__JobUnknownFaultType *const*)ptr, "ns1:JobUnknownFaultType");
	case SOAP_TYPE_PointerTons1__InvalidArgumentFaultType:
		return soap_out_PointerTons1__InvalidArgumentFaultType(soap, tag, id, (ns1__InvalidArgumentFaultType *const*)ptr, "ns1:InvalidArgumentFaultType");
	case SOAP_TYPE_PointerTons1__GetQuotaManagementFaultType:
		return soap_out_PointerTons1__GetQuotaManagementFaultType(soap, tag, id, (ns1__GetQuotaManagementFaultType *const*)ptr, "ns1:GetQuotaManagementFaultType");
	case SOAP_TYPE_PointerTons1__GenericFaultType:
		return soap_out_PointerTons1__GenericFaultType(soap, tag, id, (ns1__GenericFaultType *const*)ptr, "ns1:GenericFaultType");
	case SOAP_TYPE_PointerTons1__AuthorizationFaultType:
		return soap_out_PointerTons1__AuthorizationFaultType(soap, tag, id, (ns1__AuthorizationFaultType *const*)ptr, "ns1:AuthorizationFaultType");
	case SOAP_TYPE_PointerTons1__AuthenticationFaultType:
		return soap_out_PointerTons1__AuthenticationFaultType(soap, tag, id, (ns1__AuthenticationFaultType *const*)ptr, "ns1:AuthenticationFaultType");
	case SOAP_TYPE_PointerTo_delegationns__DelegationException:
		return soap_out_PointerTo_delegationns__DelegationException(soap, tag, id, (_delegationns__DelegationException *const*)ptr, "delegationns:DelegationException");
	case SOAP_TYPE_PointerTodelegation1__DelegationExceptionType:
		return soap_out_PointerTodelegation1__DelegationExceptionType(soap, tag, id, (delegation1__DelegationExceptionType *const*)ptr, "delegation1:DelegationExceptionType");
	case SOAP_TYPE_PointerTodouble:
		return soap_out_PointerTodouble(soap, tag, id, (double *const*)ptr, "xsd:double");
	case SOAP_TYPE_PointerTojsdlposix__GroupName_USCOREType:
		return soap_out_PointerTojsdlposix__GroupName_USCOREType(soap, tag, id, (jsdlposix__GroupName_USCOREType *const*)ptr, "jsdlposix:GroupName_Type");
	case SOAP_TYPE_PointerTojsdlposix__UserName_USCOREType:
		return soap_out_PointerTojsdlposix__UserName_USCOREType(soap, tag, id, (jsdlposix__UserName_USCOREType *const*)ptr, "jsdlposix:UserName_Type");
	case SOAP_TYPE_PointerTojsdlposix__Limits_USCOREType:
		return soap_out_PointerTojsdlposix__Limits_USCOREType(soap, tag, id, (jsdlposix__Limits_USCOREType *const*)ptr, "jsdlposix:Limits_Type");
	case SOAP_TYPE_PointerTojsdlposix__Environment_USCOREType:
		return soap_out_PointerTojsdlposix__Environment_USCOREType(soap, tag, id, (jsdlposix__Environment_USCOREType *const*)ptr, "jsdlposix:Environment_Type");
	case SOAP_TYPE_PointerTojsdlposix__DirectoryName_USCOREType:
		return soap_out_PointerTojsdlposix__DirectoryName_USCOREType(soap, tag, id, (jsdlposix__DirectoryName_USCOREType *const*)ptr, "jsdlposix:DirectoryName_Type");
	case SOAP_TYPE_PointerTojsdlposix__Argument_USCOREType:
		return soap_out_PointerTojsdlposix__Argument_USCOREType(soap, tag, id, (jsdlposix__Argument_USCOREType *const*)ptr, "jsdlposix:Argument_Type");
	case SOAP_TYPE_PointerTojsdlposix__FileName_USCOREType:
		return soap_out_PointerTojsdlposix__FileName_USCOREType(soap, tag, id, (jsdlposix__FileName_USCOREType *const*)ptr, "jsdlposix:FileName_Type");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_out_PointerToxsd__anyURI(soap, tag, id, (std::string *const*)ptr, "xsd:anyURI");
	case SOAP_TYPE_PointerTojsdl__SourceTarget_USCOREType:
		return soap_out_PointerTojsdl__SourceTarget_USCOREType(soap, tag, id, (jsdl__SourceTarget_USCOREType *const*)ptr, "jsdl:SourceTarget_Type");
	case SOAP_TYPE_PointerToxsd__NCName:
		return soap_out_PointerToxsd__NCName(soap, tag, id, (std::string *const*)ptr, "xsd:NCName");
	case SOAP_TYPE_PointerTojsdl__OperatingSystemType_USCOREType:
		return soap_out_PointerTojsdl__OperatingSystemType_USCOREType(soap, tag, id, (jsdl__OperatingSystemType_USCOREType *const*)ptr, "jsdl:OperatingSystemType_Type");
	case SOAP_TYPE_PointerTojsdl__FileSystemTypeEnumeration:
		return soap_out_PointerTojsdl__FileSystemTypeEnumeration(soap, tag, id, (enum jsdl__FileSystemTypeEnumeration *const*)ptr, "jsdl:FileSystemTypeEnumeration");
	case SOAP_TYPE_PointerTojsdl__RangeValue_USCOREType:
		return soap_out_PointerTojsdl__RangeValue_USCOREType(soap, tag, id, (jsdl__RangeValue_USCOREType *const*)ptr, "jsdl:RangeValue_Type");
	case SOAP_TYPE_PointerTojsdl__CPUArchitecture_USCOREType:
		return soap_out_PointerTojsdl__CPUArchitecture_USCOREType(soap, tag, id, (jsdl__CPUArchitecture_USCOREType *const*)ptr, "jsdl:CPUArchitecture_Type");
	case SOAP_TYPE_PointerTojsdl__OperatingSystem_USCOREType:
		return soap_out_PointerTojsdl__OperatingSystem_USCOREType(soap, tag, id, (jsdl__OperatingSystem_USCOREType *const*)ptr, "jsdl:OperatingSystem_Type");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTojsdl__FileSystem_USCOREType:
		return soap_out_PointerTojsdl__FileSystem_USCOREType(soap, tag, id, (jsdl__FileSystem_USCOREType *const*)ptr, "jsdl:FileSystem_Type");
	case SOAP_TYPE_PointerTojsdl__CandidateHosts_USCOREType:
		return soap_out_PointerTojsdl__CandidateHosts_USCOREType(soap, tag, id, (jsdl__CandidateHosts_USCOREType *const*)ptr, "jsdl:CandidateHosts_Type");
	case SOAP_TYPE_PointerTojsdl__Description_USCOREType:
		return soap_out_PointerTojsdl__Description_USCOREType(soap, tag, id, (std::string *const*)ptr, "jsdl:Description_Type");
	case SOAP_TYPE_PointerTojsdl__DataStaging_USCOREType:
		return soap_out_PointerTojsdl__DataStaging_USCOREType(soap, tag, id, (jsdl__DataStaging_USCOREType *const*)ptr, "jsdl:DataStaging_Type");
	case SOAP_TYPE_PointerTojsdl__Resources_USCOREType:
		return soap_out_PointerTojsdl__Resources_USCOREType(soap, tag, id, (jsdl__Resources_USCOREType *const*)ptr, "jsdl:Resources_Type");
	case SOAP_TYPE_PointerTojsdl__Application_USCOREType:
		return soap_out_PointerTojsdl__Application_USCOREType(soap, tag, id, (jsdl__Application_USCOREType *const*)ptr, "jsdl:Application_Type");
	case SOAP_TYPE_PointerTojsdl__JobIdentification_USCOREType:
		return soap_out_PointerTojsdl__JobIdentification_USCOREType(soap, tag, id, (jsdl__JobIdentification_USCOREType *const*)ptr, "jsdl:JobIdentification_Type");
	case SOAP_TYPE_PointerToxsd__ID:
		return soap_out_PointerToxsd__ID(soap, tag, id, (std::string *const*)ptr, "xsd:ID");
	case SOAP_TYPE_PointerTojsdl__JobDescription_USCOREType:
		return soap_out_PointerTojsdl__JobDescription_USCOREType(soap, tag, id, (jsdl__JobDescription_USCOREType *const*)ptr, "jsdl:JobDescription_Type");
	case SOAP_TYPE_PointerTojsdl__Range_USCOREType:
		return soap_out_PointerTojsdl__Range_USCOREType(soap, tag, id, (jsdl__Range_USCOREType *const*)ptr, "jsdl:Range_Type");
	case SOAP_TYPE_PointerTojsdl__Exact_USCOREType:
		return soap_out_PointerTojsdl__Exact_USCOREType(soap, tag, id, (jsdl__Exact_USCOREType *const*)ptr, "jsdl:Exact_Type");
	case SOAP_TYPE_PointerTojsdl__Boundary_USCOREType:
		return soap_out_PointerTojsdl__Boundary_USCOREType(soap, tag, id, (jsdl__Boundary_USCOREType *const*)ptr, "jsdl:Boundary_Type");
	case SOAP_TYPE_PointerTons1__VOProxyInfoStructType:
		return soap_out_PointerTons1__VOProxyInfoStructType(soap, tag, id, (ns1__VOProxyInfoStructType *const*)ptr, "ns1:VOProxyInfoStructType");
	case SOAP_TYPE_PointerTons1__GraphStructType:
		return soap_out_PointerTons1__GraphStructType(soap, tag, id, (ns1__GraphStructType *const*)ptr, "ns1:GraphStructType");
	case SOAP_TYPE_PointerTons1__JobIdStructType:
		return soap_out_PointerTons1__JobIdStructType(soap, tag, id, (ns1__JobIdStructType *const*)ptr, "ns1:JobIdStructType");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTons1__JobStatusStructType:
		return soap_out_PointerTons1__JobStatusStructType(soap, tag, id, (ns1__JobStatusStructType *const*)ptr, "ns1:JobStatusStructType");
	case SOAP_TYPE_PointerTons1__StringAndLongType:
		return soap_out_PointerTons1__StringAndLongType(soap, tag, id, (ns1__StringAndLongType *const*)ptr, "ns1:StringAndLongType");
	case SOAP_TYPE_PointerTons1__DestURIStructType:
		return soap_out_PointerTons1__DestURIStructType(soap, tag, id, (ns1__DestURIStructType *const*)ptr, "ns1:DestURIStructType");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_jsdl__Description_USCOREType:
		soap_serialize_jsdl__Description_USCOREType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_delegation1__DelegationExceptionType:
		((delegation1__DelegationExceptionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__delegationns__DelegationException:
		((_delegationns__DelegationException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_delegationns__NewProxyReq:
		((delegationns__NewProxyReq *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdlposix__POSIXApplication_USCOREType:
		((jsdlposix__POSIXApplication_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdlposix__GroupName_USCOREType:
		((jsdlposix__GroupName_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdlposix__UserName_USCOREType:
		((jsdlposix__UserName_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdlposix__Limits_USCOREType:
		((jsdlposix__Limits_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdlposix__DirectoryName_USCOREType:
		((jsdlposix__DirectoryName_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdlposix__FileName_USCOREType:
		((jsdlposix__FileName_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdlposix__Argument_USCOREType:
		((jsdlposix__Argument_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdlposix__Environment_USCOREType:
		((jsdlposix__Environment_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdl__SourceTarget_USCOREType:
		((jsdl__SourceTarget_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdl__DataStaging_USCOREType:
		((jsdl__DataStaging_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdl__OperatingSystemType_USCOREType:
		((jsdl__OperatingSystemType_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdl__OperatingSystem_USCOREType:
		((jsdl__OperatingSystem_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdl__FileSystem_USCOREType:
		((jsdl__FileSystem_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdl__CPUArchitecture_USCOREType:
		((jsdl__CPUArchitecture_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdl__CandidateHosts_USCOREType:
		((jsdl__CandidateHosts_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdl__Resources_USCOREType:
		((jsdl__Resources_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdl__Application_USCOREType:
		((jsdl__Application_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdl__JobIdentification_USCOREType:
		((jsdl__JobIdentification_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdl__JobDescription_USCOREType:
		((jsdl__JobDescription_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdl__JobDefinition_USCOREType:
		((jsdl__JobDefinition_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdl__RangeValue_USCOREType:
		((jsdl__RangeValue_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdl__Range_USCOREType:
		((jsdl__Range_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdl__Exact_USCOREType:
		((jsdl__Exact_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdl__Boundary_USCOREType:
		((jsdl__Boundary_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ServerOverloadedFaultType:
		((ns1__ServerOverloadedFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__OperationNotAllowedFaultType:
		((ns1__OperationNotAllowedFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__JobUnknownFaultType:
		((ns1__JobUnknownFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__NoSuitableResourcesFaultType:
		((ns1__NoSuitableResourcesFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GetQuotaManagementFaultType:
		((ns1__GetQuotaManagementFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__InvalidArgumentFaultType:
		((ns1__InvalidArgumentFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AuthorizationFaultType:
		((ns1__AuthorizationFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AuthenticationFaultType:
		((ns1__AuthenticationFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GenericFaultType:
		((ns1__GenericFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__BaseFaultType:
		((ns1__BaseFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ProxyInfoStructType:
		((ns1__ProxyInfoStructType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__VOProxyInfoStructType:
		((ns1__VOProxyInfoStructType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GraphStructType:
		((ns1__GraphStructType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__JobIdStructType:
		((ns1__JobIdStructType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__JobStatusStructType:
		((ns1__JobStatusStructType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__StringAndLongList:
		((ns1__StringAndLongList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__StringAndLongType:
		((ns1__StringAndLongType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DestURIsStructType:
		((ns1__DestURIsStructType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DestURIStructType:
		((ns1__DestURIStructType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__StringList:
		((ns1__StringList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__JobTypeList:
		((ns1__JobTypeList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__normalizedString:
		soap_serialize_xsd__normalizedString(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		soap_serialize_xsd__nonNegativeInteger(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_xsd__anyURI(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__NCName:
		soap_serialize_xsd__NCName(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__ID:
		soap_serialize_xsd__ID(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__getJobStatus:
		soap_serialize_ns1__getJobStatus(soap, (const struct ns1__getJobStatus *)ptr);
		break;
	case SOAP_TYPE_ns1__getJobStatusResponse:
		soap_serialize_ns1__getJobStatusResponse(soap, (const struct ns1__getJobStatusResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getTransferProtocols:
		soap_serialize_ns1__getTransferProtocols(soap, (const struct ns1__getTransferProtocols *)ptr);
		break;
	case SOAP_TYPE_ns1__getTransferProtocolsResponse:
		soap_serialize_ns1__getTransferProtocolsResponse(soap, (const struct ns1__getTransferProtocolsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getPerusalFiles:
		soap_serialize_ns1__getPerusalFiles(soap, (const struct ns1__getPerusalFiles *)ptr);
		break;
	case SOAP_TYPE_ns1__getPerusalFilesResponse:
		soap_serialize_ns1__getPerusalFilesResponse(soap, (const struct ns1__getPerusalFilesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__enableFilePerusal:
		soap_serialize_ns1__enableFilePerusal(soap, (const struct ns1__enableFilePerusal *)ptr);
		break;
	case SOAP_TYPE_ns1__enableFilePerusalResponse:
		soap_serialize_ns1__enableFilePerusalResponse(soap, (const struct ns1__enableFilePerusalResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getJobProxyInfo:
		soap_serialize_ns1__getJobProxyInfo(soap, (const struct ns1__getJobProxyInfo *)ptr);
		break;
	case SOAP_TYPE_ns1__getJobProxyInfoResponse:
		soap_serialize_ns1__getJobProxyInfoResponse(soap, (const struct ns1__getJobProxyInfoResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getDelegatedProxyInfo:
		soap_serialize_ns1__getDelegatedProxyInfo(soap, (const struct ns1__getDelegatedProxyInfo *)ptr);
		break;
	case SOAP_TYPE_ns1__getDelegatedProxyInfoResponse:
		soap_serialize_ns1__getDelegatedProxyInfoResponse(soap, (const struct ns1__getDelegatedProxyInfoResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__removeACLItem:
		soap_serialize_ns1__removeACLItem(soap, (const struct ns1__removeACLItem *)ptr);
		break;
	case SOAP_TYPE_ns1__removeACLItemResponse:
		soap_serialize_ns1__removeACLItemResponse(soap, (const struct ns1__removeACLItemResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__addACLItems:
		soap_serialize_ns1__addACLItems(soap, (const struct ns1__addACLItems *)ptr);
		break;
	case SOAP_TYPE_ns1__addACLItemsResponse:
		soap_serialize_ns1__addACLItemsResponse(soap, (const struct ns1__addACLItemsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getACLItems:
		soap_serialize_ns1__getACLItems(soap, (const struct ns1__getACLItems *)ptr);
		break;
	case SOAP_TYPE_ns1__getACLItemsResponse:
		soap_serialize_ns1__getACLItemsResponse(soap, (const struct ns1__getACLItemsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getStringParametricJobTemplate:
		soap_serialize_ns1__getStringParametricJobTemplate(soap, (const struct ns1__getStringParametricJobTemplate *)ptr);
		break;
	case SOAP_TYPE_ns1__getStringParametricJobTemplateResponse:
		soap_serialize_ns1__getStringParametricJobTemplateResponse(soap, (const struct ns1__getStringParametricJobTemplateResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getIntParametricJobTemplate:
		soap_serialize_ns1__getIntParametricJobTemplate(soap, (const struct ns1__getIntParametricJobTemplate *)ptr);
		break;
	case SOAP_TYPE_ns1__getIntParametricJobTemplateResponse:
		soap_serialize_ns1__getIntParametricJobTemplateResponse(soap, (const struct ns1__getIntParametricJobTemplateResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getCollectionTemplate:
		soap_serialize_ns1__getCollectionTemplate(soap, (const struct ns1__getCollectionTemplate *)ptr);
		break;
	case SOAP_TYPE_ns1__getCollectionTemplateResponse:
		soap_serialize_ns1__getCollectionTemplateResponse(soap, (const struct ns1__getCollectionTemplateResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getDAGTemplate:
		soap_serialize_ns1__getDAGTemplate(soap, (const struct ns1__getDAGTemplate *)ptr);
		break;
	case SOAP_TYPE_ns1__getDAGTemplateResponse:
		soap_serialize_ns1__getDAGTemplateResponse(soap, (const struct ns1__getDAGTemplateResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getJobTemplate:
		soap_serialize_ns1__getJobTemplate(soap, (const struct ns1__getJobTemplate *)ptr);
		break;
	case SOAP_TYPE_ns1__getJobTemplateResponse:
		soap_serialize_ns1__getJobTemplateResponse(soap, (const struct ns1__getJobTemplateResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__jobListMatchJSDL:
		soap_serialize_ns1__jobListMatchJSDL(soap, (const struct ns1__jobListMatchJSDL *)ptr);
		break;
	case SOAP_TYPE_ns1__jobListMatchJSDLResponse:
		soap_serialize_ns1__jobListMatchJSDLResponse(soap, (const struct ns1__jobListMatchJSDLResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__jobListMatch:
		soap_serialize_ns1__jobListMatch(soap, (const struct ns1__jobListMatch *)ptr);
		break;
	case SOAP_TYPE_ns1__jobListMatchResponse:
		soap_serialize_ns1__jobListMatchResponse(soap, (const struct ns1__jobListMatchResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getOutputFileList:
		soap_serialize_ns1__getOutputFileList(soap, (const struct ns1__getOutputFileList *)ptr);
		break;
	case SOAP_TYPE_ns1__getOutputFileListResponse:
		soap_serialize_ns1__getOutputFileListResponse(soap, (const struct ns1__getOutputFileListResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__jobPurge:
		soap_serialize_ns1__jobPurge(soap, (const struct ns1__jobPurge *)ptr);
		break;
	case SOAP_TYPE_ns1__jobPurgeResponse:
		soap_serialize_ns1__jobPurgeResponse(soap, (const struct ns1__jobPurgeResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getFreeQuota:
		soap_serialize_ns1__getFreeQuota(soap, (const struct ns1__getFreeQuota *)ptr);
		break;
	case SOAP_TYPE_ns1__getFreeQuotaResponse:
		soap_serialize_ns1__getFreeQuotaResponse(soap, (const struct ns1__getFreeQuotaResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getTotalQuota:
		soap_serialize_ns1__getTotalQuota(soap, (const struct ns1__getTotalQuota *)ptr);
		break;
	case SOAP_TYPE_ns1__getTotalQuotaResponse:
		soap_serialize_ns1__getTotalQuotaResponse(soap, (const struct ns1__getTotalQuotaResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getSandboxBulkDestURI:
		soap_serialize_ns1__getSandboxBulkDestURI(soap, (const struct ns1__getSandboxBulkDestURI *)ptr);
		break;
	case SOAP_TYPE_ns1__getSandboxBulkDestURIResponse:
		soap_serialize_ns1__getSandboxBulkDestURIResponse(soap, (const struct ns1__getSandboxBulkDestURIResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getSandboxDestURI:
		soap_serialize_ns1__getSandboxDestURI(soap, (const struct ns1__getSandboxDestURI *)ptr);
		break;
	case SOAP_TYPE_ns1__getSandboxDestURIResponse:
		soap_serialize_ns1__getSandboxDestURIResponse(soap, (const struct ns1__getSandboxDestURIResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getMaxInputSandboxSize:
		soap_serialize_ns1__getMaxInputSandboxSize(soap, (const struct ns1__getMaxInputSandboxSize *)ptr);
		break;
	case SOAP_TYPE_ns1__getMaxInputSandboxSizeResponse:
		soap_serialize_ns1__getMaxInputSandboxSizeResponse(soap, (const struct ns1__getMaxInputSandboxSizeResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__jobCancel:
		soap_serialize_ns1__jobCancel(soap, (const struct ns1__jobCancel *)ptr);
		break;
	case SOAP_TYPE_ns1__jobCancelResponse:
		soap_serialize_ns1__jobCancelResponse(soap, (const struct ns1__jobCancelResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__jobSubmitJSDL:
		soap_serialize_ns1__jobSubmitJSDL(soap, (const struct ns1__jobSubmitJSDL *)ptr);
		break;
	case SOAP_TYPE_ns1__jobSubmitJSDLResponse:
		soap_serialize_ns1__jobSubmitJSDLResponse(soap, (const struct ns1__jobSubmitJSDLResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__jobSubmit:
		soap_serialize_ns1__jobSubmit(soap, (const struct ns1__jobSubmit *)ptr);
		break;
	case SOAP_TYPE_ns1__jobSubmitResponse:
		soap_serialize_ns1__jobSubmitResponse(soap, (const struct ns1__jobSubmitResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__jobStart:
		soap_serialize_ns1__jobStart(soap, (const struct ns1__jobStart *)ptr);
		break;
	case SOAP_TYPE_ns1__jobStartResponse:
		soap_serialize_ns1__jobStartResponse(soap, (const struct ns1__jobStartResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__jobRegisterJSDL:
		soap_serialize_ns1__jobRegisterJSDL(soap, (const struct ns1__jobRegisterJSDL *)ptr);
		break;
	case SOAP_TYPE_ns1__jobRegisterJSDLResponse:
		soap_serialize_ns1__jobRegisterJSDLResponse(soap, (const struct ns1__jobRegisterJSDLResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__jobRegister:
		soap_serialize_ns1__jobRegister(soap, (const struct ns1__jobRegister *)ptr);
		break;
	case SOAP_TYPE_ns1__jobRegisterResponse:
		soap_serialize_ns1__jobRegisterResponse(soap, (const struct ns1__jobRegisterResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getJDL:
		soap_serialize_ns1__getJDL(soap, (const struct ns1__getJDL *)ptr);
		break;
	case SOAP_TYPE_ns1__getJDLResponse:
		soap_serialize_ns1__getJDLResponse(soap, (const struct ns1__getJDLResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getVersion:
		soap_serialize_ns1__getVersion(soap, (const struct ns1__getVersion *)ptr);
		break;
	case SOAP_TYPE_ns1__getVersionResponse:
		soap_serialize_ns1__getVersionResponse(soap, (const struct ns1__getVersionResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__putProxy:
		soap_serialize_ns1__putProxy(soap, (const struct ns1__putProxy *)ptr);
		break;
	case SOAP_TYPE_ns1__putProxyResponse:
		soap_serialize_ns1__putProxyResponse(soap, (const struct ns1__putProxyResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getProxyReq:
		soap_serialize_ns1__getProxyReq(soap, (const struct ns1__getProxyReq *)ptr);
		break;
	case SOAP_TYPE_ns1__getProxyReqResponse:
		soap_serialize_ns1__getProxyReqResponse(soap, (const struct ns1__getProxyReqResponse *)ptr);
		break;
	case SOAP_TYPE_delegationns__destroy:
		soap_serialize_delegationns__destroy(soap, (const struct delegationns__destroy *)ptr);
		break;
	case SOAP_TYPE_delegationns__destroyResponse:
		soap_serialize_delegationns__destroyResponse(soap, (const struct delegationns__destroyResponse *)ptr);
		break;
	case SOAP_TYPE_delegationns__getTerminationTime:
		soap_serialize_delegationns__getTerminationTime(soap, (const struct delegationns__getTerminationTime *)ptr);
		break;
	case SOAP_TYPE_delegationns__getTerminationTimeResponse:
		soap_serialize_delegationns__getTerminationTimeResponse(soap, (const struct delegationns__getTerminationTimeResponse *)ptr);
		break;
	case SOAP_TYPE_delegationns__putProxy:
		soap_serialize_delegationns__putProxy(soap, (const struct delegationns__putProxy *)ptr);
		break;
	case SOAP_TYPE_delegationns__putProxyResponse:
		soap_serialize_delegationns__putProxyResponse(soap, (const struct delegationns__putProxyResponse *)ptr);
		break;
	case SOAP_TYPE_delegationns__renewProxyReq:
		soap_serialize_delegationns__renewProxyReq(soap, (const struct delegationns__renewProxyReq *)ptr);
		break;
	case SOAP_TYPE_delegationns__renewProxyReqResponse:
		soap_serialize_delegationns__renewProxyReqResponse(soap, (const struct delegationns__renewProxyReqResponse *)ptr);
		break;
	case SOAP_TYPE_delegationns__getNewProxyReq:
		soap_serialize_delegationns__getNewProxyReq(soap, (const struct delegationns__getNewProxyReq *)ptr);
		break;
	case SOAP_TYPE_delegationns__getNewProxyReqResponse:
		soap_serialize_delegationns__getNewProxyReqResponse(soap, (const struct delegationns__getNewProxyReqResponse *)ptr);
		break;
	case SOAP_TYPE_delegationns__getProxyReq:
		soap_serialize_delegationns__getProxyReq(soap, (const struct delegationns__getProxyReq *)ptr);
		break;
	case SOAP_TYPE_delegationns__getProxyReqResponse:
		soap_serialize_delegationns__getProxyReqResponse(soap, (const struct delegationns__getProxyReqResponse *)ptr);
		break;
	case SOAP_TYPE_delegationns__getServiceMetadata:
		soap_serialize_delegationns__getServiceMetadata(soap, (const struct delegationns__getServiceMetadata *)ptr);
		break;
	case SOAP_TYPE_delegationns__getServiceMetadataResponse:
		soap_serialize_delegationns__getServiceMetadataResponse(soap, (const struct delegationns__getServiceMetadataResponse *)ptr);
		break;
	case SOAP_TYPE_delegationns__getInterfaceVersion:
		soap_serialize_delegationns__getInterfaceVersion(soap, (const struct delegationns__getInterfaceVersion *)ptr);
		break;
	case SOAP_TYPE_delegationns__getInterfaceVersionResponse:
		soap_serialize_delegationns__getInterfaceVersionResponse(soap, (const struct delegationns__getInterfaceVersionResponse *)ptr);
		break;
	case SOAP_TYPE_delegationns__getVersion:
		soap_serialize_delegationns__getVersion(soap, (const struct delegationns__getVersion *)ptr);
		break;
	case SOAP_TYPE_delegationns__getVersionResponse:
		soap_serialize_delegationns__getVersionResponse(soap, (const struct delegationns__getVersionResponse *)ptr);
		break;
	case SOAP_TYPE_delegation1__putProxy:
		soap_serialize_delegation1__putProxy(soap, (const struct delegation1__putProxy *)ptr);
		break;
	case SOAP_TYPE_delegation1__putProxyResponse:
		soap_serialize_delegation1__putProxyResponse(soap, (const struct delegation1__putProxyResponse *)ptr);
		break;
	case SOAP_TYPE_delegation1__getProxyReq:
		soap_serialize_delegation1__getProxyReq(soap, (const struct delegation1__getProxyReq *)ptr);
		break;
	case SOAP_TYPE_delegation1__getProxyReqResponse:
		soap_serialize_delegation1__getProxyReqResponse(soap, (const struct delegation1__getProxyReqResponse *)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ProxyInfoStructType:
		soap_serialize_PointerTons1__ProxyInfoStructType(soap, (ns1__ProxyInfoStructType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__JobTypeList:
		soap_serialize_PointerTons1__JobTypeList(soap, (ns1__JobTypeList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__StringAndLongList:
		soap_serialize_PointerTons1__StringAndLongList(soap, (ns1__StringAndLongList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DestURIsStructType:
		soap_serialize_PointerTons1__DestURIsStructType(soap, (ns1__DestURIsStructType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__StringList:
		soap_serialize_PointerTons1__StringList(soap, (ns1__StringList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__JobDefinition_USCOREType:
		soap_serialize_PointerTojsdl__JobDefinition_USCOREType(soap, (jsdl__JobDefinition_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodelegationns__NewProxyReq:
		soap_serialize_PointerTodelegationns__NewProxyReq(soap, (delegationns__NewProxyReq *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ServerOverloadedFaultType:
		soap_serialize_PointerTons1__ServerOverloadedFaultType(soap, (ns1__ServerOverloadedFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__OperationNotAllowedFaultType:
		soap_serialize_PointerTons1__OperationNotAllowedFaultType(soap, (ns1__OperationNotAllowedFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__NoSuitableResourcesFaultType:
		soap_serialize_PointerTons1__NoSuitableResourcesFaultType(soap, (ns1__NoSuitableResourcesFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__JobUnknownFaultType:
		soap_serialize_PointerTons1__JobUnknownFaultType(soap, (ns1__JobUnknownFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__InvalidArgumentFaultType:
		soap_serialize_PointerTons1__InvalidArgumentFaultType(soap, (ns1__InvalidArgumentFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GetQuotaManagementFaultType:
		soap_serialize_PointerTons1__GetQuotaManagementFaultType(soap, (ns1__GetQuotaManagementFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GenericFaultType:
		soap_serialize_PointerTons1__GenericFaultType(soap, (ns1__GenericFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AuthorizationFaultType:
		soap_serialize_PointerTons1__AuthorizationFaultType(soap, (ns1__AuthorizationFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AuthenticationFaultType:
		soap_serialize_PointerTons1__AuthenticationFaultType(soap, (ns1__AuthenticationFaultType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_delegationns__DelegationException:
		soap_serialize_PointerTo_delegationns__DelegationException(soap, (_delegationns__DelegationException *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodelegation1__DelegationExceptionType:
		soap_serialize_PointerTodelegation1__DelegationExceptionType(soap, (delegation1__DelegationExceptionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodouble:
		soap_serialize_PointerTodouble(soap, (double *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdlposix__GroupName_USCOREType:
		soap_serialize_PointerTojsdlposix__GroupName_USCOREType(soap, (jsdlposix__GroupName_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdlposix__UserName_USCOREType:
		soap_serialize_PointerTojsdlposix__UserName_USCOREType(soap, (jsdlposix__UserName_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdlposix__Limits_USCOREType:
		soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, (jsdlposix__Limits_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdlposix__Environment_USCOREType:
		soap_serialize_PointerTojsdlposix__Environment_USCOREType(soap, (jsdlposix__Environment_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdlposix__DirectoryName_USCOREType:
		soap_serialize_PointerTojsdlposix__DirectoryName_USCOREType(soap, (jsdlposix__DirectoryName_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdlposix__Argument_USCOREType:
		soap_serialize_PointerTojsdlposix__Argument_USCOREType(soap, (jsdlposix__Argument_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdlposix__FileName_USCOREType:
		soap_serialize_PointerTojsdlposix__FileName_USCOREType(soap, (jsdlposix__FileName_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__anyURI:
		soap_serialize_PointerToxsd__anyURI(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__SourceTarget_USCOREType:
		soap_serialize_PointerTojsdl__SourceTarget_USCOREType(soap, (jsdl__SourceTarget_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__NCName:
		soap_serialize_PointerToxsd__NCName(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__OperatingSystemType_USCOREType:
		soap_serialize_PointerTojsdl__OperatingSystemType_USCOREType(soap, (jsdl__OperatingSystemType_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__FileSystemTypeEnumeration:
		soap_serialize_PointerTojsdl__FileSystemTypeEnumeration(soap, (enum jsdl__FileSystemTypeEnumeration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__RangeValue_USCOREType:
		soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, (jsdl__RangeValue_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__CPUArchitecture_USCOREType:
		soap_serialize_PointerTojsdl__CPUArchitecture_USCOREType(soap, (jsdl__CPUArchitecture_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__OperatingSystem_USCOREType:
		soap_serialize_PointerTojsdl__OperatingSystem_USCOREType(soap, (jsdl__OperatingSystem_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__FileSystem_USCOREType:
		soap_serialize_PointerTojsdl__FileSystem_USCOREType(soap, (jsdl__FileSystem_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__CandidateHosts_USCOREType:
		soap_serialize_PointerTojsdl__CandidateHosts_USCOREType(soap, (jsdl__CandidateHosts_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__Description_USCOREType:
		soap_serialize_PointerTojsdl__Description_USCOREType(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__DataStaging_USCOREType:
		soap_serialize_PointerTojsdl__DataStaging_USCOREType(soap, (jsdl__DataStaging_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__Resources_USCOREType:
		soap_serialize_PointerTojsdl__Resources_USCOREType(soap, (jsdl__Resources_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__Application_USCOREType:
		soap_serialize_PointerTojsdl__Application_USCOREType(soap, (jsdl__Application_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__JobIdentification_USCOREType:
		soap_serialize_PointerTojsdl__JobIdentification_USCOREType(soap, (jsdl__JobIdentification_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__ID:
		soap_serialize_PointerToxsd__ID(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__JobDescription_USCOREType:
		soap_serialize_PointerTojsdl__JobDescription_USCOREType(soap, (jsdl__JobDescription_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__Range_USCOREType:
		soap_serialize_PointerTojsdl__Range_USCOREType(soap, (jsdl__Range_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__Exact_USCOREType:
		soap_serialize_PointerTojsdl__Exact_USCOREType(soap, (jsdl__Exact_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__Boundary_USCOREType:
		soap_serialize_PointerTojsdl__Boundary_USCOREType(soap, (jsdl__Boundary_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__VOProxyInfoStructType:
		soap_serialize_PointerTons1__VOProxyInfoStructType(soap, (ns1__VOProxyInfoStructType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GraphStructType:
		soap_serialize_PointerTons1__GraphStructType(soap, (ns1__GraphStructType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__JobIdStructType:
		soap_serialize_PointerTons1__JobIdStructType(soap, (ns1__JobIdStructType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__JobStatusStructType:
		soap_serialize_PointerTons1__JobStatusStructType(soap, (ns1__JobStatusStructType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__StringAndLongType:
		soap_serialize_PointerTons1__StringAndLongType(soap, (ns1__StringAndLongType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DestURIStructType:
		soap_serialize_PointerTons1__DestURIStructType(soap, (ns1__DestURIStructType *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__JobTypeList:
		return (void*)soap_instantiate_ns1__JobTypeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__StringList:
		return (void*)soap_instantiate_ns1__StringList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DestURIStructType:
		return (void*)soap_instantiate_ns1__DestURIStructType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DestURIsStructType:
		return (void*)soap_instantiate_ns1__DestURIsStructType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__StringAndLongType:
		return (void*)soap_instantiate_ns1__StringAndLongType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__StringAndLongList:
		return (void*)soap_instantiate_ns1__StringAndLongList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__JobStatusStructType:
		return (void*)soap_instantiate_ns1__JobStatusStructType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__JobIdStructType:
		return (void*)soap_instantiate_ns1__JobIdStructType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GraphStructType:
		return (void*)soap_instantiate_ns1__GraphStructType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__VOProxyInfoStructType:
		return (void*)soap_instantiate_ns1__VOProxyInfoStructType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ProxyInfoStructType:
		return (void*)soap_instantiate_ns1__ProxyInfoStructType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__BaseFaultType:
		return (void*)soap_instantiate_ns1__BaseFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__Range_USCOREType:
		return (void*)soap_instantiate_jsdl__Range_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__RangeValue_USCOREType:
		return (void*)soap_instantiate_jsdl__RangeValue_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__JobDefinition_USCOREType:
		return (void*)soap_instantiate_jsdl__JobDefinition_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__JobDescription_USCOREType:
		return (void*)soap_instantiate_jsdl__JobDescription_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__JobIdentification_USCOREType:
		return (void*)soap_instantiate_jsdl__JobIdentification_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__Application_USCOREType:
		return (void*)soap_instantiate_jsdl__Application_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__Resources_USCOREType:
		return (void*)soap_instantiate_jsdl__Resources_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__CandidateHosts_USCOREType:
		return (void*)soap_instantiate_jsdl__CandidateHosts_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__CPUArchitecture_USCOREType:
		return (void*)soap_instantiate_jsdl__CPUArchitecture_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__FileSystem_USCOREType:
		return (void*)soap_instantiate_jsdl__FileSystem_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__OperatingSystem_USCOREType:
		return (void*)soap_instantiate_jsdl__OperatingSystem_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__OperatingSystemType_USCOREType:
		return (void*)soap_instantiate_jsdl__OperatingSystemType_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__DataStaging_USCOREType:
		return (void*)soap_instantiate_jsdl__DataStaging_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__SourceTarget_USCOREType:
		return (void*)soap_instantiate_jsdl__SourceTarget_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdlposix__POSIXApplication_USCOREType:
		return (void*)soap_instantiate_jsdlposix__POSIXApplication_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegationns__NewProxyReq:
		return (void*)soap_instantiate_delegationns__NewProxyReq(soap, -1, type, arrayType, n);
	case SOAP_TYPE__delegationns__DelegationException:
		return (void*)soap_instantiate__delegationns__DelegationException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegation1__DelegationExceptionType:
		return (void*)soap_instantiate_delegation1__DelegationExceptionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GenericFaultType:
		return (void*)soap_instantiate_ns1__GenericFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AuthenticationFaultType:
		return (void*)soap_instantiate_ns1__AuthenticationFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AuthorizationFaultType:
		return (void*)soap_instantiate_ns1__AuthorizationFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__InvalidArgumentFaultType:
		return (void*)soap_instantiate_ns1__InvalidArgumentFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetQuotaManagementFaultType:
		return (void*)soap_instantiate_ns1__GetQuotaManagementFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__NoSuitableResourcesFaultType:
		return (void*)soap_instantiate_ns1__NoSuitableResourcesFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__JobUnknownFaultType:
		return (void*)soap_instantiate_ns1__JobUnknownFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__OperationNotAllowedFaultType:
		return (void*)soap_instantiate_ns1__OperationNotAllowedFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ServerOverloadedFaultType:
		return (void*)soap_instantiate_ns1__ServerOverloadedFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__Boundary_USCOREType:
		return (void*)soap_instantiate_jsdl__Boundary_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__Exact_USCOREType:
		return (void*)soap_instantiate_jsdl__Exact_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdlposix__Environment_USCOREType:
		return (void*)soap_instantiate_jsdlposix__Environment_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdlposix__Argument_USCOREType:
		return (void*)soap_instantiate_jsdlposix__Argument_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdlposix__FileName_USCOREType:
		return (void*)soap_instantiate_jsdlposix__FileName_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdlposix__DirectoryName_USCOREType:
		return (void*)soap_instantiate_jsdlposix__DirectoryName_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdlposix__Limits_USCOREType:
		return (void*)soap_instantiate_jsdlposix__Limits_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdlposix__UserName_USCOREType:
		return (void*)soap_instantiate_jsdlposix__UserName_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdlposix__GroupName_USCOREType:
		return (void*)soap_instantiate_jsdlposix__GroupName_USCOREType(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_delegation1__getProxyReqResponse:
		return (void*)soap_instantiate_delegation1__getProxyReqResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegation1__getProxyReq:
		return (void*)soap_instantiate_delegation1__getProxyReq(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegation1__putProxyResponse:
		return (void*)soap_instantiate_delegation1__putProxyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegation1__putProxy:
		return (void*)soap_instantiate_delegation1__putProxy(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegationns__getVersionResponse:
		return (void*)soap_instantiate_delegationns__getVersionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegationns__getVersion:
		return (void*)soap_instantiate_delegationns__getVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegationns__getInterfaceVersionResponse:
		return (void*)soap_instantiate_delegationns__getInterfaceVersionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegationns__getInterfaceVersion:
		return (void*)soap_instantiate_delegationns__getInterfaceVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegationns__getServiceMetadataResponse:
		return (void*)soap_instantiate_delegationns__getServiceMetadataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegationns__getServiceMetadata:
		return (void*)soap_instantiate_delegationns__getServiceMetadata(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegationns__getProxyReqResponse:
		return (void*)soap_instantiate_delegationns__getProxyReqResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegationns__getProxyReq:
		return (void*)soap_instantiate_delegationns__getProxyReq(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegationns__getNewProxyReqResponse:
		return (void*)soap_instantiate_delegationns__getNewProxyReqResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegationns__getNewProxyReq:
		return (void*)soap_instantiate_delegationns__getNewProxyReq(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegationns__renewProxyReqResponse:
		return (void*)soap_instantiate_delegationns__renewProxyReqResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegationns__renewProxyReq:
		return (void*)soap_instantiate_delegationns__renewProxyReq(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegationns__putProxyResponse:
		return (void*)soap_instantiate_delegationns__putProxyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegationns__putProxy:
		return (void*)soap_instantiate_delegationns__putProxy(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegationns__getTerminationTimeResponse:
		return (void*)soap_instantiate_delegationns__getTerminationTimeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegationns__getTerminationTime:
		return (void*)soap_instantiate_delegationns__getTerminationTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegationns__destroyResponse:
		return (void*)soap_instantiate_delegationns__destroyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_delegationns__destroy:
		return (void*)soap_instantiate_delegationns__destroy(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getProxyReqResponse:
		return (void*)soap_instantiate_ns1__getProxyReqResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getProxyReq:
		return (void*)soap_instantiate_ns1__getProxyReq(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__putProxyResponse:
		return (void*)soap_instantiate_ns1__putProxyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__putProxy:
		return (void*)soap_instantiate_ns1__putProxy(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getVersionResponse:
		return (void*)soap_instantiate_ns1__getVersionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getVersion:
		return (void*)soap_instantiate_ns1__getVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getJDLResponse:
		return (void*)soap_instantiate_ns1__getJDLResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getJDL:
		return (void*)soap_instantiate_ns1__getJDL(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__jobRegisterResponse:
		return (void*)soap_instantiate_ns1__jobRegisterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__jobRegister:
		return (void*)soap_instantiate_ns1__jobRegister(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__jobRegisterJSDLResponse:
		return (void*)soap_instantiate_ns1__jobRegisterJSDLResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__jobRegisterJSDL:
		return (void*)soap_instantiate_ns1__jobRegisterJSDL(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__jobStartResponse:
		return (void*)soap_instantiate_ns1__jobStartResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__jobStart:
		return (void*)soap_instantiate_ns1__jobStart(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__jobSubmitResponse:
		return (void*)soap_instantiate_ns1__jobSubmitResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__jobSubmit:
		return (void*)soap_instantiate_ns1__jobSubmit(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__jobSubmitJSDLResponse:
		return (void*)soap_instantiate_ns1__jobSubmitJSDLResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__jobSubmitJSDL:
		return (void*)soap_instantiate_ns1__jobSubmitJSDL(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__jobCancelResponse:
		return (void*)soap_instantiate_ns1__jobCancelResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__jobCancel:
		return (void*)soap_instantiate_ns1__jobCancel(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getMaxInputSandboxSizeResponse:
		return (void*)soap_instantiate_ns1__getMaxInputSandboxSizeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getMaxInputSandboxSize:
		return (void*)soap_instantiate_ns1__getMaxInputSandboxSize(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getSandboxDestURIResponse:
		return (void*)soap_instantiate_ns1__getSandboxDestURIResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getSandboxDestURI:
		return (void*)soap_instantiate_ns1__getSandboxDestURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getSandboxBulkDestURIResponse:
		return (void*)soap_instantiate_ns1__getSandboxBulkDestURIResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getSandboxBulkDestURI:
		return (void*)soap_instantiate_ns1__getSandboxBulkDestURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTotalQuotaResponse:
		return (void*)soap_instantiate_ns1__getTotalQuotaResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTotalQuota:
		return (void*)soap_instantiate_ns1__getTotalQuota(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getFreeQuotaResponse:
		return (void*)soap_instantiate_ns1__getFreeQuotaResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getFreeQuota:
		return (void*)soap_instantiate_ns1__getFreeQuota(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__jobPurgeResponse:
		return (void*)soap_instantiate_ns1__jobPurgeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__jobPurge:
		return (void*)soap_instantiate_ns1__jobPurge(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getOutputFileListResponse:
		return (void*)soap_instantiate_ns1__getOutputFileListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getOutputFileList:
		return (void*)soap_instantiate_ns1__getOutputFileList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__jobListMatchResponse:
		return (void*)soap_instantiate_ns1__jobListMatchResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__jobListMatch:
		return (void*)soap_instantiate_ns1__jobListMatch(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__jobListMatchJSDLResponse:
		return (void*)soap_instantiate_ns1__jobListMatchJSDLResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__jobListMatchJSDL:
		return (void*)soap_instantiate_ns1__jobListMatchJSDL(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getJobTemplateResponse:
		return (void*)soap_instantiate_ns1__getJobTemplateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getJobTemplate:
		return (void*)soap_instantiate_ns1__getJobTemplate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDAGTemplateResponse:
		return (void*)soap_instantiate_ns1__getDAGTemplateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDAGTemplate:
		return (void*)soap_instantiate_ns1__getDAGTemplate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getCollectionTemplateResponse:
		return (void*)soap_instantiate_ns1__getCollectionTemplateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getCollectionTemplate:
		return (void*)soap_instantiate_ns1__getCollectionTemplate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getIntParametricJobTemplateResponse:
		return (void*)soap_instantiate_ns1__getIntParametricJobTemplateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getIntParametricJobTemplate:
		return (void*)soap_instantiate_ns1__getIntParametricJobTemplate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getStringParametricJobTemplateResponse:
		return (void*)soap_instantiate_ns1__getStringParametricJobTemplateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getStringParametricJobTemplate:
		return (void*)soap_instantiate_ns1__getStringParametricJobTemplate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getACLItemsResponse:
		return (void*)soap_instantiate_ns1__getACLItemsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getACLItems:
		return (void*)soap_instantiate_ns1__getACLItems(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addACLItemsResponse:
		return (void*)soap_instantiate_ns1__addACLItemsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addACLItems:
		return (void*)soap_instantiate_ns1__addACLItems(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removeACLItemResponse:
		return (void*)soap_instantiate_ns1__removeACLItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removeACLItem:
		return (void*)soap_instantiate_ns1__removeACLItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDelegatedProxyInfoResponse:
		return (void*)soap_instantiate_ns1__getDelegatedProxyInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDelegatedProxyInfo:
		return (void*)soap_instantiate_ns1__getDelegatedProxyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getJobProxyInfoResponse:
		return (void*)soap_instantiate_ns1__getJobProxyInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getJobProxyInfo:
		return (void*)soap_instantiate_ns1__getJobProxyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__enableFilePerusalResponse:
		return (void*)soap_instantiate_ns1__enableFilePerusalResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__enableFilePerusal:
		return (void*)soap_instantiate_ns1__enableFilePerusal(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getPerusalFilesResponse:
		return (void*)soap_instantiate_ns1__getPerusalFilesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getPerusalFiles:
		return (void*)soap_instantiate_ns1__getPerusalFiles(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTransferProtocolsResponse:
		return (void*)soap_instantiate_ns1__getTransferProtocolsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTransferProtocols:
		return (void*)soap_instantiate_ns1__getTransferProtocols(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getJobStatusResponse:
		return (void*)soap_instantiate_ns1__getJobStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getJobStatus:
		return (void*)soap_instantiate_ns1__getJobStatus(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__ID:
		return (void*)soap_instantiate_xsd__ID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__NCName:
		return (void*)soap_instantiate_xsd__NCName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anyURI:
		return (void*)soap_instantiate_xsd__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return (void*)soap_instantiate_xsd__nonNegativeInteger(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__normalizedString:
		return (void*)soap_instantiate_xsd__normalizedString(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__Description_USCOREType:
		return (void*)soap_instantiate_jsdl__Description_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		return (void*)soap_instantiate_std__vectorTemplateOf_XML(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__Range_USCOREType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__VOProxyInfoStructType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__VOProxyInfoStructType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__GraphStructType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__GraphStructType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__JobIdStructType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__JobIdStructType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__JobStatusStructType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__JobStatusStructType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__StringAndLongType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__StringAndLongType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DestURIStructType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__DestURIStructType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns1__JobType:
		return (void*)soap_instantiate_std__vectorTemplateOfns1__JobType(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns1__JobTypeList:
		if (p->size < 0)
			SOAP_DELETE((ns1__JobTypeList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__JobTypeList*)p->ptr);
		break;
	case SOAP_TYPE_ns1__StringList:
		if (p->size < 0)
			SOAP_DELETE((ns1__StringList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__StringList*)p->ptr);
		break;
	case SOAP_TYPE_ns1__DestURIStructType:
		if (p->size < 0)
			SOAP_DELETE((ns1__DestURIStructType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__DestURIStructType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__DestURIsStructType:
		if (p->size < 0)
			SOAP_DELETE((ns1__DestURIsStructType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__DestURIsStructType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__StringAndLongType:
		if (p->size < 0)
			SOAP_DELETE((ns1__StringAndLongType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__StringAndLongType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__StringAndLongList:
		if (p->size < 0)
			SOAP_DELETE((ns1__StringAndLongList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__StringAndLongList*)p->ptr);
		break;
	case SOAP_TYPE_ns1__JobStatusStructType:
		if (p->size < 0)
			SOAP_DELETE((ns1__JobStatusStructType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__JobStatusStructType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__JobIdStructType:
		if (p->size < 0)
			SOAP_DELETE((ns1__JobIdStructType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__JobIdStructType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GraphStructType:
		if (p->size < 0)
			SOAP_DELETE((ns1__GraphStructType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__GraphStructType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__VOProxyInfoStructType:
		if (p->size < 0)
			SOAP_DELETE((ns1__VOProxyInfoStructType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__VOProxyInfoStructType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ProxyInfoStructType:
		if (p->size < 0)
			SOAP_DELETE((ns1__ProxyInfoStructType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ProxyInfoStructType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__BaseFaultType:
		if (p->size < 0)
			SOAP_DELETE((ns1__BaseFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__BaseFaultType*)p->ptr);
		break;
	case SOAP_TYPE_jsdl__Range_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((jsdl__Range_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((jsdl__Range_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_jsdl__RangeValue_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((jsdl__RangeValue_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((jsdl__RangeValue_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_jsdl__JobDefinition_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((jsdl__JobDefinition_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((jsdl__JobDefinition_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_jsdl__JobDescription_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((jsdl__JobDescription_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((jsdl__JobDescription_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_jsdl__JobIdentification_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((jsdl__JobIdentification_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((jsdl__JobIdentification_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_jsdl__Application_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((jsdl__Application_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((jsdl__Application_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_jsdl__Resources_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((jsdl__Resources_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((jsdl__Resources_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_jsdl__CandidateHosts_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((jsdl__CandidateHosts_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((jsdl__CandidateHosts_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_jsdl__CPUArchitecture_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((jsdl__CPUArchitecture_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((jsdl__CPUArchitecture_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_jsdl__FileSystem_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((jsdl__FileSystem_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((jsdl__FileSystem_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_jsdl__OperatingSystem_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((jsdl__OperatingSystem_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((jsdl__OperatingSystem_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_jsdl__OperatingSystemType_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((jsdl__OperatingSystemType_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((jsdl__OperatingSystemType_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_jsdl__DataStaging_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((jsdl__DataStaging_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((jsdl__DataStaging_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_jsdl__SourceTarget_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((jsdl__SourceTarget_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((jsdl__SourceTarget_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_jsdlposix__POSIXApplication_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((jsdlposix__POSIXApplication_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((jsdlposix__POSIXApplication_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_delegationns__NewProxyReq:
		if (p->size < 0)
			SOAP_DELETE((delegationns__NewProxyReq*)p->ptr);
		else
			SOAP_DELETE_ARRAY((delegationns__NewProxyReq*)p->ptr);
		break;
	case SOAP_TYPE__delegationns__DelegationException:
		if (p->size < 0)
			SOAP_DELETE((_delegationns__DelegationException*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_delegationns__DelegationException*)p->ptr);
		break;
	case SOAP_TYPE_delegation1__DelegationExceptionType:
		if (p->size < 0)
			SOAP_DELETE((delegation1__DelegationExceptionType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((delegation1__DelegationExceptionType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GenericFaultType:
		if (p->size < 0)
			SOAP_DELETE((ns1__GenericFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__GenericFaultType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__AuthenticationFaultType:
		if (p->size < 0)
			SOAP_DELETE((ns1__AuthenticationFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__AuthenticationFaultType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__AuthorizationFaultType:
		if (p->size < 0)
			SOAP_DELETE((ns1__AuthorizationFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__AuthorizationFaultType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__InvalidArgumentFaultType:
		if (p->size < 0)
			SOAP_DELETE((ns1__InvalidArgumentFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__InvalidArgumentFaultType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GetQuotaManagementFaultType:
		if (p->size < 0)
			SOAP_DELETE((ns1__GetQuotaManagementFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__GetQuotaManagementFaultType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__NoSuitableResourcesFaultType:
		if (p->size < 0)
			SOAP_DELETE((ns1__NoSuitableResourcesFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__NoSuitableResourcesFaultType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__JobUnknownFaultType:
		if (p->size < 0)
			SOAP_DELETE((ns1__JobUnknownFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__JobUnknownFaultType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__OperationNotAllowedFaultType:
		if (p->size < 0)
			SOAP_DELETE((ns1__OperationNotAllowedFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__OperationNotAllowedFaultType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ServerOverloadedFaultType:
		if (p->size < 0)
			SOAP_DELETE((ns1__ServerOverloadedFaultType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ServerOverloadedFaultType*)p->ptr);
		break;
	case SOAP_TYPE_jsdl__Boundary_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((jsdl__Boundary_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((jsdl__Boundary_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_jsdl__Exact_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((jsdl__Exact_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((jsdl__Exact_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_jsdlposix__Environment_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((jsdlposix__Environment_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((jsdlposix__Environment_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_jsdlposix__Argument_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((jsdlposix__Argument_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((jsdlposix__Argument_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_jsdlposix__FileName_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((jsdlposix__FileName_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((jsdlposix__FileName_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_jsdlposix__DirectoryName_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((jsdlposix__DirectoryName_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((jsdlposix__DirectoryName_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_jsdlposix__Limits_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((jsdlposix__Limits_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((jsdlposix__Limits_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_jsdlposix__UserName_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((jsdlposix__UserName_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((jsdlposix__UserName_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_jsdlposix__GroupName_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((jsdlposix__GroupName_USCOREType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((jsdlposix__GroupName_USCOREType*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
	case SOAP_TYPE_delegation1__getProxyReqResponse:
		if (p->size < 0)
			SOAP_DELETE((struct delegation1__getProxyReqResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation1__getProxyReqResponse*)p->ptr);
		break;
	case SOAP_TYPE_delegation1__getProxyReq:
		if (p->size < 0)
			SOAP_DELETE((struct delegation1__getProxyReq*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation1__getProxyReq*)p->ptr);
		break;
	case SOAP_TYPE_delegation1__putProxyResponse:
		if (p->size < 0)
			SOAP_DELETE((struct delegation1__putProxyResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation1__putProxyResponse*)p->ptr);
		break;
	case SOAP_TYPE_delegation1__putProxy:
		if (p->size < 0)
			SOAP_DELETE((struct delegation1__putProxy*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegation1__putProxy*)p->ptr);
		break;
	case SOAP_TYPE_delegationns__getVersionResponse:
		if (p->size < 0)
			SOAP_DELETE((struct delegationns__getVersionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegationns__getVersionResponse*)p->ptr);
		break;
	case SOAP_TYPE_delegationns__getVersion:
		if (p->size < 0)
			SOAP_DELETE((struct delegationns__getVersion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegationns__getVersion*)p->ptr);
		break;
	case SOAP_TYPE_delegationns__getInterfaceVersionResponse:
		if (p->size < 0)
			SOAP_DELETE((struct delegationns__getInterfaceVersionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegationns__getInterfaceVersionResponse*)p->ptr);
		break;
	case SOAP_TYPE_delegationns__getInterfaceVersion:
		if (p->size < 0)
			SOAP_DELETE((struct delegationns__getInterfaceVersion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegationns__getInterfaceVersion*)p->ptr);
		break;
	case SOAP_TYPE_delegationns__getServiceMetadataResponse:
		if (p->size < 0)
			SOAP_DELETE((struct delegationns__getServiceMetadataResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegationns__getServiceMetadataResponse*)p->ptr);
		break;
	case SOAP_TYPE_delegationns__getServiceMetadata:
		if (p->size < 0)
			SOAP_DELETE((struct delegationns__getServiceMetadata*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegationns__getServiceMetadata*)p->ptr);
		break;
	case SOAP_TYPE_delegationns__getProxyReqResponse:
		if (p->size < 0)
			SOAP_DELETE((struct delegationns__getProxyReqResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegationns__getProxyReqResponse*)p->ptr);
		break;
	case SOAP_TYPE_delegationns__getProxyReq:
		if (p->size < 0)
			SOAP_DELETE((struct delegationns__getProxyReq*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegationns__getProxyReq*)p->ptr);
		break;
	case SOAP_TYPE_delegationns__getNewProxyReqResponse:
		if (p->size < 0)
			SOAP_DELETE((struct delegationns__getNewProxyReqResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegationns__getNewProxyReqResponse*)p->ptr);
		break;
	case SOAP_TYPE_delegationns__getNewProxyReq:
		if (p->size < 0)
			SOAP_DELETE((struct delegationns__getNewProxyReq*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegationns__getNewProxyReq*)p->ptr);
		break;
	case SOAP_TYPE_delegationns__renewProxyReqResponse:
		if (p->size < 0)
			SOAP_DELETE((struct delegationns__renewProxyReqResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegationns__renewProxyReqResponse*)p->ptr);
		break;
	case SOAP_TYPE_delegationns__renewProxyReq:
		if (p->size < 0)
			SOAP_DELETE((struct delegationns__renewProxyReq*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegationns__renewProxyReq*)p->ptr);
		break;
	case SOAP_TYPE_delegationns__putProxyResponse:
		if (p->size < 0)
			SOAP_DELETE((struct delegationns__putProxyResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegationns__putProxyResponse*)p->ptr);
		break;
	case SOAP_TYPE_delegationns__putProxy:
		if (p->size < 0)
			SOAP_DELETE((struct delegationns__putProxy*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegationns__putProxy*)p->ptr);
		break;
	case SOAP_TYPE_delegationns__getTerminationTimeResponse:
		if (p->size < 0)
			SOAP_DELETE((struct delegationns__getTerminationTimeResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegationns__getTerminationTimeResponse*)p->ptr);
		break;
	case SOAP_TYPE_delegationns__getTerminationTime:
		if (p->size < 0)
			SOAP_DELETE((struct delegationns__getTerminationTime*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegationns__getTerminationTime*)p->ptr);
		break;
	case SOAP_TYPE_delegationns__destroyResponse:
		if (p->size < 0)
			SOAP_DELETE((struct delegationns__destroyResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegationns__destroyResponse*)p->ptr);
		break;
	case SOAP_TYPE_delegationns__destroy:
		if (p->size < 0)
			SOAP_DELETE((struct delegationns__destroy*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct delegationns__destroy*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getProxyReqResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getProxyReqResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getProxyReqResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getProxyReq:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getProxyReq*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getProxyReq*)p->ptr);
		break;
	case SOAP_TYPE_ns1__putProxyResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__putProxyResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__putProxyResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__putProxy:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__putProxy*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__putProxy*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getVersionResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getVersionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getVersionResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getVersion:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getVersion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getVersion*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getJDLResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getJDLResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getJDLResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getJDL:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getJDL*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getJDL*)p->ptr);
		break;
	case SOAP_TYPE_ns1__jobRegisterResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__jobRegisterResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__jobRegisterResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__jobRegister:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__jobRegister*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__jobRegister*)p->ptr);
		break;
	case SOAP_TYPE_ns1__jobRegisterJSDLResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__jobRegisterJSDLResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__jobRegisterJSDLResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__jobRegisterJSDL:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__jobRegisterJSDL*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__jobRegisterJSDL*)p->ptr);
		break;
	case SOAP_TYPE_ns1__jobStartResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__jobStartResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__jobStartResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__jobStart:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__jobStart*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__jobStart*)p->ptr);
		break;
	case SOAP_TYPE_ns1__jobSubmitResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__jobSubmitResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__jobSubmitResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__jobSubmit:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__jobSubmit*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__jobSubmit*)p->ptr);
		break;
	case SOAP_TYPE_ns1__jobSubmitJSDLResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__jobSubmitJSDLResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__jobSubmitJSDLResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__jobSubmitJSDL:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__jobSubmitJSDL*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__jobSubmitJSDL*)p->ptr);
		break;
	case SOAP_TYPE_ns1__jobCancelResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__jobCancelResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__jobCancelResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__jobCancel:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__jobCancel*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__jobCancel*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getMaxInputSandboxSizeResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getMaxInputSandboxSizeResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getMaxInputSandboxSizeResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getMaxInputSandboxSize:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getMaxInputSandboxSize*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getMaxInputSandboxSize*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getSandboxDestURIResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getSandboxDestURIResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getSandboxDestURIResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getSandboxDestURI:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getSandboxDestURI*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getSandboxDestURI*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getSandboxBulkDestURIResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getSandboxBulkDestURIResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getSandboxBulkDestURIResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getSandboxBulkDestURI:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getSandboxBulkDestURI*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getSandboxBulkDestURI*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTotalQuotaResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getTotalQuotaResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getTotalQuotaResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTotalQuota:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getTotalQuota*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getTotalQuota*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getFreeQuotaResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getFreeQuotaResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getFreeQuotaResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getFreeQuota:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getFreeQuota*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getFreeQuota*)p->ptr);
		break;
	case SOAP_TYPE_ns1__jobPurgeResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__jobPurgeResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__jobPurgeResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__jobPurge:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__jobPurge*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__jobPurge*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getOutputFileListResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getOutputFileListResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getOutputFileListResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getOutputFileList:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getOutputFileList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getOutputFileList*)p->ptr);
		break;
	case SOAP_TYPE_ns1__jobListMatchResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__jobListMatchResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__jobListMatchResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__jobListMatch:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__jobListMatch*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__jobListMatch*)p->ptr);
		break;
	case SOAP_TYPE_ns1__jobListMatchJSDLResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__jobListMatchJSDLResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__jobListMatchJSDLResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__jobListMatchJSDL:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__jobListMatchJSDL*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__jobListMatchJSDL*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getJobTemplateResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getJobTemplateResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getJobTemplateResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getJobTemplate:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getJobTemplate*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getJobTemplate*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDAGTemplateResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getDAGTemplateResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getDAGTemplateResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDAGTemplate:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getDAGTemplate*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getDAGTemplate*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getCollectionTemplateResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getCollectionTemplateResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getCollectionTemplateResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getCollectionTemplate:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getCollectionTemplate*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getCollectionTemplate*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getIntParametricJobTemplateResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getIntParametricJobTemplateResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getIntParametricJobTemplateResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getIntParametricJobTemplate:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getIntParametricJobTemplate*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getIntParametricJobTemplate*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getStringParametricJobTemplateResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getStringParametricJobTemplateResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getStringParametricJobTemplateResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getStringParametricJobTemplate:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getStringParametricJobTemplate*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getStringParametricJobTemplate*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getACLItemsResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getACLItemsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getACLItemsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getACLItems:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getACLItems*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getACLItems*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addACLItemsResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addACLItemsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addACLItemsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addACLItems:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addACLItems*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addACLItems*)p->ptr);
		break;
	case SOAP_TYPE_ns1__removeACLItemResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__removeACLItemResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__removeACLItemResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__removeACLItem:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__removeACLItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__removeACLItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDelegatedProxyInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getDelegatedProxyInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getDelegatedProxyInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDelegatedProxyInfo:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getDelegatedProxyInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getDelegatedProxyInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getJobProxyInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getJobProxyInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getJobProxyInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getJobProxyInfo:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getJobProxyInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getJobProxyInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns1__enableFilePerusalResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__enableFilePerusalResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__enableFilePerusalResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__enableFilePerusal:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__enableFilePerusal*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__enableFilePerusal*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getPerusalFilesResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getPerusalFilesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getPerusalFilesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getPerusalFiles:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getPerusalFiles*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getPerusalFiles*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTransferProtocolsResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getTransferProtocolsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getTransferProtocolsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTransferProtocols:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getTransferProtocols*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getTransferProtocols*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getJobStatusResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getJobStatusResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getJobStatusResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getJobStatus:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getJobStatus*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getJobStatus*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
	case SOAP_TYPE_xsd__ID:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__NCName:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__normalizedString:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_jsdl__Description_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<jsdlposix__Environment_USCOREType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<jsdlposix__Environment_USCOREType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<jsdlposix__Argument_USCOREType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<jsdlposix__Argument_USCOREType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<jsdl__FileSystem_USCOREType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<jsdl__FileSystem_USCOREType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<jsdl__DataStaging_USCOREType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<jsdl__DataStaging_USCOREType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		if (p->size < 0)
			SOAP_DELETE((std::vector<char * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<char * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__Range_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<jsdl__Range_USCOREType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<jsdl__Range_USCOREType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<jsdl__Exact_USCOREType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<jsdl__Exact_USCOREType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__VOProxyInfoStructType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__VOProxyInfoStructType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__VOProxyInfoStructType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__GraphStructType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__GraphStructType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__GraphStructType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__JobIdStructType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__JobIdStructType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__JobIdStructType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__JobStatusStructType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__JobStatusStructType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__JobStatusStructType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__StringAndLongType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__StringAndLongType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__StringAndLongType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DestURIStructType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__DestURIStructType * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__DestURIStructType * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			SOAP_DELETE((std::vector<std::string >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<std::string >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfns1__JobType:
		if (p->size < 0)
			SOAP_DELETE((std::vector<enum ns1__JobType >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<enum ns1__JobType >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<jsdlposix__Environment_USCOREType * >*)p)[len] = *(jsdlposix__Environment_USCOREType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<jsdlposix__Argument_USCOREType * >*)p)[len] = *(jsdlposix__Argument_USCOREType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<jsdl__FileSystem_USCOREType * >*)p)[len] = *(jsdl__FileSystem_USCOREType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<jsdl__DataStaging_USCOREType * >*)p)[len] = *(jsdl__DataStaging_USCOREType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<char * >*)p)[len] = *(char **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__Range_USCOREType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<jsdl__Range_USCOREType * >*)p)[len] = *(jsdl__Range_USCOREType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<jsdl__Exact_USCOREType * >*)p)[len] = *(jsdl__Exact_USCOREType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__VOProxyInfoStructType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__VOProxyInfoStructType * >*)p)[len] = *(ns1__VOProxyInfoStructType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__GraphStructType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__GraphStructType * >*)p)[len] = *(ns1__GraphStructType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__JobIdStructType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__JobIdStructType * >*)p)[len] = *(ns1__JobIdStructType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__JobStatusStructType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__JobStatusStructType * >*)p)[len] = *(ns1__JobStatusStructType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__StringAndLongType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__StringAndLongType * >*)p)[len] = *(ns1__StringAndLongType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__DestURIStructType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__DestURIStructType * >*)p)[len] = *(ns1__DestURIStructType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfns1__JobType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<enum ns1__JobType >*)p)[len] = *(enum ns1__JobType *)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{	double *p;
	p = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__CreationFlagEnumeration(struct soap *soap, enum jsdl__CreationFlagEnumeration *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_jsdl__CreationFlagEnumeration
	*a = SOAP_DEFAULT_jsdl__CreationFlagEnumeration;
#else
	*a = (enum jsdl__CreationFlagEnumeration)0;
#endif
}

static const struct soap_code_map soap_codes_jsdl__CreationFlagEnumeration[] =
{	{ (long)jsdl__CreationFlagEnumeration__overwrite, "overwrite" },
	{ (long)jsdl__CreationFlagEnumeration__append, "append" },
	{ (long)jsdl__CreationFlagEnumeration__dontOverwrite, "dontOverwrite" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_jsdl__CreationFlagEnumeration2s(struct soap *soap, enum jsdl__CreationFlagEnumeration n)
{	const char *s = soap_code_str(soap_codes_jsdl__CreationFlagEnumeration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__CreationFlagEnumeration(struct soap *soap, const char *tag, int id, const enum jsdl__CreationFlagEnumeration *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__CreationFlagEnumeration), type) || soap_send(soap, soap_jsdl__CreationFlagEnumeration2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2jsdl__CreationFlagEnumeration(struct soap *soap, const char *s, enum jsdl__CreationFlagEnumeration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_jsdl__CreationFlagEnumeration, s);
	if (map)
		*a = (enum jsdl__CreationFlagEnumeration)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum jsdl__CreationFlagEnumeration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum jsdl__CreationFlagEnumeration * SOAP_FMAC4 soap_in_jsdl__CreationFlagEnumeration(struct soap *soap, const char *tag, enum jsdl__CreationFlagEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum jsdl__CreationFlagEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__CreationFlagEnumeration, sizeof(enum jsdl__CreationFlagEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2jsdl__CreationFlagEnumeration(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum jsdl__CreationFlagEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__CreationFlagEnumeration, 0, sizeof(enum jsdl__CreationFlagEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__CreationFlagEnumeration(struct soap *soap, const enum jsdl__CreationFlagEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__CreationFlagEnumeration);
	if (soap_out_jsdl__CreationFlagEnumeration(soap, tag?tag:"jsdl:CreationFlagEnumeration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum jsdl__CreationFlagEnumeration * SOAP_FMAC4 soap_get_jsdl__CreationFlagEnumeration(struct soap *soap, enum jsdl__CreationFlagEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__CreationFlagEnumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__FileSystemTypeEnumeration(struct soap *soap, enum jsdl__FileSystemTypeEnumeration *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_jsdl__FileSystemTypeEnumeration
	*a = SOAP_DEFAULT_jsdl__FileSystemTypeEnumeration;
#else
	*a = (enum jsdl__FileSystemTypeEnumeration)0;
#endif
}

static const struct soap_code_map soap_codes_jsdl__FileSystemTypeEnumeration[] =
{	{ (long)jsdl__FileSystemTypeEnumeration__swap, "swap" },
	{ (long)jsdl__FileSystemTypeEnumeration__temporary, "temporary" },
	{ (long)jsdl__FileSystemTypeEnumeration__spool, "spool" },
	{ (long)jsdl__FileSystemTypeEnumeration__normal, "normal" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_jsdl__FileSystemTypeEnumeration2s(struct soap *soap, enum jsdl__FileSystemTypeEnumeration n)
{	const char *s = soap_code_str(soap_codes_jsdl__FileSystemTypeEnumeration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__FileSystemTypeEnumeration(struct soap *soap, const char *tag, int id, const enum jsdl__FileSystemTypeEnumeration *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__FileSystemTypeEnumeration), type) || soap_send(soap, soap_jsdl__FileSystemTypeEnumeration2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2jsdl__FileSystemTypeEnumeration(struct soap *soap, const char *s, enum jsdl__FileSystemTypeEnumeration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_jsdl__FileSystemTypeEnumeration, s);
	if (map)
		*a = (enum jsdl__FileSystemTypeEnumeration)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum jsdl__FileSystemTypeEnumeration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum jsdl__FileSystemTypeEnumeration * SOAP_FMAC4 soap_in_jsdl__FileSystemTypeEnumeration(struct soap *soap, const char *tag, enum jsdl__FileSystemTypeEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum jsdl__FileSystemTypeEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__FileSystemTypeEnumeration, sizeof(enum jsdl__FileSystemTypeEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2jsdl__FileSystemTypeEnumeration(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum jsdl__FileSystemTypeEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__FileSystemTypeEnumeration, 0, sizeof(enum jsdl__FileSystemTypeEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__FileSystemTypeEnumeration(struct soap *soap, const enum jsdl__FileSystemTypeEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__FileSystemTypeEnumeration);
	if (soap_out_jsdl__FileSystemTypeEnumeration(soap, tag?tag:"jsdl:FileSystemTypeEnumeration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum jsdl__FileSystemTypeEnumeration * SOAP_FMAC4 soap_get_jsdl__FileSystemTypeEnumeration(struct soap *soap, enum jsdl__FileSystemTypeEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__FileSystemTypeEnumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__OperatingSystemTypeEnumeration(struct soap *soap, enum jsdl__OperatingSystemTypeEnumeration *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_jsdl__OperatingSystemTypeEnumeration
	*a = SOAP_DEFAULT_jsdl__OperatingSystemTypeEnumeration;
#else
	*a = (enum jsdl__OperatingSystemTypeEnumeration)0;
#endif
}

static const struct soap_code_map soap_codes_jsdl__OperatingSystemTypeEnumeration[] =
{	{ (long)jsdl__OperatingSystemTypeEnumeration__Unknown, "Unknown" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__MACOS, "MACOS" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__ATTUNIX, "ATTUNIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__DGUX, "DGUX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__DECNT, "DECNT" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Tru64_USCOREUNIX, "Tru64_UNIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__OpenVMS, "OpenVMS" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__HPUX, "HPUX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__AIX, "AIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__MVS, "MVS" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__OS400, "OS400" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__OS_USCORE2, "OS_2" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__JavaVM, "JavaVM" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__MSDOS, "MSDOS" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__WIN3x, "WIN3x" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__WIN95, "WIN95" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__WIN98, "WIN98" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__WINNT, "WINNT" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__WINCE, "WINCE" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__NCR3000, "NCR3000" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__NetWare, "NetWare" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__OSF, "OSF" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__DC_USCOREOS, "DC_OS" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Reliant_USCOREUNIX, "Reliant_UNIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__SCO_USCOREUnixWare, "SCO_UnixWare" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__SCO_USCOREOpenServer, "SCO_OpenServer" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Sequent, "Sequent" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__IRIX, "IRIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Solaris, "Solaris" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__SunOS, "SunOS" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__U6000, "U6000" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__ASERIES, "ASERIES" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__TandemNSK, "TandemNSK" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__TandemNT, "TandemNT" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__BS2000, "BS2000" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__LINUX, "LINUX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Lynx, "Lynx" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__XENIX, "XENIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__VM, "VM" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Interactive_USCOREUNIX, "Interactive_UNIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__BSDUNIX, "BSDUNIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__FreeBSD, "FreeBSD" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__NetBSD, "NetBSD" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__GNU_USCOREHurd, "GNU_Hurd" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__OS9, "OS9" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__MACH_USCOREKernel, "MACH_Kernel" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Inferno, "Inferno" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__QNX, "QNX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__EPOC, "EPOC" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__IxWorks, "IxWorks" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__VxWorks, "VxWorks" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__MiNT, "MiNT" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__BeOS, "BeOS" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__HP_USCOREMPE, "HP_MPE" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__NextStep, "NextStep" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__PalmPilot, "PalmPilot" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Rhapsody, "Rhapsody" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Windows_USCORE2000, "Windows_2000" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Dedicated, "Dedicated" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__OS_USCORE390, "OS_390" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__VSE, "VSE" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__TPF, "TPF" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Windows_USCORER_USCOREMe, "Windows_R_Me" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Caldera_USCOREOpen_USCOREUNIX, "Caldera_Open_UNIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__OpenBSD, "OpenBSD" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Not_USCOREApplicable, "Not_Applicable" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Windows_USCOREXP, "Windows_XP" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__z_USCOREOS, "z_OS" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__other, "other" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_jsdl__OperatingSystemTypeEnumeration2s(struct soap *soap, enum jsdl__OperatingSystemTypeEnumeration n)
{	const char *s = soap_code_str(soap_codes_jsdl__OperatingSystemTypeEnumeration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__OperatingSystemTypeEnumeration(struct soap *soap, const char *tag, int id, const enum jsdl__OperatingSystemTypeEnumeration *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__OperatingSystemTypeEnumeration), type) || soap_send(soap, soap_jsdl__OperatingSystemTypeEnumeration2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2jsdl__OperatingSystemTypeEnumeration(struct soap *soap, const char *s, enum jsdl__OperatingSystemTypeEnumeration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_jsdl__OperatingSystemTypeEnumeration, s);
	if (map)
		*a = (enum jsdl__OperatingSystemTypeEnumeration)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 68)))
			return soap->error = SOAP_TYPE;
		*a = (enum jsdl__OperatingSystemTypeEnumeration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum jsdl__OperatingSystemTypeEnumeration * SOAP_FMAC4 soap_in_jsdl__OperatingSystemTypeEnumeration(struct soap *soap, const char *tag, enum jsdl__OperatingSystemTypeEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum jsdl__OperatingSystemTypeEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__OperatingSystemTypeEnumeration, sizeof(enum jsdl__OperatingSystemTypeEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2jsdl__OperatingSystemTypeEnumeration(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum jsdl__OperatingSystemTypeEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__OperatingSystemTypeEnumeration, 0, sizeof(enum jsdl__OperatingSystemTypeEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__OperatingSystemTypeEnumeration(struct soap *soap, const enum jsdl__OperatingSystemTypeEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__OperatingSystemTypeEnumeration);
	if (soap_out_jsdl__OperatingSystemTypeEnumeration(soap, tag?tag:"jsdl:OperatingSystemTypeEnumeration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum jsdl__OperatingSystemTypeEnumeration * SOAP_FMAC4 soap_get_jsdl__OperatingSystemTypeEnumeration(struct soap *soap, enum jsdl__OperatingSystemTypeEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__OperatingSystemTypeEnumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__ProcessorArchitectureEnumeration(struct soap *soap, enum jsdl__ProcessorArchitectureEnumeration *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_jsdl__ProcessorArchitectureEnumeration
	*a = SOAP_DEFAULT_jsdl__ProcessorArchitectureEnumeration;
#else
	*a = (enum jsdl__ProcessorArchitectureEnumeration)0;
#endif
}

static const struct soap_code_map soap_codes_jsdl__ProcessorArchitectureEnumeration[] =
{	{ (long)jsdl__ProcessorArchitectureEnumeration__sparc, "sparc" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__powerpc, "powerpc" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__x86, "x86" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__x86_USCORE32, "x86_32" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__x86_USCORE64, "x86_64" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__parisc, "parisc" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__mips, "mips" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__ia64, "ia64" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__arm, "arm" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__other, "other" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_jsdl__ProcessorArchitectureEnumeration2s(struct soap *soap, enum jsdl__ProcessorArchitectureEnumeration n)
{	const char *s = soap_code_str(soap_codes_jsdl__ProcessorArchitectureEnumeration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__ProcessorArchitectureEnumeration(struct soap *soap, const char *tag, int id, const enum jsdl__ProcessorArchitectureEnumeration *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__ProcessorArchitectureEnumeration), type) || soap_send(soap, soap_jsdl__ProcessorArchitectureEnumeration2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2jsdl__ProcessorArchitectureEnumeration(struct soap *soap, const char *s, enum jsdl__ProcessorArchitectureEnumeration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_jsdl__ProcessorArchitectureEnumeration, s);
	if (map)
		*a = (enum jsdl__ProcessorArchitectureEnumeration)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 9)))
			return soap->error = SOAP_TYPE;
		*a = (enum jsdl__ProcessorArchitectureEnumeration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum jsdl__ProcessorArchitectureEnumeration * SOAP_FMAC4 soap_in_jsdl__ProcessorArchitectureEnumeration(struct soap *soap, const char *tag, enum jsdl__ProcessorArchitectureEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum jsdl__ProcessorArchitectureEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__ProcessorArchitectureEnumeration, sizeof(enum jsdl__ProcessorArchitectureEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2jsdl__ProcessorArchitectureEnumeration(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum jsdl__ProcessorArchitectureEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__ProcessorArchitectureEnumeration, 0, sizeof(enum jsdl__ProcessorArchitectureEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__ProcessorArchitectureEnumeration(struct soap *soap, const enum jsdl__ProcessorArchitectureEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__ProcessorArchitectureEnumeration);
	if (soap_out_jsdl__ProcessorArchitectureEnumeration(soap, tag?tag:"jsdl:ProcessorArchitectureEnumeration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum jsdl__ProcessorArchitectureEnumeration * SOAP_FMAC4 soap_get_jsdl__ProcessorArchitectureEnumeration(struct soap *soap, enum jsdl__ProcessorArchitectureEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__ProcessorArchitectureEnumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__JdlType(struct soap *soap, enum ns1__JdlType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__JdlType
	*a = SOAP_DEFAULT_ns1__JdlType;
#else
	*a = (enum ns1__JdlType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__JdlType[] =
{	{ (long)ns1__JdlType__ORIGINAL, "ORIGINAL" },
	{ (long)ns1__JdlType__REGISTERED, "REGISTERED" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__JdlType2s(struct soap *soap, enum ns1__JdlType n)
{	const char *s = soap_code_str(soap_codes_ns1__JdlType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__JdlType(struct soap *soap, const char *tag, int id, const enum ns1__JdlType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__JdlType), type) || soap_send(soap, soap_ns1__JdlType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__JdlType(struct soap *soap, const char *s, enum ns1__JdlType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__JdlType, s);
	if (map)
		*a = (enum ns1__JdlType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__JdlType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__JdlType * SOAP_FMAC4 soap_in_ns1__JdlType(struct soap *soap, const char *tag, enum ns1__JdlType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__JdlType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__JdlType, sizeof(enum ns1__JdlType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__JdlType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__JdlType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__JdlType, 0, sizeof(enum ns1__JdlType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__JdlType(struct soap *soap, const enum ns1__JdlType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__JdlType);
	if (soap_out_ns1__JdlType(soap, tag?tag:"ns1:JdlType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__JdlType * SOAP_FMAC4 soap_get_ns1__JdlType(struct soap *soap, enum ns1__JdlType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__JdlType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__JobType(struct soap *soap, enum ns1__JobType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__JobType
	*a = SOAP_DEFAULT_ns1__JobType;
#else
	*a = (enum ns1__JobType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__JobType[] =
{	{ (long)ns1__JobType__NORMAL, "NORMAL" },
	{ (long)ns1__JobType__PARAMETRIC, "PARAMETRIC" },
	{ (long)ns1__JobType__INTERACTIVE, "INTERACTIVE" },
	{ (long)ns1__JobType__MPI, "MPI" },
	{ (long)ns1__JobType__PARTITIONABLE, "PARTITIONABLE" },
	{ (long)ns1__JobType__CHECKPOINTABLE, "CHECKPOINTABLE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__JobType2s(struct soap *soap, enum ns1__JobType n)
{	const char *s = soap_code_str(soap_codes_ns1__JobType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__JobType(struct soap *soap, const char *tag, int id, const enum ns1__JobType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__JobType), type) || soap_send(soap, soap_ns1__JobType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__JobType(struct soap *soap, const char *s, enum ns1__JobType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__JobType, s);
	if (map)
		*a = (enum ns1__JobType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__JobType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__JobType * SOAP_FMAC4 soap_in_ns1__JobType(struct soap *soap, const char *tag, enum ns1__JobType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__JobType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__JobType, sizeof(enum ns1__JobType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__JobType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__JobType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__JobType, 0, sizeof(enum ns1__JobType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__JobType(struct soap *soap, const enum ns1__JobType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__JobType);
	if (soap_out_ns1__JobType(soap, tag?tag:"ns1:JobType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__JobType * SOAP_FMAC4 soap_get_ns1__JobType(struct soap *soap, enum ns1__JobType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__JobType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ObjectType(struct soap *soap, enum ns1__ObjectType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__ObjectType
	*a = SOAP_DEFAULT_ns1__ObjectType;
#else
	*a = (enum ns1__ObjectType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__ObjectType[] =
{	{ (long)ns1__ObjectType__JOB, "JOB" },
	{ (long)ns1__ObjectType__DAG, "DAG" },
	{ (long)ns1__ObjectType__COLLECTION, "COLLECTION" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__ObjectType2s(struct soap *soap, enum ns1__ObjectType n)
{	const char *s = soap_code_str(soap_codes_ns1__ObjectType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ObjectType(struct soap *soap, const char *tag, int id, const enum ns1__ObjectType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ObjectType), type) || soap_send(soap, soap_ns1__ObjectType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__ObjectType(struct soap *soap, const char *s, enum ns1__ObjectType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__ObjectType, s);
	if (map)
		*a = (enum ns1__ObjectType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__ObjectType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__ObjectType * SOAP_FMAC4 soap_in_ns1__ObjectType(struct soap *soap, const char *tag, enum ns1__ObjectType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__ObjectType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ObjectType, sizeof(enum ns1__ObjectType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__ObjectType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__ObjectType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ObjectType, 0, sizeof(enum ns1__ObjectType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ObjectType(struct soap *soap, const enum ns1__ObjectType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ObjectType);
	if (soap_out_ns1__ObjectType(soap, tag?tag:"ns1:ObjectType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__ObjectType * SOAP_FMAC4 soap_get_ns1__ObjectType(struct soap *soap, enum ns1__ObjectType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ObjectType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__Description_USCOREType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_jsdl__Description_USCOREType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_jsdl__Description_USCOREType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_jsdl__Description_USCOREType, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_jsdl__Description_USCOREType, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_jsdl__Description_USCOREType, 0, sizeof(std::string), 0, soap_copy_jsdl__Description_USCOREType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__Description_USCOREType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__Description_USCOREType);
	if (soap_out_jsdl__Description_USCOREType(soap, tag?tag:"jsdl:Description_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_jsdl__Description_USCOREType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Description_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void delegation1__DelegationExceptionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->delegation1__DelegationExceptionType::message = NULL;
	/* transient soap skipped */
}

void delegation1__DelegationExceptionType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->delegation1__DelegationExceptionType::message);
	/* transient soap skipped */
}

int delegation1__DelegationExceptionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_delegation1__DelegationExceptionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation1__DelegationExceptionType(struct soap *soap, const char *tag, int id, const delegation1__DelegationExceptionType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegation1__DelegationExceptionType), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "message", -1, &(a->delegation1__DelegationExceptionType::message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *delegation1__DelegationExceptionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_delegation1__DelegationExceptionType(soap, tag, this, type);
}

SOAP_FMAC3 delegation1__DelegationExceptionType * SOAP_FMAC4 soap_in_delegation1__DelegationExceptionType(struct soap *soap, const char *tag, delegation1__DelegationExceptionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (delegation1__DelegationExceptionType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_delegation1__DelegationExceptionType, sizeof(delegation1__DelegationExceptionType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_delegation1__DelegationExceptionType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (delegation1__DelegationExceptionType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "message", &(a->delegation1__DelegationExceptionType::message), "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (delegation1__DelegationExceptionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegation1__DelegationExceptionType, 0, sizeof(delegation1__DelegationExceptionType), 0, soap_copy_delegation1__DelegationExceptionType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int delegation1__DelegationExceptionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_delegation1__DelegationExceptionType);
	if (this->soap_out(soap, tag?tag:"delegation1:DelegationExceptionType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *delegation1__DelegationExceptionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_delegation1__DelegationExceptionType(soap, this, tag, type);
}

SOAP_FMAC3 delegation1__DelegationExceptionType * SOAP_FMAC4 soap_get_delegation1__DelegationExceptionType(struct soap *soap, delegation1__DelegationExceptionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation1__DelegationExceptionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 delegation1__DelegationExceptionType * SOAP_FMAC2 soap_instantiate_delegation1__DelegationExceptionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation1__DelegationExceptionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegation1__DelegationExceptionType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(delegation1__DelegationExceptionType);
		if (size)
			*size = sizeof(delegation1__DelegationExceptionType);
		((delegation1__DelegationExceptionType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(delegation1__DelegationExceptionType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(delegation1__DelegationExceptionType);
		for (int i = 0; i < n; i++)
			((delegation1__DelegationExceptionType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (delegation1__DelegationExceptionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation1__DelegationExceptionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying delegation1__DelegationExceptionType %p -> %p\n", q, p));
	*(delegation1__DelegationExceptionType*)p = *(delegation1__DelegationExceptionType*)q;
}

void _delegationns__DelegationException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_delegationns__DelegationException::msg = NULL;
	/* transient soap skipped */
}

void _delegationns__DelegationException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->_delegationns__DelegationException::msg);
	/* transient soap skipped */
}

int _delegationns__DelegationException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__delegationns__DelegationException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__delegationns__DelegationException(struct soap *soap, const char *tag, int id, const _delegationns__DelegationException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__delegationns__DelegationException), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "msg", -1, &(a->_delegationns__DelegationException::msg), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_delegationns__DelegationException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__delegationns__DelegationException(soap, tag, this, type);
}

SOAP_FMAC3 _delegationns__DelegationException * SOAP_FMAC4 soap_in__delegationns__DelegationException(struct soap *soap, const char *tag, _delegationns__DelegationException *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_delegationns__DelegationException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__delegationns__DelegationException, sizeof(_delegationns__DelegationException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__delegationns__DelegationException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_delegationns__DelegationException *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_msg1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_msg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "msg", &(a->_delegationns__DelegationException::msg), "xsd:string"))
				{	soap_flag_msg1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_delegationns__DelegationException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__delegationns__DelegationException, 0, sizeof(_delegationns__DelegationException), 0, soap_copy__delegationns__DelegationException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _delegationns__DelegationException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__delegationns__DelegationException);
	if (this->soap_out(soap, tag?tag:"delegationns:DelegationException", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_delegationns__DelegationException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__delegationns__DelegationException(soap, this, tag, type);
}

SOAP_FMAC3 _delegationns__DelegationException * SOAP_FMAC4 soap_get__delegationns__DelegationException(struct soap *soap, _delegationns__DelegationException *p, const char *tag, const char *type)
{
	if ((p = soap_in__delegationns__DelegationException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _delegationns__DelegationException * SOAP_FMAC2 soap_instantiate__delegationns__DelegationException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__delegationns__DelegationException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__delegationns__DelegationException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_delegationns__DelegationException);
		if (size)
			*size = sizeof(_delegationns__DelegationException);
		((_delegationns__DelegationException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_delegationns__DelegationException[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_delegationns__DelegationException);
		for (int i = 0; i < n; i++)
			((_delegationns__DelegationException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_delegationns__DelegationException*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__delegationns__DelegationException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _delegationns__DelegationException %p -> %p\n", q, p));
	*(_delegationns__DelegationException*)p = *(_delegationns__DelegationException*)q;
}

void delegationns__NewProxyReq::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->delegationns__NewProxyReq::proxyRequest = NULL;
	this->delegationns__NewProxyReq::delegationID = NULL;
	/* transient soap skipped */
}

void delegationns__NewProxyReq::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->delegationns__NewProxyReq::proxyRequest);
	soap_serialize_PointerTostd__string(soap, &this->delegationns__NewProxyReq::delegationID);
	/* transient soap skipped */
}

int delegationns__NewProxyReq::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_delegationns__NewProxyReq(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegationns__NewProxyReq(struct soap *soap, const char *tag, int id, const delegationns__NewProxyReq *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegationns__NewProxyReq), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "proxyRequest", -1, &(a->delegationns__NewProxyReq::proxyRequest), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "delegationID", -1, &(a->delegationns__NewProxyReq::delegationID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *delegationns__NewProxyReq::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_delegationns__NewProxyReq(soap, tag, this, type);
}

SOAP_FMAC3 delegationns__NewProxyReq * SOAP_FMAC4 soap_in_delegationns__NewProxyReq(struct soap *soap, const char *tag, delegationns__NewProxyReq *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (delegationns__NewProxyReq *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_delegationns__NewProxyReq, sizeof(delegationns__NewProxyReq), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_delegationns__NewProxyReq)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (delegationns__NewProxyReq *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_proxyRequest1 = 1;
	size_t soap_flag_delegationID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_proxyRequest1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "proxyRequest", &(a->delegationns__NewProxyReq::proxyRequest), "xsd:string"))
				{	soap_flag_proxyRequest1--;
					continue;
				}
			if (soap_flag_delegationID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "delegationID", &(a->delegationns__NewProxyReq::delegationID), "xsd:string"))
				{	soap_flag_delegationID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (delegationns__NewProxyReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegationns__NewProxyReq, 0, sizeof(delegationns__NewProxyReq), 0, soap_copy_delegationns__NewProxyReq);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int delegationns__NewProxyReq::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_delegationns__NewProxyReq);
	if (this->soap_out(soap, tag?tag:"delegationns:NewProxyReq", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *delegationns__NewProxyReq::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_delegationns__NewProxyReq(soap, this, tag, type);
}

SOAP_FMAC3 delegationns__NewProxyReq * SOAP_FMAC4 soap_get_delegationns__NewProxyReq(struct soap *soap, delegationns__NewProxyReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegationns__NewProxyReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 delegationns__NewProxyReq * SOAP_FMAC2 soap_instantiate_delegationns__NewProxyReq(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegationns__NewProxyReq(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegationns__NewProxyReq, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(delegationns__NewProxyReq);
		if (size)
			*size = sizeof(delegationns__NewProxyReq);
		((delegationns__NewProxyReq*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(delegationns__NewProxyReq[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(delegationns__NewProxyReq);
		for (int i = 0; i < n; i++)
			((delegationns__NewProxyReq*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (delegationns__NewProxyReq*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegationns__NewProxyReq(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying delegationns__NewProxyReq %p -> %p\n", q, p));
	*(delegationns__NewProxyReq*)p = *(delegationns__NewProxyReq*)q;
}

void jsdlposix__POSIXApplication_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdlposix__POSIXApplication_USCOREType::Executable = NULL;
	soap_default_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::Argument);
	this->jsdlposix__POSIXApplication_USCOREType::Input = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::Output = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::Error = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::WorkingDirectory = NULL;
	soap_default_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::Environment);
	this->jsdlposix__POSIXApplication_USCOREType::WallTimeLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::FileSizeLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::CoreDumpLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::DataSegmentLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::LockedMemoryLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::MemoryLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::OpenDescriptorsLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::PipeSizeLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::StackSizeLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::CPUTimeLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::ProcessCountLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::VirtualMemoryLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::ThreadCountLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::UserName = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::GroupName = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::name = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdlposix__POSIXApplication_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdlposix__FileName_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::Executable);
	soap_serialize_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::Argument);
	soap_serialize_PointerTojsdlposix__FileName_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::Input);
	soap_serialize_PointerTojsdlposix__FileName_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::Output);
	soap_serialize_PointerTojsdlposix__FileName_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::Error);
	soap_serialize_PointerTojsdlposix__DirectoryName_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::WorkingDirectory);
	soap_serialize_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::Environment);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::WallTimeLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::FileSizeLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::CoreDumpLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::DataSegmentLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::LockedMemoryLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::MemoryLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::OpenDescriptorsLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::PipeSizeLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::StackSizeLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::CPUTimeLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::ProcessCountLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::VirtualMemoryLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::ThreadCountLimit);
	soap_serialize_PointerTojsdlposix__UserName_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::UserName);
	soap_serialize_PointerTojsdlposix__GroupName_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::GroupName);
	/* transient soap skipped */
}

int jsdlposix__POSIXApplication_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdlposix__POSIXApplication_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdlposix__POSIXApplication_USCOREType(struct soap *soap, const char *tag, int id, const jsdlposix__POSIXApplication_USCOREType *a, const char *type)
{
	if (((jsdlposix__POSIXApplication_USCOREType*)a)->name)
		soap_set_attr(soap, "name", ((jsdlposix__POSIXApplication_USCOREType*)a)->name->c_str());
	if (((jsdlposix__POSIXApplication_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdlposix__POSIXApplication_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdlposix__POSIXApplication_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTojsdlposix__FileName_USCOREType(soap, "Executable", -1, &(a->jsdlposix__POSIXApplication_USCOREType::Executable), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType(soap, "Argument", -1, &(a->jsdlposix__POSIXApplication_USCOREType::Argument), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__FileName_USCOREType(soap, "Input", -1, &(a->jsdlposix__POSIXApplication_USCOREType::Input), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__FileName_USCOREType(soap, "Output", -1, &(a->jsdlposix__POSIXApplication_USCOREType::Output), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__FileName_USCOREType(soap, "Error", -1, &(a->jsdlposix__POSIXApplication_USCOREType::Error), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__DirectoryName_USCOREType(soap, "WorkingDirectory", -1, &(a->jsdlposix__POSIXApplication_USCOREType::WorkingDirectory), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType(soap, "Environment", -1, &(a->jsdlposix__POSIXApplication_USCOREType::Environment), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "WallTimeLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::WallTimeLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "FileSizeLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::FileSizeLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "CoreDumpLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::CoreDumpLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "DataSegmentLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::DataSegmentLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "LockedMemoryLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::LockedMemoryLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "MemoryLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::MemoryLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "OpenDescriptorsLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::OpenDescriptorsLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "PipeSizeLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::PipeSizeLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "StackSizeLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::StackSizeLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "CPUTimeLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::CPUTimeLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "ProcessCountLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::ProcessCountLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "VirtualMemoryLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::VirtualMemoryLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "ThreadCountLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::ThreadCountLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__UserName_USCOREType(soap, "UserName", -1, &(a->jsdlposix__POSIXApplication_USCOREType::UserName), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__GroupName_USCOREType(soap, "GroupName", -1, &(a->jsdlposix__POSIXApplication_USCOREType::GroupName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdlposix__POSIXApplication_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdlposix__POSIXApplication_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdlposix__POSIXApplication_USCOREType * SOAP_FMAC4 soap_in_jsdlposix__POSIXApplication_USCOREType(struct soap *soap, const char *tag, jsdlposix__POSIXApplication_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdlposix__POSIXApplication_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdlposix__POSIXApplication_USCOREType, sizeof(jsdlposix__POSIXApplication_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdlposix__POSIXApplication_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdlposix__POSIXApplication_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((jsdlposix__POSIXApplication_USCOREType*)a)->name = soap_new_std__string(soap, -1);
				((jsdlposix__POSIXApplication_USCOREType*)a)->name->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdlposix__POSIXApplication_USCOREType*)a)->__anyAttribute, -1, -1))
		return NULL;
	size_t soap_flag_Executable1 = 1;
	size_t soap_flag_Input1 = 1;
	size_t soap_flag_Output1 = 1;
	size_t soap_flag_Error1 = 1;
	size_t soap_flag_WorkingDirectory1 = 1;
	size_t soap_flag_WallTimeLimit1 = 1;
	size_t soap_flag_FileSizeLimit1 = 1;
	size_t soap_flag_CoreDumpLimit1 = 1;
	size_t soap_flag_DataSegmentLimit1 = 1;
	size_t soap_flag_LockedMemoryLimit1 = 1;
	size_t soap_flag_MemoryLimit1 = 1;
	size_t soap_flag_OpenDescriptorsLimit1 = 1;
	size_t soap_flag_PipeSizeLimit1 = 1;
	size_t soap_flag_StackSizeLimit1 = 1;
	size_t soap_flag_CPUTimeLimit1 = 1;
	size_t soap_flag_ProcessCountLimit1 = 1;
	size_t soap_flag_VirtualMemoryLimit1 = 1;
	size_t soap_flag_ThreadCountLimit1 = 1;
	size_t soap_flag_UserName1 = 1;
	size_t soap_flag_GroupName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Executable1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__FileName_USCOREType(soap, "Executable", &(a->jsdlposix__POSIXApplication_USCOREType::Executable), "jsdlposix:FileName_Type"))
				{	soap_flag_Executable1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType(soap, "Argument", &(a->jsdlposix__POSIXApplication_USCOREType::Argument), "jsdlposix:Argument_Type"))
					continue;
			if (soap_flag_Input1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__FileName_USCOREType(soap, "Input", &(a->jsdlposix__POSIXApplication_USCOREType::Input), "jsdlposix:FileName_Type"))
				{	soap_flag_Input1--;
					continue;
				}
			if (soap_flag_Output1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__FileName_USCOREType(soap, "Output", &(a->jsdlposix__POSIXApplication_USCOREType::Output), "jsdlposix:FileName_Type"))
				{	soap_flag_Output1--;
					continue;
				}
			if (soap_flag_Error1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__FileName_USCOREType(soap, "Error", &(a->jsdlposix__POSIXApplication_USCOREType::Error), "jsdlposix:FileName_Type"))
				{	soap_flag_Error1--;
					continue;
				}
			if (soap_flag_WorkingDirectory1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__DirectoryName_USCOREType(soap, "WorkingDirectory", &(a->jsdlposix__POSIXApplication_USCOREType::WorkingDirectory), "jsdlposix:DirectoryName_Type"))
				{	soap_flag_WorkingDirectory1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType(soap, "Environment", &(a->jsdlposix__POSIXApplication_USCOREType::Environment), "jsdlposix:Environment_Type"))
					continue;
			if (soap_flag_WallTimeLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "WallTimeLimit", &(a->jsdlposix__POSIXApplication_USCOREType::WallTimeLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_WallTimeLimit1--;
					continue;
				}
			if (soap_flag_FileSizeLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "FileSizeLimit", &(a->jsdlposix__POSIXApplication_USCOREType::FileSizeLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_FileSizeLimit1--;
					continue;
				}
			if (soap_flag_CoreDumpLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "CoreDumpLimit", &(a->jsdlposix__POSIXApplication_USCOREType::CoreDumpLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_CoreDumpLimit1--;
					continue;
				}
			if (soap_flag_DataSegmentLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "DataSegmentLimit", &(a->jsdlposix__POSIXApplication_USCOREType::DataSegmentLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_DataSegmentLimit1--;
					continue;
				}
			if (soap_flag_LockedMemoryLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "LockedMemoryLimit", &(a->jsdlposix__POSIXApplication_USCOREType::LockedMemoryLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_LockedMemoryLimit1--;
					continue;
				}
			if (soap_flag_MemoryLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "MemoryLimit", &(a->jsdlposix__POSIXApplication_USCOREType::MemoryLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_MemoryLimit1--;
					continue;
				}
			if (soap_flag_OpenDescriptorsLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "OpenDescriptorsLimit", &(a->jsdlposix__POSIXApplication_USCOREType::OpenDescriptorsLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_OpenDescriptorsLimit1--;
					continue;
				}
			if (soap_flag_PipeSizeLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "PipeSizeLimit", &(a->jsdlposix__POSIXApplication_USCOREType::PipeSizeLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_PipeSizeLimit1--;
					continue;
				}
			if (soap_flag_StackSizeLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "StackSizeLimit", &(a->jsdlposix__POSIXApplication_USCOREType::StackSizeLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_StackSizeLimit1--;
					continue;
				}
			if (soap_flag_CPUTimeLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "CPUTimeLimit", &(a->jsdlposix__POSIXApplication_USCOREType::CPUTimeLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_CPUTimeLimit1--;
					continue;
				}
			if (soap_flag_ProcessCountLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "ProcessCountLimit", &(a->jsdlposix__POSIXApplication_USCOREType::ProcessCountLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_ProcessCountLimit1--;
					continue;
				}
			if (soap_flag_VirtualMemoryLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "VirtualMemoryLimit", &(a->jsdlposix__POSIXApplication_USCOREType::VirtualMemoryLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_VirtualMemoryLimit1--;
					continue;
				}
			if (soap_flag_ThreadCountLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "ThreadCountLimit", &(a->jsdlposix__POSIXApplication_USCOREType::ThreadCountLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_ThreadCountLimit1--;
					continue;
				}
			if (soap_flag_UserName1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__UserName_USCOREType(soap, "UserName", &(a->jsdlposix__POSIXApplication_USCOREType::UserName), "jsdlposix:UserName_Type"))
				{	soap_flag_UserName1--;
					continue;
				}
			if (soap_flag_GroupName1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__GroupName_USCOREType(soap, "GroupName", &(a->jsdlposix__POSIXApplication_USCOREType::GroupName), "jsdlposix:GroupName_Type"))
				{	soap_flag_GroupName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdlposix__POSIXApplication_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdlposix__POSIXApplication_USCOREType, 0, sizeof(jsdlposix__POSIXApplication_USCOREType), 0, soap_copy_jsdlposix__POSIXApplication_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int jsdlposix__POSIXApplication_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdlposix__POSIXApplication_USCOREType);
	if (this->soap_out(soap, tag?tag:"jsdlposix:POSIXApplication_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *jsdlposix__POSIXApplication_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdlposix__POSIXApplication_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdlposix__POSIXApplication_USCOREType * SOAP_FMAC4 soap_get_jsdlposix__POSIXApplication_USCOREType(struct soap *soap, jsdlposix__POSIXApplication_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdlposix__POSIXApplication_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 jsdlposix__POSIXApplication_USCOREType * SOAP_FMAC2 soap_instantiate_jsdlposix__POSIXApplication_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdlposix__POSIXApplication_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdlposix__POSIXApplication_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(jsdlposix__POSIXApplication_USCOREType);
		if (size)
			*size = sizeof(jsdlposix__POSIXApplication_USCOREType);
		((jsdlposix__POSIXApplication_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(jsdlposix__POSIXApplication_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdlposix__POSIXApplication_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdlposix__POSIXApplication_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdlposix__POSIXApplication_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdlposix__POSIXApplication_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdlposix__POSIXApplication_USCOREType %p -> %p\n", q, p));
	*(jsdlposix__POSIXApplication_USCOREType*)p = *(jsdlposix__POSIXApplication_USCOREType*)q;
}

void jsdlposix__GroupName_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->jsdlposix__GroupName_USCOREType::__item);
	this->jsdlposix__GroupName_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdlposix__GroupName_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->jsdlposix__GroupName_USCOREType::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->jsdlposix__GroupName_USCOREType::__item);
	/* transient soap skipped */
}

int jsdlposix__GroupName_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdlposix__GroupName_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdlposix__GroupName_USCOREType(struct soap *soap, const char *tag, int id, const jsdlposix__GroupName_USCOREType *a, const char *type)
{
	if (((jsdlposix__GroupName_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdlposix__GroupName_USCOREType*)a)->__anyAttribute);
	return soap_out_std__string(soap, tag, id, &a->jsdlposix__GroupName_USCOREType::__item, "");
}

void *jsdlposix__GroupName_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdlposix__GroupName_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdlposix__GroupName_USCOREType * SOAP_FMAC4 soap_in_jsdlposix__GroupName_USCOREType(struct soap *soap, const char *tag, jsdlposix__GroupName_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (jsdlposix__GroupName_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdlposix__GroupName_USCOREType, sizeof(jsdlposix__GroupName_USCOREType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdlposix__GroupName_USCOREType)
			return (jsdlposix__GroupName_USCOREType *)a->soap_in(soap, tag, type);
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdlposix__GroupName_USCOREType*)a)->__anyAttribute, -1, -1))
		return NULL;
	if (!soap_in_std__string(soap, tag, &(a->jsdlposix__GroupName_USCOREType::__item), "jsdlposix:GroupName_Type"))
		return NULL;
	return a;
}

int jsdlposix__GroupName_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdlposix__GroupName_USCOREType);
	if (this->soap_out(soap, tag?tag:"jsdlposix:GroupName_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *jsdlposix__GroupName_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdlposix__GroupName_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdlposix__GroupName_USCOREType * SOAP_FMAC4 soap_get_jsdlposix__GroupName_USCOREType(struct soap *soap, jsdlposix__GroupName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdlposix__GroupName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 jsdlposix__GroupName_USCOREType * SOAP_FMAC2 soap_instantiate_jsdlposix__GroupName_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdlposix__GroupName_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdlposix__GroupName_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(jsdlposix__GroupName_USCOREType);
		if (size)
			*size = sizeof(jsdlposix__GroupName_USCOREType);
		((jsdlposix__GroupName_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(jsdlposix__GroupName_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdlposix__GroupName_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdlposix__GroupName_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdlposix__GroupName_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdlposix__GroupName_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdlposix__GroupName_USCOREType %p -> %p\n", q, p));
	*(jsdlposix__GroupName_USCOREType*)p = *(jsdlposix__GroupName_USCOREType*)q;
}

void jsdlposix__UserName_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->jsdlposix__UserName_USCOREType::__item);
	this->jsdlposix__UserName_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdlposix__UserName_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->jsdlposix__UserName_USCOREType::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->jsdlposix__UserName_USCOREType::__item);
	/* transient soap skipped */
}

int jsdlposix__UserName_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdlposix__UserName_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdlposix__UserName_USCOREType(struct soap *soap, const char *tag, int id, const jsdlposix__UserName_USCOREType *a, const char *type)
{
	if (((jsdlposix__UserName_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdlposix__UserName_USCOREType*)a)->__anyAttribute);
	return soap_out_std__string(soap, tag, id, &a->jsdlposix__UserName_USCOREType::__item, "");
}

void *jsdlposix__UserName_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdlposix__UserName_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdlposix__UserName_USCOREType * SOAP_FMAC4 soap_in_jsdlposix__UserName_USCOREType(struct soap *soap, const char *tag, jsdlposix__UserName_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (jsdlposix__UserName_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdlposix__UserName_USCOREType, sizeof(jsdlposix__UserName_USCOREType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdlposix__UserName_USCOREType)
			return (jsdlposix__UserName_USCOREType *)a->soap_in(soap, tag, type);
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdlposix__UserName_USCOREType*)a)->__anyAttribute, -1, -1))
		return NULL;
	if (!soap_in_std__string(soap, tag, &(a->jsdlposix__UserName_USCOREType::__item), "jsdlposix:UserName_Type"))
		return NULL;
	return a;
}

int jsdlposix__UserName_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdlposix__UserName_USCOREType);
	if (this->soap_out(soap, tag?tag:"jsdlposix:UserName_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *jsdlposix__UserName_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdlposix__UserName_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdlposix__UserName_USCOREType * SOAP_FMAC4 soap_get_jsdlposix__UserName_USCOREType(struct soap *soap, jsdlposix__UserName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdlposix__UserName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 jsdlposix__UserName_USCOREType * SOAP_FMAC2 soap_instantiate_jsdlposix__UserName_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdlposix__UserName_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdlposix__UserName_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(jsdlposix__UserName_USCOREType);
		if (size)
			*size = sizeof(jsdlposix__UserName_USCOREType);
		((jsdlposix__UserName_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(jsdlposix__UserName_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdlposix__UserName_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdlposix__UserName_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdlposix__UserName_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdlposix__UserName_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdlposix__UserName_USCOREType %p -> %p\n", q, p));
	*(jsdlposix__UserName_USCOREType*)p = *(jsdlposix__UserName_USCOREType*)q;
}

void jsdlposix__Limits_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__nonNegativeInteger(soap, &this->jsdlposix__Limits_USCOREType::__item);
	this->jsdlposix__Limits_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdlposix__Limits_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__nonNegativeInteger(soap, &this->jsdlposix__Limits_USCOREType::__item);
	/* transient soap skipped */
}

int jsdlposix__Limits_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdlposix__Limits_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdlposix__Limits_USCOREType(struct soap *soap, const char *tag, int id, const jsdlposix__Limits_USCOREType *a, const char *type)
{
	if (((jsdlposix__Limits_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdlposix__Limits_USCOREType*)a)->__anyAttribute);
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->jsdlposix__Limits_USCOREType::__item, "");
}

void *jsdlposix__Limits_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdlposix__Limits_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdlposix__Limits_USCOREType * SOAP_FMAC4 soap_in_jsdlposix__Limits_USCOREType(struct soap *soap, const char *tag, jsdlposix__Limits_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (jsdlposix__Limits_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdlposix__Limits_USCOREType, sizeof(jsdlposix__Limits_USCOREType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdlposix__Limits_USCOREType)
			return (jsdlposix__Limits_USCOREType *)a->soap_in(soap, tag, type);
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdlposix__Limits_USCOREType*)a)->__anyAttribute, -1, -1))
		return NULL;
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &(a->jsdlposix__Limits_USCOREType::__item), "jsdlposix:Limits_Type"))
		return NULL;
	return a;
}

int jsdlposix__Limits_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdlposix__Limits_USCOREType);
	if (this->soap_out(soap, tag?tag:"jsdlposix:Limits_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *jsdlposix__Limits_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdlposix__Limits_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdlposix__Limits_USCOREType * SOAP_FMAC4 soap_get_jsdlposix__Limits_USCOREType(struct soap *soap, jsdlposix__Limits_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdlposix__Limits_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 jsdlposix__Limits_USCOREType * SOAP_FMAC2 soap_instantiate_jsdlposix__Limits_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdlposix__Limits_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdlposix__Limits_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(jsdlposix__Limits_USCOREType);
		if (size)
			*size = sizeof(jsdlposix__Limits_USCOREType);
		((jsdlposix__Limits_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(jsdlposix__Limits_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdlposix__Limits_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdlposix__Limits_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdlposix__Limits_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdlposix__Limits_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdlposix__Limits_USCOREType %p -> %p\n", q, p));
	*(jsdlposix__Limits_USCOREType*)p = *(jsdlposix__Limits_USCOREType*)q;
}

void jsdlposix__DirectoryName_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->jsdlposix__DirectoryName_USCOREType::__item);
	this->jsdlposix__DirectoryName_USCOREType::filesystemName = NULL;
	this->jsdlposix__DirectoryName_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdlposix__DirectoryName_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->jsdlposix__DirectoryName_USCOREType::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->jsdlposix__DirectoryName_USCOREType::__item);
	/* transient soap skipped */
}

int jsdlposix__DirectoryName_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdlposix__DirectoryName_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdlposix__DirectoryName_USCOREType(struct soap *soap, const char *tag, int id, const jsdlposix__DirectoryName_USCOREType *a, const char *type)
{
	if (((jsdlposix__DirectoryName_USCOREType*)a)->filesystemName)
		soap_set_attr(soap, "filesystemName", ((jsdlposix__DirectoryName_USCOREType*)a)->filesystemName->c_str());
	if (((jsdlposix__DirectoryName_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdlposix__DirectoryName_USCOREType*)a)->__anyAttribute);
	return soap_out_std__string(soap, tag, id, &a->jsdlposix__DirectoryName_USCOREType::__item, "");
}

void *jsdlposix__DirectoryName_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdlposix__DirectoryName_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdlposix__DirectoryName_USCOREType * SOAP_FMAC4 soap_in_jsdlposix__DirectoryName_USCOREType(struct soap *soap, const char *tag, jsdlposix__DirectoryName_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (jsdlposix__DirectoryName_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdlposix__DirectoryName_USCOREType, sizeof(jsdlposix__DirectoryName_USCOREType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdlposix__DirectoryName_USCOREType)
			return (jsdlposix__DirectoryName_USCOREType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "filesystemName", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((jsdlposix__DirectoryName_USCOREType*)a)->filesystemName = soap_new_std__string(soap, -1);
				((jsdlposix__DirectoryName_USCOREType*)a)->filesystemName->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdlposix__DirectoryName_USCOREType*)a)->__anyAttribute, -1, -1))
		return NULL;
	if (!soap_in_std__string(soap, tag, &(a->jsdlposix__DirectoryName_USCOREType::__item), "jsdlposix:DirectoryName_Type"))
		return NULL;
	return a;
}

int jsdlposix__DirectoryName_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdlposix__DirectoryName_USCOREType);
	if (this->soap_out(soap, tag?tag:"jsdlposix:DirectoryName_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *jsdlposix__DirectoryName_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdlposix__DirectoryName_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdlposix__DirectoryName_USCOREType * SOAP_FMAC4 soap_get_jsdlposix__DirectoryName_USCOREType(struct soap *soap, jsdlposix__DirectoryName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdlposix__DirectoryName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 jsdlposix__DirectoryName_USCOREType * SOAP_FMAC2 soap_instantiate_jsdlposix__DirectoryName_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdlposix__DirectoryName_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdlposix__DirectoryName_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(jsdlposix__DirectoryName_USCOREType);
		if (size)
			*size = sizeof(jsdlposix__DirectoryName_USCOREType);
		((jsdlposix__DirectoryName_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(jsdlposix__DirectoryName_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdlposix__DirectoryName_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdlposix__DirectoryName_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdlposix__DirectoryName_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdlposix__DirectoryName_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdlposix__DirectoryName_USCOREType %p -> %p\n", q, p));
	*(jsdlposix__DirectoryName_USCOREType*)p = *(jsdlposix__DirectoryName_USCOREType*)q;
}

void jsdlposix__FileName_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->jsdlposix__FileName_USCOREType::__item);
	this->jsdlposix__FileName_USCOREType::filesystemName = NULL;
	this->jsdlposix__FileName_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdlposix__FileName_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->jsdlposix__FileName_USCOREType::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->jsdlposix__FileName_USCOREType::__item);
	/* transient soap skipped */
}

int jsdlposix__FileName_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdlposix__FileName_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdlposix__FileName_USCOREType(struct soap *soap, const char *tag, int id, const jsdlposix__FileName_USCOREType *a, const char *type)
{
	if (((jsdlposix__FileName_USCOREType*)a)->filesystemName)
		soap_set_attr(soap, "filesystemName", ((jsdlposix__FileName_USCOREType*)a)->filesystemName->c_str());
	if (((jsdlposix__FileName_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdlposix__FileName_USCOREType*)a)->__anyAttribute);
	return soap_out_std__string(soap, tag, id, &a->jsdlposix__FileName_USCOREType::__item, "");
}

void *jsdlposix__FileName_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdlposix__FileName_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdlposix__FileName_USCOREType * SOAP_FMAC4 soap_in_jsdlposix__FileName_USCOREType(struct soap *soap, const char *tag, jsdlposix__FileName_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (jsdlposix__FileName_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdlposix__FileName_USCOREType, sizeof(jsdlposix__FileName_USCOREType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdlposix__FileName_USCOREType)
			return (jsdlposix__FileName_USCOREType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "filesystemName", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((jsdlposix__FileName_USCOREType*)a)->filesystemName = soap_new_std__string(soap, -1);
				((jsdlposix__FileName_USCOREType*)a)->filesystemName->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdlposix__FileName_USCOREType*)a)->__anyAttribute, -1, -1))
		return NULL;
	if (!soap_in_std__string(soap, tag, &(a->jsdlposix__FileName_USCOREType::__item), "jsdlposix:FileName_Type"))
		return NULL;
	return a;
}

int jsdlposix__FileName_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdlposix__FileName_USCOREType);
	if (this->soap_out(soap, tag?tag:"jsdlposix:FileName_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *jsdlposix__FileName_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdlposix__FileName_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdlposix__FileName_USCOREType * SOAP_FMAC4 soap_get_jsdlposix__FileName_USCOREType(struct soap *soap, jsdlposix__FileName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdlposix__FileName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 jsdlposix__FileName_USCOREType * SOAP_FMAC2 soap_instantiate_jsdlposix__FileName_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdlposix__FileName_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdlposix__FileName_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(jsdlposix__FileName_USCOREType);
		if (size)
			*size = sizeof(jsdlposix__FileName_USCOREType);
		((jsdlposix__FileName_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(jsdlposix__FileName_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdlposix__FileName_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdlposix__FileName_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdlposix__FileName_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdlposix__FileName_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdlposix__FileName_USCOREType %p -> %p\n", q, p));
	*(jsdlposix__FileName_USCOREType*)p = *(jsdlposix__FileName_USCOREType*)q;
}

void jsdlposix__Argument_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__normalizedString(soap, &this->jsdlposix__Argument_USCOREType::__item);
	this->jsdlposix__Argument_USCOREType::filesystemName = NULL;
	this->jsdlposix__Argument_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdlposix__Argument_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__normalizedString(soap, &this->jsdlposix__Argument_USCOREType::__item);
	/* transient soap skipped */
}

int jsdlposix__Argument_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdlposix__Argument_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdlposix__Argument_USCOREType(struct soap *soap, const char *tag, int id, const jsdlposix__Argument_USCOREType *a, const char *type)
{
	if (((jsdlposix__Argument_USCOREType*)a)->filesystemName)
		soap_set_attr(soap, "filesystemName", ((jsdlposix__Argument_USCOREType*)a)->filesystemName->c_str());
	if (((jsdlposix__Argument_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdlposix__Argument_USCOREType*)a)->__anyAttribute);
	return soap_out_xsd__normalizedString(soap, tag, id, &a->jsdlposix__Argument_USCOREType::__item, "");
}

void *jsdlposix__Argument_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdlposix__Argument_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdlposix__Argument_USCOREType * SOAP_FMAC4 soap_in_jsdlposix__Argument_USCOREType(struct soap *soap, const char *tag, jsdlposix__Argument_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (jsdlposix__Argument_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdlposix__Argument_USCOREType, sizeof(jsdlposix__Argument_USCOREType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdlposix__Argument_USCOREType)
			return (jsdlposix__Argument_USCOREType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "filesystemName", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((jsdlposix__Argument_USCOREType*)a)->filesystemName = soap_new_std__string(soap, -1);
				((jsdlposix__Argument_USCOREType*)a)->filesystemName->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdlposix__Argument_USCOREType*)a)->__anyAttribute, -1, -1))
		return NULL;
	if (!soap_in_xsd__normalizedString(soap, tag, &(a->jsdlposix__Argument_USCOREType::__item), "jsdlposix:Argument_Type"))
		return NULL;
	return a;
}

int jsdlposix__Argument_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdlposix__Argument_USCOREType);
	if (this->soap_out(soap, tag?tag:"jsdlposix:Argument_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *jsdlposix__Argument_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdlposix__Argument_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdlposix__Argument_USCOREType * SOAP_FMAC4 soap_get_jsdlposix__Argument_USCOREType(struct soap *soap, jsdlposix__Argument_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdlposix__Argument_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 jsdlposix__Argument_USCOREType * SOAP_FMAC2 soap_instantiate_jsdlposix__Argument_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdlposix__Argument_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdlposix__Argument_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(jsdlposix__Argument_USCOREType);
		if (size)
			*size = sizeof(jsdlposix__Argument_USCOREType);
		((jsdlposix__Argument_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(jsdlposix__Argument_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdlposix__Argument_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdlposix__Argument_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdlposix__Argument_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdlposix__Argument_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdlposix__Argument_USCOREType %p -> %p\n", q, p));
	*(jsdlposix__Argument_USCOREType*)p = *(jsdlposix__Argument_USCOREType*)q;
}

void jsdlposix__Environment_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->jsdlposix__Environment_USCOREType::__item);
	soap_default_xsd__NCName(soap, &this->jsdlposix__Environment_USCOREType::name);
	this->jsdlposix__Environment_USCOREType::filesystemName = NULL;
	this->jsdlposix__Environment_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdlposix__Environment_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->jsdlposix__Environment_USCOREType::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->jsdlposix__Environment_USCOREType::__item);
	/* transient soap skipped */
}

int jsdlposix__Environment_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdlposix__Environment_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdlposix__Environment_USCOREType(struct soap *soap, const char *tag, int id, const jsdlposix__Environment_USCOREType *a, const char *type)
{
	if (!((jsdlposix__Environment_USCOREType*)a)->name.empty())
		soap_set_attr(soap, "name", ((jsdlposix__Environment_USCOREType*)a)->name.c_str());
	if (((jsdlposix__Environment_USCOREType*)a)->filesystemName)
		soap_set_attr(soap, "filesystemName", ((jsdlposix__Environment_USCOREType*)a)->filesystemName->c_str());
	if (((jsdlposix__Environment_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdlposix__Environment_USCOREType*)a)->__anyAttribute);
	return soap_out_std__string(soap, tag, id, &a->jsdlposix__Environment_USCOREType::__item, "");
}

void *jsdlposix__Environment_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdlposix__Environment_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdlposix__Environment_USCOREType * SOAP_FMAC4 soap_in_jsdlposix__Environment_USCOREType(struct soap *soap, const char *tag, jsdlposix__Environment_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (jsdlposix__Environment_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdlposix__Environment_USCOREType, sizeof(jsdlposix__Environment_USCOREType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdlposix__Environment_USCOREType)
			return (jsdlposix__Environment_USCOREType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "name", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((jsdlposix__Environment_USCOREType*)a)->name.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "filesystemName", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((jsdlposix__Environment_USCOREType*)a)->filesystemName = soap_new_std__string(soap, -1);
				((jsdlposix__Environment_USCOREType*)a)->filesystemName->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdlposix__Environment_USCOREType*)a)->__anyAttribute, -1, -1))
		return NULL;
	if (!soap_in_std__string(soap, tag, &(a->jsdlposix__Environment_USCOREType::__item), "jsdlposix:Environment_Type"))
		return NULL;
	return a;
}

int jsdlposix__Environment_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdlposix__Environment_USCOREType);
	if (this->soap_out(soap, tag?tag:"jsdlposix:Environment_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *jsdlposix__Environment_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdlposix__Environment_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdlposix__Environment_USCOREType * SOAP_FMAC4 soap_get_jsdlposix__Environment_USCOREType(struct soap *soap, jsdlposix__Environment_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdlposix__Environment_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 jsdlposix__Environment_USCOREType * SOAP_FMAC2 soap_instantiate_jsdlposix__Environment_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdlposix__Environment_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdlposix__Environment_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(jsdlposix__Environment_USCOREType);
		if (size)
			*size = sizeof(jsdlposix__Environment_USCOREType);
		((jsdlposix__Environment_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(jsdlposix__Environment_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdlposix__Environment_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdlposix__Environment_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdlposix__Environment_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdlposix__Environment_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdlposix__Environment_USCOREType %p -> %p\n", q, p));
	*(jsdlposix__Environment_USCOREType*)p = *(jsdlposix__Environment_USCOREType*)q;
}

void jsdl__SourceTarget_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__SourceTarget_USCOREType::URI = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__SourceTarget_USCOREType::__any);
	this->jsdl__SourceTarget_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__SourceTarget_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__anyURI(soap, &this->jsdl__SourceTarget_USCOREType::URI);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__SourceTarget_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__SourceTarget_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__SourceTarget_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__SourceTarget_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__SourceTarget_USCOREType *a, const char *type)
{
	if (((jsdl__SourceTarget_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__SourceTarget_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__SourceTarget_USCOREType), type))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "URI", -1, &(a->jsdl__SourceTarget_USCOREType::URI), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__SourceTarget_USCOREType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__SourceTarget_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__SourceTarget_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__SourceTarget_USCOREType * SOAP_FMAC4 soap_in_jsdl__SourceTarget_USCOREType(struct soap *soap, const char *tag, jsdl__SourceTarget_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__SourceTarget_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__SourceTarget_USCOREType, sizeof(jsdl__SourceTarget_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdl__SourceTarget_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__SourceTarget_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__SourceTarget_USCOREType*)a)->__anyAttribute, -1, -1))
		return NULL;
	size_t soap_flag_URI1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_URI1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "URI", &(a->jsdl__SourceTarget_USCOREType::URI), "xsd:anyURI"))
				{	soap_flag_URI1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__SourceTarget_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__SourceTarget_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__SourceTarget_USCOREType, 0, sizeof(jsdl__SourceTarget_USCOREType), 0, soap_copy_jsdl__SourceTarget_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int jsdl__SourceTarget_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdl__SourceTarget_USCOREType);
	if (this->soap_out(soap, tag?tag:"jsdl:SourceTarget_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *jsdl__SourceTarget_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__SourceTarget_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__SourceTarget_USCOREType * SOAP_FMAC4 soap_get_jsdl__SourceTarget_USCOREType(struct soap *soap, jsdl__SourceTarget_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__SourceTarget_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 jsdl__SourceTarget_USCOREType * SOAP_FMAC2 soap_instantiate_jsdl__SourceTarget_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__SourceTarget_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdl__SourceTarget_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(jsdl__SourceTarget_USCOREType);
		if (size)
			*size = sizeof(jsdl__SourceTarget_USCOREType);
		((jsdl__SourceTarget_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(jsdl__SourceTarget_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__SourceTarget_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__SourceTarget_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__SourceTarget_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__SourceTarget_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__SourceTarget_USCOREType %p -> %p\n", q, p));
	*(jsdl__SourceTarget_USCOREType*)p = *(jsdl__SourceTarget_USCOREType*)q;
}

void jsdl__DataStaging_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->jsdl__DataStaging_USCOREType::FileName);
	this->jsdl__DataStaging_USCOREType::FilesystemName = NULL;
	soap_default_jsdl__CreationFlagEnumeration(soap, &this->jsdl__DataStaging_USCOREType::CreationFlag);
	this->jsdl__DataStaging_USCOREType::DeleteOnTermination = NULL;
	this->jsdl__DataStaging_USCOREType::Source = NULL;
	this->jsdl__DataStaging_USCOREType::Target = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__DataStaging_USCOREType::__any);
	this->jsdl__DataStaging_USCOREType::name = NULL;
	this->jsdl__DataStaging_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__DataStaging_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->jsdl__DataStaging_USCOREType::FileName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->jsdl__DataStaging_USCOREType::FileName);
	soap_serialize_PointerToxsd__NCName(soap, &this->jsdl__DataStaging_USCOREType::FilesystemName);
	soap_serialize_PointerTobool(soap, &this->jsdl__DataStaging_USCOREType::DeleteOnTermination);
	soap_serialize_PointerTojsdl__SourceTarget_USCOREType(soap, &this->jsdl__DataStaging_USCOREType::Source);
	soap_serialize_PointerTojsdl__SourceTarget_USCOREType(soap, &this->jsdl__DataStaging_USCOREType::Target);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__DataStaging_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__DataStaging_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__DataStaging_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__DataStaging_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__DataStaging_USCOREType *a, const char *type)
{
	if (((jsdl__DataStaging_USCOREType*)a)->name)
		soap_set_attr(soap, "name", ((jsdl__DataStaging_USCOREType*)a)->name->c_str());
	if (((jsdl__DataStaging_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__DataStaging_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__DataStaging_USCOREType), type))
		return soap->error;
	if (soap_out_std__string(soap, "FileName", -1, &(a->jsdl__DataStaging_USCOREType::FileName), ""))
		return soap->error;
	if (soap_out_PointerToxsd__NCName(soap, "FilesystemName", -1, &(a->jsdl__DataStaging_USCOREType::FilesystemName), ""))
		return soap->error;
	if (soap_out_jsdl__CreationFlagEnumeration(soap, "CreationFlag", -1, &(a->jsdl__DataStaging_USCOREType::CreationFlag), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "DeleteOnTermination", -1, &(a->jsdl__DataStaging_USCOREType::DeleteOnTermination), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__SourceTarget_USCOREType(soap, "Source", -1, &(a->jsdl__DataStaging_USCOREType::Source), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__SourceTarget_USCOREType(soap, "Target", -1, &(a->jsdl__DataStaging_USCOREType::Target), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__DataStaging_USCOREType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__DataStaging_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__DataStaging_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__DataStaging_USCOREType * SOAP_FMAC4 soap_in_jsdl__DataStaging_USCOREType(struct soap *soap, const char *tag, jsdl__DataStaging_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__DataStaging_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__DataStaging_USCOREType, sizeof(jsdl__DataStaging_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdl__DataStaging_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__DataStaging_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((jsdl__DataStaging_USCOREType*)a)->name = soap_new_std__string(soap, -1);
				((jsdl__DataStaging_USCOREType*)a)->name->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__DataStaging_USCOREType*)a)->__anyAttribute, -1, -1))
		return NULL;
	size_t soap_flag_FileName1 = 1;
	size_t soap_flag_FilesystemName1 = 1;
	size_t soap_flag_CreationFlag1 = 1;
	size_t soap_flag_DeleteOnTermination1 = 1;
	size_t soap_flag_Source1 = 1;
	size_t soap_flag_Target1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FileName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "FileName", &(a->jsdl__DataStaging_USCOREType::FileName), "xsd:string"))
				{	soap_flag_FileName1--;
					continue;
				}
			if (soap_flag_FilesystemName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__NCName(soap, "FilesystemName", &(a->jsdl__DataStaging_USCOREType::FilesystemName), "xsd:NCName"))
				{	soap_flag_FilesystemName1--;
					continue;
				}
			if (soap_flag_CreationFlag1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_jsdl__CreationFlagEnumeration(soap, "CreationFlag", &(a->jsdl__DataStaging_USCOREType::CreationFlag), "jsdl:CreationFlagEnumeration"))
				{	soap_flag_CreationFlag1--;
					continue;
				}
			if (soap_flag_DeleteOnTermination1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "DeleteOnTermination", &(a->jsdl__DataStaging_USCOREType::DeleteOnTermination), "xsd:boolean"))
				{	soap_flag_DeleteOnTermination1--;
					continue;
				}
			if (soap_flag_Source1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__SourceTarget_USCOREType(soap, "Source", &(a->jsdl__DataStaging_USCOREType::Source), "jsdl:SourceTarget_Type"))
				{	soap_flag_Source1--;
					continue;
				}
			if (soap_flag_Target1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__SourceTarget_USCOREType(soap, "Target", &(a->jsdl__DataStaging_USCOREType::Target), "jsdl:SourceTarget_Type"))
				{	soap_flag_Target1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__DataStaging_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__DataStaging_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__DataStaging_USCOREType, 0, sizeof(jsdl__DataStaging_USCOREType), 0, soap_copy_jsdl__DataStaging_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FileName1 > 0 || soap_flag_CreationFlag1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int jsdl__DataStaging_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdl__DataStaging_USCOREType);
	if (this->soap_out(soap, tag?tag:"jsdl:DataStaging_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *jsdl__DataStaging_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__DataStaging_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__DataStaging_USCOREType * SOAP_FMAC4 soap_get_jsdl__DataStaging_USCOREType(struct soap *soap, jsdl__DataStaging_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__DataStaging_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 jsdl__DataStaging_USCOREType * SOAP_FMAC2 soap_instantiate_jsdl__DataStaging_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__DataStaging_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdl__DataStaging_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(jsdl__DataStaging_USCOREType);
		if (size)
			*size = sizeof(jsdl__DataStaging_USCOREType);
		((jsdl__DataStaging_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(jsdl__DataStaging_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__DataStaging_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__DataStaging_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__DataStaging_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__DataStaging_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__DataStaging_USCOREType %p -> %p\n", q, p));
	*(jsdl__DataStaging_USCOREType*)p = *(jsdl__DataStaging_USCOREType*)q;
}

void jsdl__OperatingSystemType_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_jsdl__OperatingSystemTypeEnumeration(soap, &this->jsdl__OperatingSystemType_USCOREType::OperatingSystemName);
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__OperatingSystemType_USCOREType::__any);
	this->jsdl__OperatingSystemType_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__OperatingSystemType_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__OperatingSystemType_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__OperatingSystemType_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__OperatingSystemType_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__OperatingSystemType_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__OperatingSystemType_USCOREType *a, const char *type)
{
	if (((jsdl__OperatingSystemType_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__OperatingSystemType_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__OperatingSystemType_USCOREType), type))
		return soap->error;
	if (soap_out_jsdl__OperatingSystemTypeEnumeration(soap, "OperatingSystemName", -1, &(a->jsdl__OperatingSystemType_USCOREType::OperatingSystemName), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__OperatingSystemType_USCOREType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__OperatingSystemType_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__OperatingSystemType_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__OperatingSystemType_USCOREType * SOAP_FMAC4 soap_in_jsdl__OperatingSystemType_USCOREType(struct soap *soap, const char *tag, jsdl__OperatingSystemType_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__OperatingSystemType_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__OperatingSystemType_USCOREType, sizeof(jsdl__OperatingSystemType_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdl__OperatingSystemType_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__OperatingSystemType_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__OperatingSystemType_USCOREType*)a)->__anyAttribute, -1, -1))
		return NULL;
	size_t soap_flag_OperatingSystemName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OperatingSystemName1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_jsdl__OperatingSystemTypeEnumeration(soap, "OperatingSystemName", &(a->jsdl__OperatingSystemType_USCOREType::OperatingSystemName), "jsdl:OperatingSystemTypeEnumeration"))
				{	soap_flag_OperatingSystemName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__OperatingSystemType_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__OperatingSystemType_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__OperatingSystemType_USCOREType, 0, sizeof(jsdl__OperatingSystemType_USCOREType), 0, soap_copy_jsdl__OperatingSystemType_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OperatingSystemName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int jsdl__OperatingSystemType_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdl__OperatingSystemType_USCOREType);
	if (this->soap_out(soap, tag?tag:"jsdl:OperatingSystemType_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *jsdl__OperatingSystemType_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__OperatingSystemType_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__OperatingSystemType_USCOREType * SOAP_FMAC4 soap_get_jsdl__OperatingSystemType_USCOREType(struct soap *soap, jsdl__OperatingSystemType_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__OperatingSystemType_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 jsdl__OperatingSystemType_USCOREType * SOAP_FMAC2 soap_instantiate_jsdl__OperatingSystemType_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__OperatingSystemType_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdl__OperatingSystemType_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(jsdl__OperatingSystemType_USCOREType);
		if (size)
			*size = sizeof(jsdl__OperatingSystemType_USCOREType);
		((jsdl__OperatingSystemType_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(jsdl__OperatingSystemType_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__OperatingSystemType_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__OperatingSystemType_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__OperatingSystemType_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__OperatingSystemType_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__OperatingSystemType_USCOREType %p -> %p\n", q, p));
	*(jsdl__OperatingSystemType_USCOREType*)p = *(jsdl__OperatingSystemType_USCOREType*)q;
}

void jsdl__OperatingSystem_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__OperatingSystem_USCOREType::OperatingSystemType = NULL;
	this->jsdl__OperatingSystem_USCOREType::OperatingSystemVersion = NULL;
	this->jsdl__OperatingSystem_USCOREType::Description = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__OperatingSystem_USCOREType::__any);
	this->jsdl__OperatingSystem_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__OperatingSystem_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__OperatingSystemType_USCOREType(soap, &this->jsdl__OperatingSystem_USCOREType::OperatingSystemType);
	soap_serialize_PointerTostd__string(soap, &this->jsdl__OperatingSystem_USCOREType::OperatingSystemVersion);
	soap_serialize_PointerTojsdl__Description_USCOREType(soap, &this->jsdl__OperatingSystem_USCOREType::Description);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__OperatingSystem_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__OperatingSystem_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__OperatingSystem_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__OperatingSystem_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__OperatingSystem_USCOREType *a, const char *type)
{
	if (((jsdl__OperatingSystem_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__OperatingSystem_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__OperatingSystem_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTojsdl__OperatingSystemType_USCOREType(soap, "OperatingSystemType", -1, &(a->jsdl__OperatingSystem_USCOREType::OperatingSystemType), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "OperatingSystemVersion", -1, &(a->jsdl__OperatingSystem_USCOREType::OperatingSystemVersion), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Description_USCOREType(soap, "Description", -1, &(a->jsdl__OperatingSystem_USCOREType::Description), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__OperatingSystem_USCOREType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__OperatingSystem_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__OperatingSystem_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__OperatingSystem_USCOREType * SOAP_FMAC4 soap_in_jsdl__OperatingSystem_USCOREType(struct soap *soap, const char *tag, jsdl__OperatingSystem_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__OperatingSystem_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__OperatingSystem_USCOREType, sizeof(jsdl__OperatingSystem_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdl__OperatingSystem_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__OperatingSystem_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__OperatingSystem_USCOREType*)a)->__anyAttribute, -1, -1))
		return NULL;
	size_t soap_flag_OperatingSystemType1 = 1;
	size_t soap_flag_OperatingSystemVersion1 = 1;
	size_t soap_flag_Description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OperatingSystemType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__OperatingSystemType_USCOREType(soap, "OperatingSystemType", &(a->jsdl__OperatingSystem_USCOREType::OperatingSystemType), "jsdl:OperatingSystemType_Type"))
				{	soap_flag_OperatingSystemType1--;
					continue;
				}
			if (soap_flag_OperatingSystemVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "OperatingSystemVersion", &(a->jsdl__OperatingSystem_USCOREType::OperatingSystemVersion), "xsd:string"))
				{	soap_flag_OperatingSystemVersion1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTojsdl__Description_USCOREType(soap, "Description", &(a->jsdl__OperatingSystem_USCOREType::Description), "jsdl:Description_Type"))
				{	soap_flag_Description1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__OperatingSystem_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__OperatingSystem_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__OperatingSystem_USCOREType, 0, sizeof(jsdl__OperatingSystem_USCOREType), 0, soap_copy_jsdl__OperatingSystem_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int jsdl__OperatingSystem_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdl__OperatingSystem_USCOREType);
	if (this->soap_out(soap, tag?tag:"jsdl:OperatingSystem_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *jsdl__OperatingSystem_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__OperatingSystem_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__OperatingSystem_USCOREType * SOAP_FMAC4 soap_get_jsdl__OperatingSystem_USCOREType(struct soap *soap, jsdl__OperatingSystem_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__OperatingSystem_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 jsdl__OperatingSystem_USCOREType * SOAP_FMAC2 soap_instantiate_jsdl__OperatingSystem_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__OperatingSystem_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdl__OperatingSystem_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(jsdl__OperatingSystem_USCOREType);
		if (size)
			*size = sizeof(jsdl__OperatingSystem_USCOREType);
		((jsdl__OperatingSystem_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(jsdl__OperatingSystem_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__OperatingSystem_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__OperatingSystem_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__OperatingSystem_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__OperatingSystem_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__OperatingSystem_USCOREType %p -> %p\n", q, p));
	*(jsdl__OperatingSystem_USCOREType*)p = *(jsdl__OperatingSystem_USCOREType*)q;
}

void jsdl__FileSystem_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__FileSystem_USCOREType::FileSystemType = NULL;
	this->jsdl__FileSystem_USCOREType::Description = NULL;
	this->jsdl__FileSystem_USCOREType::MountPoint = NULL;
	this->jsdl__FileSystem_USCOREType::DiskSpace = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__FileSystem_USCOREType::__any);
	soap_default_xsd__NCName(soap, &this->jsdl__FileSystem_USCOREType::name);
	this->jsdl__FileSystem_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__FileSystem_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__FileSystemTypeEnumeration(soap, &this->jsdl__FileSystem_USCOREType::FileSystemType);
	soap_serialize_PointerTojsdl__Description_USCOREType(soap, &this->jsdl__FileSystem_USCOREType::Description);
	soap_serialize_PointerTostd__string(soap, &this->jsdl__FileSystem_USCOREType::MountPoint);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__FileSystem_USCOREType::DiskSpace);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__FileSystem_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__FileSystem_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__FileSystem_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__FileSystem_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__FileSystem_USCOREType *a, const char *type)
{
	if (!((jsdl__FileSystem_USCOREType*)a)->name.empty())
		soap_set_attr(soap, "name", ((jsdl__FileSystem_USCOREType*)a)->name.c_str());
	if (((jsdl__FileSystem_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__FileSystem_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__FileSystem_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTojsdl__FileSystemTypeEnumeration(soap, "FileSystemType", -1, &(a->jsdl__FileSystem_USCOREType::FileSystemType), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Description_USCOREType(soap, "Description", -1, &(a->jsdl__FileSystem_USCOREType::Description), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "MountPoint", -1, &(a->jsdl__FileSystem_USCOREType::MountPoint), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "DiskSpace", -1, &(a->jsdl__FileSystem_USCOREType::DiskSpace), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__FileSystem_USCOREType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__FileSystem_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__FileSystem_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__FileSystem_USCOREType * SOAP_FMAC4 soap_in_jsdl__FileSystem_USCOREType(struct soap *soap, const char *tag, jsdl__FileSystem_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__FileSystem_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__FileSystem_USCOREType, sizeof(jsdl__FileSystem_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdl__FileSystem_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__FileSystem_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			((jsdl__FileSystem_USCOREType*)a)->name.assign(s);
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__FileSystem_USCOREType*)a)->__anyAttribute, -1, -1))
		return NULL;
	size_t soap_flag_FileSystemType1 = 1;
	size_t soap_flag_Description1 = 1;
	size_t soap_flag_MountPoint1 = 1;
	size_t soap_flag_DiskSpace1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FileSystemType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__FileSystemTypeEnumeration(soap, "FileSystemType", &(a->jsdl__FileSystem_USCOREType::FileSystemType), "jsdl:FileSystemTypeEnumeration"))
				{	soap_flag_FileSystemType1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTojsdl__Description_USCOREType(soap, "Description", &(a->jsdl__FileSystem_USCOREType::Description), "jsdl:Description_Type"))
				{	soap_flag_Description1--;
					continue;
				}
			if (soap_flag_MountPoint1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "MountPoint", &(a->jsdl__FileSystem_USCOREType::MountPoint), "xsd:string"))
				{	soap_flag_MountPoint1--;
					continue;
				}
			if (soap_flag_DiskSpace1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "DiskSpace", &(a->jsdl__FileSystem_USCOREType::DiskSpace), "jsdl:RangeValue_Type"))
				{	soap_flag_DiskSpace1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__FileSystem_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__FileSystem_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__FileSystem_USCOREType, 0, sizeof(jsdl__FileSystem_USCOREType), 0, soap_copy_jsdl__FileSystem_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int jsdl__FileSystem_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdl__FileSystem_USCOREType);
	if (this->soap_out(soap, tag?tag:"jsdl:FileSystem_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *jsdl__FileSystem_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__FileSystem_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__FileSystem_USCOREType * SOAP_FMAC4 soap_get_jsdl__FileSystem_USCOREType(struct soap *soap, jsdl__FileSystem_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__FileSystem_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 jsdl__FileSystem_USCOREType * SOAP_FMAC2 soap_instantiate_jsdl__FileSystem_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__FileSystem_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdl__FileSystem_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(jsdl__FileSystem_USCOREType);
		if (size)
			*size = sizeof(jsdl__FileSystem_USCOREType);
		((jsdl__FileSystem_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(jsdl__FileSystem_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__FileSystem_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__FileSystem_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__FileSystem_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__FileSystem_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__FileSystem_USCOREType %p -> %p\n", q, p));
	*(jsdl__FileSystem_USCOREType*)p = *(jsdl__FileSystem_USCOREType*)q;
}

void jsdl__CPUArchitecture_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_jsdl__ProcessorArchitectureEnumeration(soap, &this->jsdl__CPUArchitecture_USCOREType::CPUArchitectureName);
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__CPUArchitecture_USCOREType::__any);
	this->jsdl__CPUArchitecture_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__CPUArchitecture_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__CPUArchitecture_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__CPUArchitecture_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__CPUArchitecture_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__CPUArchitecture_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__CPUArchitecture_USCOREType *a, const char *type)
{
	if (((jsdl__CPUArchitecture_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__CPUArchitecture_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__CPUArchitecture_USCOREType), type))
		return soap->error;
	if (soap_out_jsdl__ProcessorArchitectureEnumeration(soap, "CPUArchitectureName", -1, &(a->jsdl__CPUArchitecture_USCOREType::CPUArchitectureName), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__CPUArchitecture_USCOREType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__CPUArchitecture_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__CPUArchitecture_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__CPUArchitecture_USCOREType * SOAP_FMAC4 soap_in_jsdl__CPUArchitecture_USCOREType(struct soap *soap, const char *tag, jsdl__CPUArchitecture_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__CPUArchitecture_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__CPUArchitecture_USCOREType, sizeof(jsdl__CPUArchitecture_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdl__CPUArchitecture_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__CPUArchitecture_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__CPUArchitecture_USCOREType*)a)->__anyAttribute, -1, -1))
		return NULL;
	size_t soap_flag_CPUArchitectureName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CPUArchitectureName1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_jsdl__ProcessorArchitectureEnumeration(soap, "CPUArchitectureName", &(a->jsdl__CPUArchitecture_USCOREType::CPUArchitectureName), "jsdl:ProcessorArchitectureEnumeration"))
				{	soap_flag_CPUArchitectureName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__CPUArchitecture_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__CPUArchitecture_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__CPUArchitecture_USCOREType, 0, sizeof(jsdl__CPUArchitecture_USCOREType), 0, soap_copy_jsdl__CPUArchitecture_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CPUArchitectureName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int jsdl__CPUArchitecture_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdl__CPUArchitecture_USCOREType);
	if (this->soap_out(soap, tag?tag:"jsdl:CPUArchitecture_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *jsdl__CPUArchitecture_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__CPUArchitecture_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__CPUArchitecture_USCOREType * SOAP_FMAC4 soap_get_jsdl__CPUArchitecture_USCOREType(struct soap *soap, jsdl__CPUArchitecture_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__CPUArchitecture_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 jsdl__CPUArchitecture_USCOREType * SOAP_FMAC2 soap_instantiate_jsdl__CPUArchitecture_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__CPUArchitecture_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdl__CPUArchitecture_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(jsdl__CPUArchitecture_USCOREType);
		if (size)
			*size = sizeof(jsdl__CPUArchitecture_USCOREType);
		((jsdl__CPUArchitecture_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(jsdl__CPUArchitecture_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__CPUArchitecture_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__CPUArchitecture_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__CPUArchitecture_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__CPUArchitecture_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__CPUArchitecture_USCOREType %p -> %p\n", q, p));
	*(jsdl__CPUArchitecture_USCOREType*)p = *(jsdl__CPUArchitecture_USCOREType*)q;
}

void jsdl__CandidateHosts_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->jsdl__CandidateHosts_USCOREType::HostName);
	/* transient soap skipped */
}

void jsdl__CandidateHosts_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->jsdl__CandidateHosts_USCOREType::HostName);
	/* transient soap skipped */
}

int jsdl__CandidateHosts_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__CandidateHosts_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__CandidateHosts_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__CandidateHosts_USCOREType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__CandidateHosts_USCOREType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "HostName", -1, &(a->jsdl__CandidateHosts_USCOREType::HostName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__CandidateHosts_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__CandidateHosts_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__CandidateHosts_USCOREType * SOAP_FMAC4 soap_in_jsdl__CandidateHosts_USCOREType(struct soap *soap, const char *tag, jsdl__CandidateHosts_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__CandidateHosts_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__CandidateHosts_USCOREType, sizeof(jsdl__CandidateHosts_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdl__CandidateHosts_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__CandidateHosts_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "HostName", &(a->jsdl__CandidateHosts_USCOREType::HostName), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__CandidateHosts_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__CandidateHosts_USCOREType, 0, sizeof(jsdl__CandidateHosts_USCOREType), 0, soap_copy_jsdl__CandidateHosts_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->jsdl__CandidateHosts_USCOREType::HostName.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int jsdl__CandidateHosts_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdl__CandidateHosts_USCOREType);
	if (this->soap_out(soap, tag?tag:"jsdl:CandidateHosts_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *jsdl__CandidateHosts_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__CandidateHosts_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__CandidateHosts_USCOREType * SOAP_FMAC4 soap_get_jsdl__CandidateHosts_USCOREType(struct soap *soap, jsdl__CandidateHosts_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__CandidateHosts_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 jsdl__CandidateHosts_USCOREType * SOAP_FMAC2 soap_instantiate_jsdl__CandidateHosts_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__CandidateHosts_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdl__CandidateHosts_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(jsdl__CandidateHosts_USCOREType);
		if (size)
			*size = sizeof(jsdl__CandidateHosts_USCOREType);
		((jsdl__CandidateHosts_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(jsdl__CandidateHosts_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__CandidateHosts_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__CandidateHosts_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__CandidateHosts_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__CandidateHosts_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__CandidateHosts_USCOREType %p -> %p\n", q, p));
	*(jsdl__CandidateHosts_USCOREType*)p = *(jsdl__CandidateHosts_USCOREType*)q;
}

void jsdl__Resources_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__Resources_USCOREType::CandidateHosts = NULL;
	soap_default_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(soap, &this->jsdl__Resources_USCOREType::FileSystem);
	this->jsdl__Resources_USCOREType::ExclusiveExecution = NULL;
	this->jsdl__Resources_USCOREType::OperatingSystem = NULL;
	this->jsdl__Resources_USCOREType::CPUArchitecture = NULL;
	this->jsdl__Resources_USCOREType::IndividualCPUSpeed = NULL;
	this->jsdl__Resources_USCOREType::IndividualCPUTime = NULL;
	this->jsdl__Resources_USCOREType::IndividualCPUCount = NULL;
	this->jsdl__Resources_USCOREType::IndividualNetworkBandwidth = NULL;
	this->jsdl__Resources_USCOREType::IndividualPhysicalMemory = NULL;
	this->jsdl__Resources_USCOREType::IndividualVirtualMemory = NULL;
	this->jsdl__Resources_USCOREType::IndividualDiskSpace = NULL;
	this->jsdl__Resources_USCOREType::TotalCPUTime = NULL;
	this->jsdl__Resources_USCOREType::TotalCPUCount = NULL;
	this->jsdl__Resources_USCOREType::TotalPhysicalMemory = NULL;
	this->jsdl__Resources_USCOREType::TotalVirtualMemory = NULL;
	this->jsdl__Resources_USCOREType::TotalDiskSpace = NULL;
	this->jsdl__Resources_USCOREType::TotalResourceCount = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__Resources_USCOREType::__any);
	this->jsdl__Resources_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__Resources_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__CandidateHosts_USCOREType(soap, &this->jsdl__Resources_USCOREType::CandidateHosts);
	soap_serialize_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(soap, &this->jsdl__Resources_USCOREType::FileSystem);
	soap_serialize_PointerTobool(soap, &this->jsdl__Resources_USCOREType::ExclusiveExecution);
	soap_serialize_PointerTojsdl__OperatingSystem_USCOREType(soap, &this->jsdl__Resources_USCOREType::OperatingSystem);
	soap_serialize_PointerTojsdl__CPUArchitecture_USCOREType(soap, &this->jsdl__Resources_USCOREType::CPUArchitecture);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::IndividualCPUSpeed);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::IndividualCPUTime);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::IndividualCPUCount);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::IndividualNetworkBandwidth);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::IndividualPhysicalMemory);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::IndividualVirtualMemory);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::IndividualDiskSpace);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::TotalCPUTime);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::TotalCPUCount);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::TotalPhysicalMemory);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::TotalVirtualMemory);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::TotalDiskSpace);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::TotalResourceCount);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__Resources_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__Resources_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__Resources_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__Resources_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__Resources_USCOREType *a, const char *type)
{
	if (((jsdl__Resources_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__Resources_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__Resources_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTojsdl__CandidateHosts_USCOREType(soap, "CandidateHosts", -1, &(a->jsdl__Resources_USCOREType::CandidateHosts), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(soap, "FileSystem", -1, &(a->jsdl__Resources_USCOREType::FileSystem), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ExclusiveExecution", -1, &(a->jsdl__Resources_USCOREType::ExclusiveExecution), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__OperatingSystem_USCOREType(soap, "OperatingSystem", -1, &(a->jsdl__Resources_USCOREType::OperatingSystem), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__CPUArchitecture_USCOREType(soap, "CPUArchitecture", -1, &(a->jsdl__Resources_USCOREType::CPUArchitecture), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "IndividualCPUSpeed", -1, &(a->jsdl__Resources_USCOREType::IndividualCPUSpeed), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "IndividualCPUTime", -1, &(a->jsdl__Resources_USCOREType::IndividualCPUTime), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "IndividualCPUCount", -1, &(a->jsdl__Resources_USCOREType::IndividualCPUCount), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "IndividualNetworkBandwidth", -1, &(a->jsdl__Resources_USCOREType::IndividualNetworkBandwidth), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "IndividualPhysicalMemory", -1, &(a->jsdl__Resources_USCOREType::IndividualPhysicalMemory), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "IndividualVirtualMemory", -1, &(a->jsdl__Resources_USCOREType::IndividualVirtualMemory), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "IndividualDiskSpace", -1, &(a->jsdl__Resources_USCOREType::IndividualDiskSpace), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "TotalCPUTime", -1, &(a->jsdl__Resources_USCOREType::TotalCPUTime), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "TotalCPUCount", -1, &(a->jsdl__Resources_USCOREType::TotalCPUCount), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "TotalPhysicalMemory", -1, &(a->jsdl__Resources_USCOREType::TotalPhysicalMemory), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "TotalVirtualMemory", -1, &(a->jsdl__Resources_USCOREType::TotalVirtualMemory), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "TotalDiskSpace", -1, &(a->jsdl__Resources_USCOREType::TotalDiskSpace), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "TotalResourceCount", -1, &(a->jsdl__Resources_USCOREType::TotalResourceCount), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__Resources_USCOREType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__Resources_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__Resources_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__Resources_USCOREType * SOAP_FMAC4 soap_in_jsdl__Resources_USCOREType(struct soap *soap, const char *tag, jsdl__Resources_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__Resources_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__Resources_USCOREType, sizeof(jsdl__Resources_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdl__Resources_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__Resources_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__Resources_USCOREType*)a)->__anyAttribute, -1, -1))
		return NULL;
	size_t soap_flag_CandidateHosts1 = 1;
	size_t soap_flag_ExclusiveExecution1 = 1;
	size_t soap_flag_OperatingSystem1 = 1;
	size_t soap_flag_CPUArchitecture1 = 1;
	size_t soap_flag_IndividualCPUSpeed1 = 1;
	size_t soap_flag_IndividualCPUTime1 = 1;
	size_t soap_flag_IndividualCPUCount1 = 1;
	size_t soap_flag_IndividualNetworkBandwidth1 = 1;
	size_t soap_flag_IndividualPhysicalMemory1 = 1;
	size_t soap_flag_IndividualVirtualMemory1 = 1;
	size_t soap_flag_IndividualDiskSpace1 = 1;
	size_t soap_flag_TotalCPUTime1 = 1;
	size_t soap_flag_TotalCPUCount1 = 1;
	size_t soap_flag_TotalPhysicalMemory1 = 1;
	size_t soap_flag_TotalVirtualMemory1 = 1;
	size_t soap_flag_TotalDiskSpace1 = 1;
	size_t soap_flag_TotalResourceCount1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CandidateHosts1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__CandidateHosts_USCOREType(soap, "CandidateHosts", &(a->jsdl__Resources_USCOREType::CandidateHosts), "jsdl:CandidateHosts_Type"))
				{	soap_flag_CandidateHosts1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(soap, "FileSystem", &(a->jsdl__Resources_USCOREType::FileSystem), "jsdl:FileSystem_Type"))
					continue;
			if (soap_flag_ExclusiveExecution1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ExclusiveExecution", &(a->jsdl__Resources_USCOREType::ExclusiveExecution), "xsd:boolean"))
				{	soap_flag_ExclusiveExecution1--;
					continue;
				}
			if (soap_flag_OperatingSystem1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__OperatingSystem_USCOREType(soap, "OperatingSystem", &(a->jsdl__Resources_USCOREType::OperatingSystem), "jsdl:OperatingSystem_Type"))
				{	soap_flag_OperatingSystem1--;
					continue;
				}
			if (soap_flag_CPUArchitecture1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__CPUArchitecture_USCOREType(soap, "CPUArchitecture", &(a->jsdl__Resources_USCOREType::CPUArchitecture), "jsdl:CPUArchitecture_Type"))
				{	soap_flag_CPUArchitecture1--;
					continue;
				}
			if (soap_flag_IndividualCPUSpeed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "IndividualCPUSpeed", &(a->jsdl__Resources_USCOREType::IndividualCPUSpeed), "jsdl:RangeValue_Type"))
				{	soap_flag_IndividualCPUSpeed1--;
					continue;
				}
			if (soap_flag_IndividualCPUTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "IndividualCPUTime", &(a->jsdl__Resources_USCOREType::IndividualCPUTime), "jsdl:RangeValue_Type"))
				{	soap_flag_IndividualCPUTime1--;
					continue;
				}
			if (soap_flag_IndividualCPUCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "IndividualCPUCount", &(a->jsdl__Resources_USCOREType::IndividualCPUCount), "jsdl:RangeValue_Type"))
				{	soap_flag_IndividualCPUCount1--;
					continue;
				}
			if (soap_flag_IndividualNetworkBandwidth1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "IndividualNetworkBandwidth", &(a->jsdl__Resources_USCOREType::IndividualNetworkBandwidth), "jsdl:RangeValue_Type"))
				{	soap_flag_IndividualNetworkBandwidth1--;
					continue;
				}
			if (soap_flag_IndividualPhysicalMemory1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "IndividualPhysicalMemory", &(a->jsdl__Resources_USCOREType::IndividualPhysicalMemory), "jsdl:RangeValue_Type"))
				{	soap_flag_IndividualPhysicalMemory1--;
					continue;
				}
			if (soap_flag_IndividualVirtualMemory1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "IndividualVirtualMemory", &(a->jsdl__Resources_USCOREType::IndividualVirtualMemory), "jsdl:RangeValue_Type"))
				{	soap_flag_IndividualVirtualMemory1--;
					continue;
				}
			if (soap_flag_IndividualDiskSpace1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "IndividualDiskSpace", &(a->jsdl__Resources_USCOREType::IndividualDiskSpace), "jsdl:RangeValue_Type"))
				{	soap_flag_IndividualDiskSpace1--;
					continue;
				}
			if (soap_flag_TotalCPUTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "TotalCPUTime", &(a->jsdl__Resources_USCOREType::TotalCPUTime), "jsdl:RangeValue_Type"))
				{	soap_flag_TotalCPUTime1--;
					continue;
				}
			if (soap_flag_TotalCPUCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "TotalCPUCount", &(a->jsdl__Resources_USCOREType::TotalCPUCount), "jsdl:RangeValue_Type"))
				{	soap_flag_TotalCPUCount1--;
					continue;
				}
			if (soap_flag_TotalPhysicalMemory1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "TotalPhysicalMemory", &(a->jsdl__Resources_USCOREType::TotalPhysicalMemory), "jsdl:RangeValue_Type"))
				{	soap_flag_TotalPhysicalMemory1--;
					continue;
				}
			if (soap_flag_TotalVirtualMemory1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "TotalVirtualMemory", &(a->jsdl__Resources_USCOREType::TotalVirtualMemory), "jsdl:RangeValue_Type"))
				{	soap_flag_TotalVirtualMemory1--;
					continue;
				}
			if (soap_flag_TotalDiskSpace1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "TotalDiskSpace", &(a->jsdl__Resources_USCOREType::TotalDiskSpace), "jsdl:RangeValue_Type"))
				{	soap_flag_TotalDiskSpace1--;
					continue;
				}
			if (soap_flag_TotalResourceCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "TotalResourceCount", &(a->jsdl__Resources_USCOREType::TotalResourceCount), "jsdl:RangeValue_Type"))
				{	soap_flag_TotalResourceCount1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__Resources_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__Resources_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__Resources_USCOREType, 0, sizeof(jsdl__Resources_USCOREType), 0, soap_copy_jsdl__Resources_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int jsdl__Resources_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdl__Resources_USCOREType);
	if (this->soap_out(soap, tag?tag:"jsdl:Resources_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *jsdl__Resources_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__Resources_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__Resources_USCOREType * SOAP_FMAC4 soap_get_jsdl__Resources_USCOREType(struct soap *soap, jsdl__Resources_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Resources_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 jsdl__Resources_USCOREType * SOAP_FMAC2 soap_instantiate_jsdl__Resources_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__Resources_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdl__Resources_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(jsdl__Resources_USCOREType);
		if (size)
			*size = sizeof(jsdl__Resources_USCOREType);
		((jsdl__Resources_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(jsdl__Resources_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__Resources_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__Resources_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__Resources_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__Resources_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__Resources_USCOREType %p -> %p\n", q, p));
	*(jsdl__Resources_USCOREType*)p = *(jsdl__Resources_USCOREType*)q;
}

void jsdl__Application_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__Application_USCOREType::ApplicationName = NULL;
	this->jsdl__Application_USCOREType::ApplicationVersion = NULL;
	this->jsdl__Application_USCOREType::Description = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__Application_USCOREType::__any);
	this->jsdl__Application_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__Application_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->jsdl__Application_USCOREType::ApplicationName);
	soap_serialize_PointerTostd__string(soap, &this->jsdl__Application_USCOREType::ApplicationVersion);
	soap_serialize_PointerTojsdl__Description_USCOREType(soap, &this->jsdl__Application_USCOREType::Description);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__Application_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__Application_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__Application_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__Application_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__Application_USCOREType *a, const char *type)
{
	if (((jsdl__Application_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__Application_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__Application_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ApplicationName", -1, &(a->jsdl__Application_USCOREType::ApplicationName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ApplicationVersion", -1, &(a->jsdl__Application_USCOREType::ApplicationVersion), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Description_USCOREType(soap, "Description", -1, &(a->jsdl__Application_USCOREType::Description), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__Application_USCOREType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__Application_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__Application_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__Application_USCOREType * SOAP_FMAC4 soap_in_jsdl__Application_USCOREType(struct soap *soap, const char *tag, jsdl__Application_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__Application_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__Application_USCOREType, sizeof(jsdl__Application_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdl__Application_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__Application_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__Application_USCOREType*)a)->__anyAttribute, -1, -1))
		return NULL;
	size_t soap_flag_ApplicationName1 = 1;
	size_t soap_flag_ApplicationVersion1 = 1;
	size_t soap_flag_Description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ApplicationName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ApplicationName", &(a->jsdl__Application_USCOREType::ApplicationName), "xsd:string"))
				{	soap_flag_ApplicationName1--;
					continue;
				}
			if (soap_flag_ApplicationVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ApplicationVersion", &(a->jsdl__Application_USCOREType::ApplicationVersion), "xsd:string"))
				{	soap_flag_ApplicationVersion1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTojsdl__Description_USCOREType(soap, "Description", &(a->jsdl__Application_USCOREType::Description), "jsdl:Description_Type"))
				{	soap_flag_Description1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__Application_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__Application_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__Application_USCOREType, 0, sizeof(jsdl__Application_USCOREType), 0, soap_copy_jsdl__Application_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int jsdl__Application_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdl__Application_USCOREType);
	if (this->soap_out(soap, tag?tag:"jsdl:Application_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *jsdl__Application_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__Application_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__Application_USCOREType * SOAP_FMAC4 soap_get_jsdl__Application_USCOREType(struct soap *soap, jsdl__Application_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Application_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 jsdl__Application_USCOREType * SOAP_FMAC2 soap_instantiate_jsdl__Application_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__Application_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdl__Application_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(jsdl__Application_USCOREType);
		if (size)
			*size = sizeof(jsdl__Application_USCOREType);
		((jsdl__Application_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(jsdl__Application_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__Application_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__Application_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__Application_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__Application_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__Application_USCOREType %p -> %p\n", q, p));
	*(jsdl__Application_USCOREType*)p = *(jsdl__Application_USCOREType*)q;
}

void jsdl__JobIdentification_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__JobIdentification_USCOREType::JobName = NULL;
	this->jsdl__JobIdentification_USCOREType::Description = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->jsdl__JobIdentification_USCOREType::JobAnnotation);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->jsdl__JobIdentification_USCOREType::JobProject);
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__JobIdentification_USCOREType::__any);
	this->jsdl__JobIdentification_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__JobIdentification_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->jsdl__JobIdentification_USCOREType::JobName);
	soap_serialize_PointerTojsdl__Description_USCOREType(soap, &this->jsdl__JobIdentification_USCOREType::Description);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->jsdl__JobIdentification_USCOREType::JobAnnotation);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->jsdl__JobIdentification_USCOREType::JobProject);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__JobIdentification_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__JobIdentification_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__JobIdentification_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__JobIdentification_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__JobIdentification_USCOREType *a, const char *type)
{
	if (((jsdl__JobIdentification_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__JobIdentification_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__JobIdentification_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "JobName", -1, &(a->jsdl__JobIdentification_USCOREType::JobName), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Description_USCOREType(soap, "Description", -1, &(a->jsdl__JobIdentification_USCOREType::Description), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "JobAnnotation", -1, &(a->jsdl__JobIdentification_USCOREType::JobAnnotation), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "JobProject", -1, &(a->jsdl__JobIdentification_USCOREType::JobProject), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__JobIdentification_USCOREType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__JobIdentification_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__JobIdentification_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__JobIdentification_USCOREType * SOAP_FMAC4 soap_in_jsdl__JobIdentification_USCOREType(struct soap *soap, const char *tag, jsdl__JobIdentification_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__JobIdentification_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__JobIdentification_USCOREType, sizeof(jsdl__JobIdentification_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdl__JobIdentification_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__JobIdentification_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__JobIdentification_USCOREType*)a)->__anyAttribute, -1, -1))
		return NULL;
	size_t soap_flag_JobName1 = 1;
	size_t soap_flag_Description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "JobName", &(a->jsdl__JobIdentification_USCOREType::JobName), "xsd:string"))
				{	soap_flag_JobName1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTojsdl__Description_USCOREType(soap, "Description", &(a->jsdl__JobIdentification_USCOREType::Description), "jsdl:Description_Type"))
				{	soap_flag_Description1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "JobAnnotation", &(a->jsdl__JobIdentification_USCOREType::JobAnnotation), "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "JobProject", &(a->jsdl__JobIdentification_USCOREType::JobProject), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__JobIdentification_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__JobIdentification_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__JobIdentification_USCOREType, 0, sizeof(jsdl__JobIdentification_USCOREType), 0, soap_copy_jsdl__JobIdentification_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int jsdl__JobIdentification_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdl__JobIdentification_USCOREType);
	if (this->soap_out(soap, tag?tag:"jsdl:JobIdentification_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *jsdl__JobIdentification_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__JobIdentification_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__JobIdentification_USCOREType * SOAP_FMAC4 soap_get_jsdl__JobIdentification_USCOREType(struct soap *soap, jsdl__JobIdentification_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__JobIdentification_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 jsdl__JobIdentification_USCOREType * SOAP_FMAC2 soap_instantiate_jsdl__JobIdentification_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__JobIdentification_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdl__JobIdentification_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(jsdl__JobIdentification_USCOREType);
		if (size)
			*size = sizeof(jsdl__JobIdentification_USCOREType);
		((jsdl__JobIdentification_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(jsdl__JobIdentification_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__JobIdentification_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__JobIdentification_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__JobIdentification_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__JobIdentification_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__JobIdentification_USCOREType %p -> %p\n", q, p));
	*(jsdl__JobIdentification_USCOREType*)p = *(jsdl__JobIdentification_USCOREType*)q;
}

void jsdl__JobDescription_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__JobDescription_USCOREType::JobIdentification = NULL;
	this->jsdl__JobDescription_USCOREType::Application = NULL;
	this->jsdl__JobDescription_USCOREType::Resources = NULL;
	soap_default_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(soap, &this->jsdl__JobDescription_USCOREType::DataStaging);
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__JobDescription_USCOREType::__any);
	this->jsdl__JobDescription_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__JobDescription_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__JobIdentification_USCOREType(soap, &this->jsdl__JobDescription_USCOREType::JobIdentification);
	soap_serialize_PointerTojsdl__Application_USCOREType(soap, &this->jsdl__JobDescription_USCOREType::Application);
	soap_serialize_PointerTojsdl__Resources_USCOREType(soap, &this->jsdl__JobDescription_USCOREType::Resources);
	soap_serialize_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(soap, &this->jsdl__JobDescription_USCOREType::DataStaging);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__JobDescription_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__JobDescription_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__JobDescription_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__JobDescription_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__JobDescription_USCOREType *a, const char *type)
{
	if (((jsdl__JobDescription_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__JobDescription_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__JobDescription_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTojsdl__JobIdentification_USCOREType(soap, "JobIdentification", -1, &(a->jsdl__JobDescription_USCOREType::JobIdentification), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Application_USCOREType(soap, "Application", -1, &(a->jsdl__JobDescription_USCOREType::Application), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Resources_USCOREType(soap, "Resources", -1, &(a->jsdl__JobDescription_USCOREType::Resources), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(soap, "DataStaging", -1, &(a->jsdl__JobDescription_USCOREType::DataStaging), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__JobDescription_USCOREType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__JobDescription_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__JobDescription_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__JobDescription_USCOREType * SOAP_FMAC4 soap_in_jsdl__JobDescription_USCOREType(struct soap *soap, const char *tag, jsdl__JobDescription_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__JobDescription_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__JobDescription_USCOREType, sizeof(jsdl__JobDescription_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdl__JobDescription_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__JobDescription_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__JobDescription_USCOREType*)a)->__anyAttribute, -1, -1))
		return NULL;
	size_t soap_flag_JobIdentification1 = 1;
	size_t soap_flag_Application1 = 1;
	size_t soap_flag_Resources1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobIdentification1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__JobIdentification_USCOREType(soap, "JobIdentification", &(a->jsdl__JobDescription_USCOREType::JobIdentification), "jsdl:JobIdentification_Type"))
				{	soap_flag_JobIdentification1--;
					continue;
				}
			if (soap_flag_Application1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Application_USCOREType(soap, "Application", &(a->jsdl__JobDescription_USCOREType::Application), "jsdl:Application_Type"))
				{	soap_flag_Application1--;
					continue;
				}
			if (soap_flag_Resources1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Resources_USCOREType(soap, "Resources", &(a->jsdl__JobDescription_USCOREType::Resources), "jsdl:Resources_Type"))
				{	soap_flag_Resources1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(soap, "DataStaging", &(a->jsdl__JobDescription_USCOREType::DataStaging), "jsdl:DataStaging_Type"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__JobDescription_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__JobDescription_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__JobDescription_USCOREType, 0, sizeof(jsdl__JobDescription_USCOREType), 0, soap_copy_jsdl__JobDescription_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int jsdl__JobDescription_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdl__JobDescription_USCOREType);
	if (this->soap_out(soap, tag?tag:"jsdl:JobDescription_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *jsdl__JobDescription_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__JobDescription_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__JobDescription_USCOREType * SOAP_FMAC4 soap_get_jsdl__JobDescription_USCOREType(struct soap *soap, jsdl__JobDescription_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__JobDescription_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 jsdl__JobDescription_USCOREType * SOAP_FMAC2 soap_instantiate_jsdl__JobDescription_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__JobDescription_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdl__JobDescription_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(jsdl__JobDescription_USCOREType);
		if (size)
			*size = sizeof(jsdl__JobDescription_USCOREType);
		((jsdl__JobDescription_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(jsdl__JobDescription_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__JobDescription_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__JobDescription_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__JobDescription_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__JobDescription_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__JobDescription_USCOREType %p -> %p\n", q, p));
	*(jsdl__JobDescription_USCOREType*)p = *(jsdl__JobDescription_USCOREType*)q;
}

void jsdl__JobDefinition_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__JobDefinition_USCOREType::JobDescription = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__JobDefinition_USCOREType::__any);
	this->jsdl__JobDefinition_USCOREType::id = NULL;
	this->jsdl__JobDefinition_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__JobDefinition_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__JobDescription_USCOREType(soap, &this->jsdl__JobDefinition_USCOREType::JobDescription);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__JobDefinition_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__JobDefinition_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__JobDefinition_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__JobDefinition_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__JobDefinition_USCOREType *a, const char *type)
{
	if (((jsdl__JobDefinition_USCOREType*)a)->id)
		soap_set_attr(soap, "id", ((jsdl__JobDefinition_USCOREType*)a)->id->c_str());
	if (((jsdl__JobDefinition_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__JobDefinition_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__JobDefinition_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTojsdl__JobDescription_USCOREType(soap, "JobDescription", -1, &(a->jsdl__JobDefinition_USCOREType::JobDescription), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__JobDefinition_USCOREType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__JobDefinition_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__JobDefinition_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__JobDefinition_USCOREType * SOAP_FMAC4 soap_in_jsdl__JobDefinition_USCOREType(struct soap *soap, const char *tag, jsdl__JobDefinition_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__JobDefinition_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__JobDefinition_USCOREType, sizeof(jsdl__JobDefinition_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdl__JobDefinition_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__JobDefinition_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "id", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s, -1, -1))
				return NULL;
			if (s)
			{	((jsdl__JobDefinition_USCOREType*)a)->id = soap_new_std__string(soap, -1);
				((jsdl__JobDefinition_USCOREType*)a)->id->assign(s);
			}
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__JobDefinition_USCOREType*)a)->__anyAttribute, -1, -1))
		return NULL;
	size_t soap_flag_JobDescription1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobDescription1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__JobDescription_USCOREType(soap, "JobDescription", &(a->jsdl__JobDefinition_USCOREType::JobDescription), "jsdl:JobDescription_Type"))
				{	soap_flag_JobDescription1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__JobDefinition_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__JobDefinition_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__JobDefinition_USCOREType, 0, sizeof(jsdl__JobDefinition_USCOREType), 0, soap_copy_jsdl__JobDefinition_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobDescription1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int jsdl__JobDefinition_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdl__JobDefinition_USCOREType);
	if (this->soap_out(soap, tag?tag:"jsdl:JobDefinition_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *jsdl__JobDefinition_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__JobDefinition_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__JobDefinition_USCOREType * SOAP_FMAC4 soap_get_jsdl__JobDefinition_USCOREType(struct soap *soap, jsdl__JobDefinition_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__JobDefinition_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 jsdl__JobDefinition_USCOREType * SOAP_FMAC2 soap_instantiate_jsdl__JobDefinition_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__JobDefinition_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdl__JobDefinition_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(jsdl__JobDefinition_USCOREType);
		if (size)
			*size = sizeof(jsdl__JobDefinition_USCOREType);
		((jsdl__JobDefinition_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(jsdl__JobDefinition_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__JobDefinition_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__JobDefinition_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__JobDefinition_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__JobDefinition_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__JobDefinition_USCOREType %p -> %p\n", q, p));
	*(jsdl__JobDefinition_USCOREType*)p = *(jsdl__JobDefinition_USCOREType*)q;
}

void jsdl__RangeValue_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__RangeValue_USCOREType::UpperBoundedRange = NULL;
	this->jsdl__RangeValue_USCOREType::LowerBoundedRange = NULL;
	soap_default_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(soap, &this->jsdl__RangeValue_USCOREType::Exact);
	soap_default_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(soap, &this->jsdl__RangeValue_USCOREType::Range);
	this->jsdl__RangeValue_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__RangeValue_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__Boundary_USCOREType(soap, &this->jsdl__RangeValue_USCOREType::UpperBoundedRange);
	soap_serialize_PointerTojsdl__Boundary_USCOREType(soap, &this->jsdl__RangeValue_USCOREType::LowerBoundedRange);
	soap_serialize_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(soap, &this->jsdl__RangeValue_USCOREType::Exact);
	soap_serialize_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(soap, &this->jsdl__RangeValue_USCOREType::Range);
	/* transient soap skipped */
}

int jsdl__RangeValue_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__RangeValue_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__RangeValue_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__RangeValue_USCOREType *a, const char *type)
{
	if (((jsdl__RangeValue_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__RangeValue_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__RangeValue_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "UpperBoundedRange", -1, &(a->jsdl__RangeValue_USCOREType::UpperBoundedRange), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "LowerBoundedRange", -1, &(a->jsdl__RangeValue_USCOREType::LowerBoundedRange), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(soap, "Exact", -1, &(a->jsdl__RangeValue_USCOREType::Exact), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(soap, "Range", -1, &(a->jsdl__RangeValue_USCOREType::Range), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__RangeValue_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__RangeValue_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in_jsdl__RangeValue_USCOREType(struct soap *soap, const char *tag, jsdl__RangeValue_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__RangeValue_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__RangeValue_USCOREType, sizeof(jsdl__RangeValue_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdl__RangeValue_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__RangeValue_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__RangeValue_USCOREType*)a)->__anyAttribute, -1, -1))
		return NULL;
	size_t soap_flag_UpperBoundedRange1 = 1;
	size_t soap_flag_LowerBoundedRange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpperBoundedRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "UpperBoundedRange", &(a->jsdl__RangeValue_USCOREType::UpperBoundedRange), "jsdl:Boundary_Type"))
				{	soap_flag_UpperBoundedRange1--;
					continue;
				}
			if (soap_flag_LowerBoundedRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "LowerBoundedRange", &(a->jsdl__RangeValue_USCOREType::LowerBoundedRange), "jsdl:Boundary_Type"))
				{	soap_flag_LowerBoundedRange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(soap, "Exact", &(a->jsdl__RangeValue_USCOREType::Exact), "jsdl:Exact_Type"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(soap, "Range", &(a->jsdl__RangeValue_USCOREType::Range), "jsdl:Range_Type"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__RangeValue_USCOREType, 0, sizeof(jsdl__RangeValue_USCOREType), 0, soap_copy_jsdl__RangeValue_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int jsdl__RangeValue_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdl__RangeValue_USCOREType);
	if (this->soap_out(soap, tag?tag:"jsdl:RangeValue_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *jsdl__RangeValue_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__RangeValue_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get_jsdl__RangeValue_USCOREType(struct soap *soap, jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__RangeValue_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 jsdl__RangeValue_USCOREType * SOAP_FMAC2 soap_instantiate_jsdl__RangeValue_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__RangeValue_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdl__RangeValue_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(jsdl__RangeValue_USCOREType);
		if (size)
			*size = sizeof(jsdl__RangeValue_USCOREType);
		((jsdl__RangeValue_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(jsdl__RangeValue_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__RangeValue_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__RangeValue_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__RangeValue_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__RangeValue_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__RangeValue_USCOREType %p -> %p\n", q, p));
	*(jsdl__RangeValue_USCOREType*)p = *(jsdl__RangeValue_USCOREType*)q;
}

void jsdl__Range_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__Range_USCOREType::LowerBound = NULL;
	this->jsdl__Range_USCOREType::UpperBound = NULL;
	this->jsdl__Range_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__Range_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__Boundary_USCOREType(soap, &this->jsdl__Range_USCOREType::LowerBound);
	soap_serialize_PointerTojsdl__Boundary_USCOREType(soap, &this->jsdl__Range_USCOREType::UpperBound);
	/* transient soap skipped */
}

int jsdl__Range_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__Range_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__Range_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__Range_USCOREType *a, const char *type)
{
	if (((jsdl__Range_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__Range_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__Range_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "LowerBound", -1, &(a->jsdl__Range_USCOREType::LowerBound), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "UpperBound", -1, &(a->jsdl__Range_USCOREType::UpperBound), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__Range_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__Range_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__Range_USCOREType * SOAP_FMAC4 soap_in_jsdl__Range_USCOREType(struct soap *soap, const char *tag, jsdl__Range_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__Range_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__Range_USCOREType, sizeof(jsdl__Range_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdl__Range_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__Range_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__Range_USCOREType*)a)->__anyAttribute, -1, -1))
		return NULL;
	size_t soap_flag_LowerBound1 = 1;
	size_t soap_flag_UpperBound1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LowerBound1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "LowerBound", &(a->jsdl__Range_USCOREType::LowerBound), "jsdl:Boundary_Type"))
				{	soap_flag_LowerBound1--;
					continue;
				}
			if (soap_flag_UpperBound1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "UpperBound", &(a->jsdl__Range_USCOREType::UpperBound), "jsdl:Boundary_Type"))
				{	soap_flag_UpperBound1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__Range_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__Range_USCOREType, 0, sizeof(jsdl__Range_USCOREType), 0, soap_copy_jsdl__Range_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LowerBound1 > 0 || soap_flag_UpperBound1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int jsdl__Range_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdl__Range_USCOREType);
	if (this->soap_out(soap, tag?tag:"jsdl:Range_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *jsdl__Range_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__Range_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__Range_USCOREType * SOAP_FMAC4 soap_get_jsdl__Range_USCOREType(struct soap *soap, jsdl__Range_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Range_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 jsdl__Range_USCOREType * SOAP_FMAC2 soap_instantiate_jsdl__Range_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__Range_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdl__Range_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(jsdl__Range_USCOREType);
		if (size)
			*size = sizeof(jsdl__Range_USCOREType);
		((jsdl__Range_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(jsdl__Range_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__Range_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__Range_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__Range_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__Range_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__Range_USCOREType %p -> %p\n", q, p));
	*(jsdl__Range_USCOREType*)p = *(jsdl__Range_USCOREType*)q;
}

void jsdl__Exact_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &this->jsdl__Exact_USCOREType::__item);
	this->jsdl__Exact_USCOREType::epsilon = NULL;
	this->jsdl__Exact_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__Exact_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->jsdl__Exact_USCOREType::__item, SOAP_TYPE_double);
	/* transient soap skipped */
}

int jsdl__Exact_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__Exact_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__Exact_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__Exact_USCOREType *a, const char *type)
{
	if (((jsdl__Exact_USCOREType*)a)->epsilon)
		soap_set_attr(soap, "epsilon", soap_double2s(soap, *((jsdl__Exact_USCOREType*)a)->epsilon));
	if (((jsdl__Exact_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__Exact_USCOREType*)a)->__anyAttribute);
	return soap_out_double(soap, tag, id, &a->jsdl__Exact_USCOREType::__item, "");
}

void *jsdl__Exact_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__Exact_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__Exact_USCOREType * SOAP_FMAC4 soap_in_jsdl__Exact_USCOREType(struct soap *soap, const char *tag, jsdl__Exact_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (jsdl__Exact_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__Exact_USCOREType, sizeof(jsdl__Exact_USCOREType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdl__Exact_USCOREType)
			return (jsdl__Exact_USCOREType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "epsilon", 0);
		if (t)
		{
			if (!(((jsdl__Exact_USCOREType*)a)->epsilon = (double *)soap_malloc(soap, sizeof(double))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2double(soap, t, ((jsdl__Exact_USCOREType*)a)->epsilon))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__Exact_USCOREType*)a)->__anyAttribute, -1, -1))
		return NULL;
	if (!soap_in_double(soap, tag, &(a->jsdl__Exact_USCOREType::__item), "jsdl:Exact_Type"))
		return NULL;
	return a;
}

int jsdl__Exact_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdl__Exact_USCOREType);
	if (this->soap_out(soap, tag?tag:"jsdl:Exact_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *jsdl__Exact_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__Exact_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__Exact_USCOREType * SOAP_FMAC4 soap_get_jsdl__Exact_USCOREType(struct soap *soap, jsdl__Exact_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Exact_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 jsdl__Exact_USCOREType * SOAP_FMAC2 soap_instantiate_jsdl__Exact_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__Exact_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdl__Exact_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(jsdl__Exact_USCOREType);
		if (size)
			*size = sizeof(jsdl__Exact_USCOREType);
		((jsdl__Exact_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(jsdl__Exact_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__Exact_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__Exact_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__Exact_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__Exact_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__Exact_USCOREType %p -> %p\n", q, p));
	*(jsdl__Exact_USCOREType*)p = *(jsdl__Exact_USCOREType*)q;
}

void jsdl__Boundary_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &this->jsdl__Boundary_USCOREType::__item);
	this->jsdl__Boundary_USCOREType::exclusiveBound = NULL;
	this->jsdl__Boundary_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__Boundary_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->jsdl__Boundary_USCOREType::__item, SOAP_TYPE_double);
	/* transient soap skipped */
}

int jsdl__Boundary_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__Boundary_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__Boundary_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__Boundary_USCOREType *a, const char *type)
{
	if (((jsdl__Boundary_USCOREType*)a)->exclusiveBound)
		soap_set_attr(soap, "exclusiveBound", soap_bool2s(soap, *((jsdl__Boundary_USCOREType*)a)->exclusiveBound));
	if (((jsdl__Boundary_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__Boundary_USCOREType*)a)->__anyAttribute);
	return soap_out_double(soap, tag, id, &a->jsdl__Boundary_USCOREType::__item, "");
}

void *jsdl__Boundary_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__Boundary_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__Boundary_USCOREType * SOAP_FMAC4 soap_in_jsdl__Boundary_USCOREType(struct soap *soap, const char *tag, jsdl__Boundary_USCOREType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (jsdl__Boundary_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__Boundary_USCOREType, sizeof(jsdl__Boundary_USCOREType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdl__Boundary_USCOREType)
			return (jsdl__Boundary_USCOREType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "exclusiveBound", 0);
		if (t)
		{
			if (!(((jsdl__Boundary_USCOREType*)a)->exclusiveBound = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((jsdl__Boundary_USCOREType*)a)->exclusiveBound))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__Boundary_USCOREType*)a)->__anyAttribute, -1, -1))
		return NULL;
	if (!soap_in_double(soap, tag, &(a->jsdl__Boundary_USCOREType::__item), "jsdl:Boundary_Type"))
		return NULL;
	return a;
}

int jsdl__Boundary_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdl__Boundary_USCOREType);
	if (this->soap_out(soap, tag?tag:"jsdl:Boundary_Type", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *jsdl__Boundary_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__Boundary_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__Boundary_USCOREType * SOAP_FMAC4 soap_get_jsdl__Boundary_USCOREType(struct soap *soap, jsdl__Boundary_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Boundary_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 jsdl__Boundary_USCOREType * SOAP_FMAC2 soap_instantiate_jsdl__Boundary_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__Boundary_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdl__Boundary_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(jsdl__Boundary_USCOREType);
		if (size)
			*size = sizeof(jsdl__Boundary_USCOREType);
		((jsdl__Boundary_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(jsdl__Boundary_USCOREType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__Boundary_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__Boundary_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__Boundary_USCOREType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__Boundary_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__Boundary_USCOREType %p -> %p\n", q, p));
	*(jsdl__Boundary_USCOREType*)p = *(jsdl__Boundary_USCOREType*)q;
}

void ns1__ServerOverloadedFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__BaseFaultType::methodName);
	soap_default_time(soap, &this->ns1__BaseFaultType::Timestamp);
	this->ns1__BaseFaultType::ErrorCode = NULL;
	this->ns1__BaseFaultType::Description = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

void ns1__ServerOverloadedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__BaseFaultType::methodName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__BaseFaultType::methodName);
	soap_serialize_PointerTostd__string(soap, &this->ns1__BaseFaultType::ErrorCode);
	soap_serialize_PointerTostd__string(soap, &this->ns1__BaseFaultType::Description);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

int ns1__ServerOverloadedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ServerOverloadedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ServerOverloadedFaultType(struct soap *soap, const char *tag, int id, const ns1__ServerOverloadedFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ServerOverloadedFaultType), "ns1:ServerOverloadedFaultType"))
		return soap->error;
	if (soap_out_std__string(soap, "methodName", -1, &(a->ns1__BaseFaultType::methodName), ""))
		return soap->error;
	if (soap_out_time(soap, "Timestamp", -1, &(a->ns1__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ErrorCode", -1, &(a->ns1__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Description", -1, &(a->ns1__BaseFaultType::Description), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "FaultCause", -1, &(a->ns1__BaseFaultType::FaultCause), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ServerOverloadedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ServerOverloadedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ServerOverloadedFaultType * SOAP_FMAC4 soap_in_ns1__ServerOverloadedFaultType(struct soap *soap, const char *tag, ns1__ServerOverloadedFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ServerOverloadedFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ServerOverloadedFaultType, sizeof(ns1__ServerOverloadedFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ServerOverloadedFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ServerOverloadedFaultType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_methodName2 = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_Description2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_methodName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "methodName", &(a->ns1__BaseFaultType::methodName), "xsd:string"))
				{	soap_flag_methodName2--;
					continue;
				}
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "Timestamp", &(a->ns1__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			if (soap_flag_ErrorCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ErrorCode", &(a->ns1__BaseFaultType::ErrorCode), "xsd:string"))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			if (soap_flag_Description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Description", &(a->ns1__BaseFaultType::Description), "xsd:string"))
				{	soap_flag_Description2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "FaultCause", &(a->ns1__BaseFaultType::FaultCause), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ServerOverloadedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ServerOverloadedFaultType, 0, sizeof(ns1__ServerOverloadedFaultType), 0, soap_copy_ns1__ServerOverloadedFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_methodName2 > 0 || soap_flag_Timestamp2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__ServerOverloadedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ServerOverloadedFaultType);
	if (this->soap_out(soap, tag?tag:"ns1:ServerOverloadedFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ServerOverloadedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ServerOverloadedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ServerOverloadedFaultType * SOAP_FMAC4 soap_get_ns1__ServerOverloadedFaultType(struct soap *soap, ns1__ServerOverloadedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ServerOverloadedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ServerOverloadedFaultType * SOAP_FMAC2 soap_instantiate_ns1__ServerOverloadedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ServerOverloadedFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ServerOverloadedFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ServerOverloadedFaultType);
		if (size)
			*size = sizeof(ns1__ServerOverloadedFaultType);
		((ns1__ServerOverloadedFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ServerOverloadedFaultType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ServerOverloadedFaultType);
		for (int i = 0; i < n; i++)
			((ns1__ServerOverloadedFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ServerOverloadedFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ServerOverloadedFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ServerOverloadedFaultType %p -> %p\n", q, p));
	*(ns1__ServerOverloadedFaultType*)p = *(ns1__ServerOverloadedFaultType*)q;
}

void ns1__OperationNotAllowedFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__BaseFaultType::methodName);
	soap_default_time(soap, &this->ns1__BaseFaultType::Timestamp);
	this->ns1__BaseFaultType::ErrorCode = NULL;
	this->ns1__BaseFaultType::Description = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

void ns1__OperationNotAllowedFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__BaseFaultType::methodName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__BaseFaultType::methodName);
	soap_serialize_PointerTostd__string(soap, &this->ns1__BaseFaultType::ErrorCode);
	soap_serialize_PointerTostd__string(soap, &this->ns1__BaseFaultType::Description);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

int ns1__OperationNotAllowedFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__OperationNotAllowedFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__OperationNotAllowedFaultType(struct soap *soap, const char *tag, int id, const ns1__OperationNotAllowedFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__OperationNotAllowedFaultType), "ns1:OperationNotAllowedFaultType"))
		return soap->error;
	if (soap_out_std__string(soap, "methodName", -1, &(a->ns1__BaseFaultType::methodName), ""))
		return soap->error;
	if (soap_out_time(soap, "Timestamp", -1, &(a->ns1__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ErrorCode", -1, &(a->ns1__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Description", -1, &(a->ns1__BaseFaultType::Description), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "FaultCause", -1, &(a->ns1__BaseFaultType::FaultCause), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__OperationNotAllowedFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__OperationNotAllowedFaultType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__OperationNotAllowedFaultType * SOAP_FMAC4 soap_in_ns1__OperationNotAllowedFaultType(struct soap *soap, const char *tag, ns1__OperationNotAllowedFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__OperationNotAllowedFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__OperationNotAllowedFaultType, sizeof(ns1__OperationNotAllowedFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__OperationNotAllowedFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__OperationNotAllowedFaultType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_methodName2 = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_Description2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_methodName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "methodName", &(a->ns1__BaseFaultType::methodName), "xsd:string"))
				{	soap_flag_methodName2--;
					continue;
				}
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "Timestamp", &(a->ns1__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			if (soap_flag_ErrorCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ErrorCode", &(a->ns1__BaseFaultType::ErrorCode), "xsd:string"))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			if (soap_flag_Description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Description", &(a->ns1__BaseFaultType::Description), "xsd:string"))
				{	soap_flag_Description2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "FaultCause", &(a->ns1__BaseFaultType::FaultCause), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__OperationNotAllowedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__OperationNotAllowedFaultType, 0, sizeof(ns1__OperationNotAllowedFaultType), 0, soap_copy_ns1__OperationNotAllowedFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_methodName2 > 0 || soap_flag_Timestamp2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__OperationNotAllowedFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__OperationNotAllowedFaultType);
	if (this->soap_out(soap, tag?tag:"ns1:OperationNotAllowedFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__OperationNotAllowedFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__OperationNotAllowedFaultType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__OperationNotAllowedFaultType * SOAP_FMAC4 soap_get_ns1__OperationNotAllowedFaultType(struct soap *soap, ns1__OperationNotAllowedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__OperationNotAllowedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__OperationNotAllowedFaultType * SOAP_FMAC2 soap_instantiate_ns1__OperationNotAllowedFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__OperationNotAllowedFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__OperationNotAllowedFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__OperationNotAllowedFaultType);
		if (size)
			*size = sizeof(ns1__OperationNotAllowedFaultType);
		((ns1__OperationNotAllowedFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__OperationNotAllowedFaultType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__OperationNotAllowedFaultType);
		for (int i = 0; i < n; i++)
			((ns1__OperationNotAllowedFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__OperationNotAllowedFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__OperationNotAllowedFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__OperationNotAllowedFaultType %p -> %p\n", q, p));
	*(ns1__OperationNotAllowedFaultType*)p = *(ns1__OperationNotAllowedFaultType*)q;
}

void ns1__JobUnknownFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__BaseFaultType::methodName);
	soap_default_time(soap, &this->ns1__BaseFaultType::Timestamp);
	this->ns1__BaseFaultType::ErrorCode = NULL;
	this->ns1__BaseFaultType::Description = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

void ns1__JobUnknownFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__BaseFaultType::methodName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__BaseFaultType::methodName);
	soap_serialize_PointerTostd__string(soap, &this->ns1__BaseFaultType::ErrorCode);
	soap_serialize_PointerTostd__string(soap, &this->ns1__BaseFaultType::Description);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

int ns1__JobUnknownFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__JobUnknownFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__JobUnknownFaultType(struct soap *soap, const char *tag, int id, const ns1__JobUnknownFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__JobUnknownFaultType), "ns1:JobUnknownFaultType"))
		return soap->error;
	if (soap_out_std__string(soap, "methodName", -1, &(a->ns1__BaseFaultType::methodName), ""))
		return soap->error;
	if (soap_out_time(soap, "Timestamp", -1, &(a->ns1__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ErrorCode", -1, &(a->ns1__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Description", -1, &(a->ns1__BaseFaultType::Description), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "FaultCause", -1, &(a->ns1__BaseFaultType::FaultCause), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__JobUnknownFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__JobUnknownFaultType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__JobUnknownFaultType * SOAP_FMAC4 soap_in_ns1__JobUnknownFaultType(struct soap *soap, const char *tag, ns1__JobUnknownFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__JobUnknownFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__JobUnknownFaultType, sizeof(ns1__JobUnknownFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__JobUnknownFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__JobUnknownFaultType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_methodName2 = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_Description2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_methodName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "methodName", &(a->ns1__BaseFaultType::methodName), "xsd:string"))
				{	soap_flag_methodName2--;
					continue;
				}
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "Timestamp", &(a->ns1__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			if (soap_flag_ErrorCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ErrorCode", &(a->ns1__BaseFaultType::ErrorCode), "xsd:string"))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			if (soap_flag_Description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Description", &(a->ns1__BaseFaultType::Description), "xsd:string"))
				{	soap_flag_Description2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "FaultCause", &(a->ns1__BaseFaultType::FaultCause), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__JobUnknownFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__JobUnknownFaultType, 0, sizeof(ns1__JobUnknownFaultType), 0, soap_copy_ns1__JobUnknownFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_methodName2 > 0 || soap_flag_Timestamp2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__JobUnknownFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__JobUnknownFaultType);
	if (this->soap_out(soap, tag?tag:"ns1:JobUnknownFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__JobUnknownFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__JobUnknownFaultType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__JobUnknownFaultType * SOAP_FMAC4 soap_get_ns1__JobUnknownFaultType(struct soap *soap, ns1__JobUnknownFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__JobUnknownFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__JobUnknownFaultType * SOAP_FMAC2 soap_instantiate_ns1__JobUnknownFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__JobUnknownFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__JobUnknownFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__JobUnknownFaultType);
		if (size)
			*size = sizeof(ns1__JobUnknownFaultType);
		((ns1__JobUnknownFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__JobUnknownFaultType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__JobUnknownFaultType);
		for (int i = 0; i < n; i++)
			((ns1__JobUnknownFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__JobUnknownFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__JobUnknownFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__JobUnknownFaultType %p -> %p\n", q, p));
	*(ns1__JobUnknownFaultType*)p = *(ns1__JobUnknownFaultType*)q;
}

void ns1__NoSuitableResourcesFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__BaseFaultType::methodName);
	soap_default_time(soap, &this->ns1__BaseFaultType::Timestamp);
	this->ns1__BaseFaultType::ErrorCode = NULL;
	this->ns1__BaseFaultType::Description = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

void ns1__NoSuitableResourcesFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__BaseFaultType::methodName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__BaseFaultType::methodName);
	soap_serialize_PointerTostd__string(soap, &this->ns1__BaseFaultType::ErrorCode);
	soap_serialize_PointerTostd__string(soap, &this->ns1__BaseFaultType::Description);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

int ns1__NoSuitableResourcesFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__NoSuitableResourcesFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NoSuitableResourcesFaultType(struct soap *soap, const char *tag, int id, const ns1__NoSuitableResourcesFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__NoSuitableResourcesFaultType), "ns1:NoSuitableResourcesFaultType"))
		return soap->error;
	if (soap_out_std__string(soap, "methodName", -1, &(a->ns1__BaseFaultType::methodName), ""))
		return soap->error;
	if (soap_out_time(soap, "Timestamp", -1, &(a->ns1__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ErrorCode", -1, &(a->ns1__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Description", -1, &(a->ns1__BaseFaultType::Description), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "FaultCause", -1, &(a->ns1__BaseFaultType::FaultCause), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__NoSuitableResourcesFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__NoSuitableResourcesFaultType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__NoSuitableResourcesFaultType * SOAP_FMAC4 soap_in_ns1__NoSuitableResourcesFaultType(struct soap *soap, const char *tag, ns1__NoSuitableResourcesFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__NoSuitableResourcesFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NoSuitableResourcesFaultType, sizeof(ns1__NoSuitableResourcesFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__NoSuitableResourcesFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__NoSuitableResourcesFaultType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_methodName2 = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_Description2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_methodName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "methodName", &(a->ns1__BaseFaultType::methodName), "xsd:string"))
				{	soap_flag_methodName2--;
					continue;
				}
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "Timestamp", &(a->ns1__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			if (soap_flag_ErrorCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ErrorCode", &(a->ns1__BaseFaultType::ErrorCode), "xsd:string"))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			if (soap_flag_Description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Description", &(a->ns1__BaseFaultType::Description), "xsd:string"))
				{	soap_flag_Description2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "FaultCause", &(a->ns1__BaseFaultType::FaultCause), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__NoSuitableResourcesFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__NoSuitableResourcesFaultType, 0, sizeof(ns1__NoSuitableResourcesFaultType), 0, soap_copy_ns1__NoSuitableResourcesFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_methodName2 > 0 || soap_flag_Timestamp2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__NoSuitableResourcesFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__NoSuitableResourcesFaultType);
	if (this->soap_out(soap, tag?tag:"ns1:NoSuitableResourcesFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__NoSuitableResourcesFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__NoSuitableResourcesFaultType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__NoSuitableResourcesFaultType * SOAP_FMAC4 soap_get_ns1__NoSuitableResourcesFaultType(struct soap *soap, ns1__NoSuitableResourcesFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NoSuitableResourcesFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__NoSuitableResourcesFaultType * SOAP_FMAC2 soap_instantiate_ns1__NoSuitableResourcesFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__NoSuitableResourcesFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__NoSuitableResourcesFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__NoSuitableResourcesFaultType);
		if (size)
			*size = sizeof(ns1__NoSuitableResourcesFaultType);
		((ns1__NoSuitableResourcesFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__NoSuitableResourcesFaultType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__NoSuitableResourcesFaultType);
		for (int i = 0; i < n; i++)
			((ns1__NoSuitableResourcesFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__NoSuitableResourcesFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__NoSuitableResourcesFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__NoSuitableResourcesFaultType %p -> %p\n", q, p));
	*(ns1__NoSuitableResourcesFaultType*)p = *(ns1__NoSuitableResourcesFaultType*)q;
}

void ns1__GetQuotaManagementFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__BaseFaultType::methodName);
	soap_default_time(soap, &this->ns1__BaseFaultType::Timestamp);
	this->ns1__BaseFaultType::ErrorCode = NULL;
	this->ns1__BaseFaultType::Description = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

void ns1__GetQuotaManagementFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__BaseFaultType::methodName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__BaseFaultType::methodName);
	soap_serialize_PointerTostd__string(soap, &this->ns1__BaseFaultType::ErrorCode);
	soap_serialize_PointerTostd__string(soap, &this->ns1__BaseFaultType::Description);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

int ns1__GetQuotaManagementFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GetQuotaManagementFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetQuotaManagementFaultType(struct soap *soap, const char *tag, int id, const ns1__GetQuotaManagementFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetQuotaManagementFaultType), "ns1:GetQuotaManagementFaultType"))
		return soap->error;
	if (soap_out_std__string(soap, "methodName", -1, &(a->ns1__BaseFaultType::methodName), ""))
		return soap->error;
	if (soap_out_time(soap, "Timestamp", -1, &(a->ns1__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ErrorCode", -1, &(a->ns1__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Description", -1, &(a->ns1__BaseFaultType::Description), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "FaultCause", -1, &(a->ns1__BaseFaultType::FaultCause), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__GetQuotaManagementFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__GetQuotaManagementFaultType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GetQuotaManagementFaultType * SOAP_FMAC4 soap_in_ns1__GetQuotaManagementFaultType(struct soap *soap, const char *tag, ns1__GetQuotaManagementFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GetQuotaManagementFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetQuotaManagementFaultType, sizeof(ns1__GetQuotaManagementFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__GetQuotaManagementFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__GetQuotaManagementFaultType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_methodName2 = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_Description2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_methodName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "methodName", &(a->ns1__BaseFaultType::methodName), "xsd:string"))
				{	soap_flag_methodName2--;
					continue;
				}
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "Timestamp", &(a->ns1__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			if (soap_flag_ErrorCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ErrorCode", &(a->ns1__BaseFaultType::ErrorCode), "xsd:string"))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			if (soap_flag_Description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Description", &(a->ns1__BaseFaultType::Description), "xsd:string"))
				{	soap_flag_Description2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "FaultCause", &(a->ns1__BaseFaultType::FaultCause), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__GetQuotaManagementFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetQuotaManagementFaultType, 0, sizeof(ns1__GetQuotaManagementFaultType), 0, soap_copy_ns1__GetQuotaManagementFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_methodName2 > 0 || soap_flag_Timestamp2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__GetQuotaManagementFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__GetQuotaManagementFaultType);
	if (this->soap_out(soap, tag?tag:"ns1:GetQuotaManagementFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__GetQuotaManagementFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GetQuotaManagementFaultType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GetQuotaManagementFaultType * SOAP_FMAC4 soap_get_ns1__GetQuotaManagementFaultType(struct soap *soap, ns1__GetQuotaManagementFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetQuotaManagementFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__GetQuotaManagementFaultType * SOAP_FMAC2 soap_instantiate_ns1__GetQuotaManagementFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetQuotaManagementFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GetQuotaManagementFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__GetQuotaManagementFaultType);
		if (size)
			*size = sizeof(ns1__GetQuotaManagementFaultType);
		((ns1__GetQuotaManagementFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__GetQuotaManagementFaultType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__GetQuotaManagementFaultType);
		for (int i = 0; i < n; i++)
			((ns1__GetQuotaManagementFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__GetQuotaManagementFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GetQuotaManagementFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__GetQuotaManagementFaultType %p -> %p\n", q, p));
	*(ns1__GetQuotaManagementFaultType*)p = *(ns1__GetQuotaManagementFaultType*)q;
}

void ns1__InvalidArgumentFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__BaseFaultType::methodName);
	soap_default_time(soap, &this->ns1__BaseFaultType::Timestamp);
	this->ns1__BaseFaultType::ErrorCode = NULL;
	this->ns1__BaseFaultType::Description = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

void ns1__InvalidArgumentFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__BaseFaultType::methodName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__BaseFaultType::methodName);
	soap_serialize_PointerTostd__string(soap, &this->ns1__BaseFaultType::ErrorCode);
	soap_serialize_PointerTostd__string(soap, &this->ns1__BaseFaultType::Description);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

int ns1__InvalidArgumentFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__InvalidArgumentFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__InvalidArgumentFaultType(struct soap *soap, const char *tag, int id, const ns1__InvalidArgumentFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__InvalidArgumentFaultType), "ns1:InvalidArgumentFaultType"))
		return soap->error;
	if (soap_out_std__string(soap, "methodName", -1, &(a->ns1__BaseFaultType::methodName), ""))
		return soap->error;
	if (soap_out_time(soap, "Timestamp", -1, &(a->ns1__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ErrorCode", -1, &(a->ns1__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Description", -1, &(a->ns1__BaseFaultType::Description), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "FaultCause", -1, &(a->ns1__BaseFaultType::FaultCause), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__InvalidArgumentFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__InvalidArgumentFaultType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__InvalidArgumentFaultType * SOAP_FMAC4 soap_in_ns1__InvalidArgumentFaultType(struct soap *soap, const char *tag, ns1__InvalidArgumentFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__InvalidArgumentFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__InvalidArgumentFaultType, sizeof(ns1__InvalidArgumentFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__InvalidArgumentFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__InvalidArgumentFaultType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_methodName2 = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_Description2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_methodName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "methodName", &(a->ns1__BaseFaultType::methodName), "xsd:string"))
				{	soap_flag_methodName2--;
					continue;
				}
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "Timestamp", &(a->ns1__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			if (soap_flag_ErrorCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ErrorCode", &(a->ns1__BaseFaultType::ErrorCode), "xsd:string"))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			if (soap_flag_Description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Description", &(a->ns1__BaseFaultType::Description), "xsd:string"))
				{	soap_flag_Description2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "FaultCause", &(a->ns1__BaseFaultType::FaultCause), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__InvalidArgumentFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__InvalidArgumentFaultType, 0, sizeof(ns1__InvalidArgumentFaultType), 0, soap_copy_ns1__InvalidArgumentFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_methodName2 > 0 || soap_flag_Timestamp2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__InvalidArgumentFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__InvalidArgumentFaultType);
	if (this->soap_out(soap, tag?tag:"ns1:InvalidArgumentFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__InvalidArgumentFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__InvalidArgumentFaultType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__InvalidArgumentFaultType * SOAP_FMAC4 soap_get_ns1__InvalidArgumentFaultType(struct soap *soap, ns1__InvalidArgumentFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__InvalidArgumentFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__InvalidArgumentFaultType * SOAP_FMAC2 soap_instantiate_ns1__InvalidArgumentFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__InvalidArgumentFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__InvalidArgumentFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__InvalidArgumentFaultType);
		if (size)
			*size = sizeof(ns1__InvalidArgumentFaultType);
		((ns1__InvalidArgumentFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__InvalidArgumentFaultType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__InvalidArgumentFaultType);
		for (int i = 0; i < n; i++)
			((ns1__InvalidArgumentFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__InvalidArgumentFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__InvalidArgumentFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__InvalidArgumentFaultType %p -> %p\n", q, p));
	*(ns1__InvalidArgumentFaultType*)p = *(ns1__InvalidArgumentFaultType*)q;
}

void ns1__AuthorizationFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__BaseFaultType::methodName);
	soap_default_time(soap, &this->ns1__BaseFaultType::Timestamp);
	this->ns1__BaseFaultType::ErrorCode = NULL;
	this->ns1__BaseFaultType::Description = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

void ns1__AuthorizationFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__BaseFaultType::methodName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__BaseFaultType::methodName);
	soap_serialize_PointerTostd__string(soap, &this->ns1__BaseFaultType::ErrorCode);
	soap_serialize_PointerTostd__string(soap, &this->ns1__BaseFaultType::Description);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

int ns1__AuthorizationFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AuthorizationFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AuthorizationFaultType(struct soap *soap, const char *tag, int id, const ns1__AuthorizationFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AuthorizationFaultType), "ns1:AuthorizationFaultType"))
		return soap->error;
	if (soap_out_std__string(soap, "methodName", -1, &(a->ns1__BaseFaultType::methodName), ""))
		return soap->error;
	if (soap_out_time(soap, "Timestamp", -1, &(a->ns1__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ErrorCode", -1, &(a->ns1__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Description", -1, &(a->ns1__BaseFaultType::Description), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "FaultCause", -1, &(a->ns1__BaseFaultType::FaultCause), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__AuthorizationFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AuthorizationFaultType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AuthorizationFaultType * SOAP_FMAC4 soap_in_ns1__AuthorizationFaultType(struct soap *soap, const char *tag, ns1__AuthorizationFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AuthorizationFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AuthorizationFaultType, sizeof(ns1__AuthorizationFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__AuthorizationFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__AuthorizationFaultType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_methodName2 = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_Description2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_methodName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "methodName", &(a->ns1__BaseFaultType::methodName), "xsd:string"))
				{	soap_flag_methodName2--;
					continue;
				}
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "Timestamp", &(a->ns1__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			if (soap_flag_ErrorCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ErrorCode", &(a->ns1__BaseFaultType::ErrorCode), "xsd:string"))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			if (soap_flag_Description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Description", &(a->ns1__BaseFaultType::Description), "xsd:string"))
				{	soap_flag_Description2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "FaultCause", &(a->ns1__BaseFaultType::FaultCause), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__AuthorizationFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AuthorizationFaultType, 0, sizeof(ns1__AuthorizationFaultType), 0, soap_copy_ns1__AuthorizationFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_methodName2 > 0 || soap_flag_Timestamp2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__AuthorizationFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__AuthorizationFaultType);
	if (this->soap_out(soap, tag?tag:"ns1:AuthorizationFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__AuthorizationFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AuthorizationFaultType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AuthorizationFaultType * SOAP_FMAC4 soap_get_ns1__AuthorizationFaultType(struct soap *soap, ns1__AuthorizationFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AuthorizationFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__AuthorizationFaultType * SOAP_FMAC2 soap_instantiate_ns1__AuthorizationFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AuthorizationFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AuthorizationFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__AuthorizationFaultType);
		if (size)
			*size = sizeof(ns1__AuthorizationFaultType);
		((ns1__AuthorizationFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__AuthorizationFaultType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__AuthorizationFaultType);
		for (int i = 0; i < n; i++)
			((ns1__AuthorizationFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__AuthorizationFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AuthorizationFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__AuthorizationFaultType %p -> %p\n", q, p));
	*(ns1__AuthorizationFaultType*)p = *(ns1__AuthorizationFaultType*)q;
}

void ns1__AuthenticationFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__BaseFaultType::methodName);
	soap_default_time(soap, &this->ns1__BaseFaultType::Timestamp);
	this->ns1__BaseFaultType::ErrorCode = NULL;
	this->ns1__BaseFaultType::Description = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

void ns1__AuthenticationFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__BaseFaultType::methodName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__BaseFaultType::methodName);
	soap_serialize_PointerTostd__string(soap, &this->ns1__BaseFaultType::ErrorCode);
	soap_serialize_PointerTostd__string(soap, &this->ns1__BaseFaultType::Description);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

int ns1__AuthenticationFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AuthenticationFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AuthenticationFaultType(struct soap *soap, const char *tag, int id, const ns1__AuthenticationFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AuthenticationFaultType), "ns1:AuthenticationFaultType"))
		return soap->error;
	if (soap_out_std__string(soap, "methodName", -1, &(a->ns1__BaseFaultType::methodName), ""))
		return soap->error;
	if (soap_out_time(soap, "Timestamp", -1, &(a->ns1__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ErrorCode", -1, &(a->ns1__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Description", -1, &(a->ns1__BaseFaultType::Description), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "FaultCause", -1, &(a->ns1__BaseFaultType::FaultCause), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__AuthenticationFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AuthenticationFaultType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AuthenticationFaultType * SOAP_FMAC4 soap_in_ns1__AuthenticationFaultType(struct soap *soap, const char *tag, ns1__AuthenticationFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AuthenticationFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AuthenticationFaultType, sizeof(ns1__AuthenticationFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__AuthenticationFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__AuthenticationFaultType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_methodName2 = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_Description2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_methodName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "methodName", &(a->ns1__BaseFaultType::methodName), "xsd:string"))
				{	soap_flag_methodName2--;
					continue;
				}
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "Timestamp", &(a->ns1__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			if (soap_flag_ErrorCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ErrorCode", &(a->ns1__BaseFaultType::ErrorCode), "xsd:string"))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			if (soap_flag_Description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Description", &(a->ns1__BaseFaultType::Description), "xsd:string"))
				{	soap_flag_Description2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "FaultCause", &(a->ns1__BaseFaultType::FaultCause), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__AuthenticationFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AuthenticationFaultType, 0, sizeof(ns1__AuthenticationFaultType), 0, soap_copy_ns1__AuthenticationFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_methodName2 > 0 || soap_flag_Timestamp2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__AuthenticationFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__AuthenticationFaultType);
	if (this->soap_out(soap, tag?tag:"ns1:AuthenticationFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__AuthenticationFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AuthenticationFaultType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AuthenticationFaultType * SOAP_FMAC4 soap_get_ns1__AuthenticationFaultType(struct soap *soap, ns1__AuthenticationFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AuthenticationFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__AuthenticationFaultType * SOAP_FMAC2 soap_instantiate_ns1__AuthenticationFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AuthenticationFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AuthenticationFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__AuthenticationFaultType);
		if (size)
			*size = sizeof(ns1__AuthenticationFaultType);
		((ns1__AuthenticationFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__AuthenticationFaultType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__AuthenticationFaultType);
		for (int i = 0; i < n; i++)
			((ns1__AuthenticationFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__AuthenticationFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AuthenticationFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__AuthenticationFaultType %p -> %p\n", q, p));
	*(ns1__AuthenticationFaultType*)p = *(ns1__AuthenticationFaultType*)q;
}

void ns1__GenericFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__BaseFaultType::methodName);
	soap_default_time(soap, &this->ns1__BaseFaultType::Timestamp);
	this->ns1__BaseFaultType::ErrorCode = NULL;
	this->ns1__BaseFaultType::Description = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

void ns1__GenericFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__BaseFaultType::methodName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__BaseFaultType::methodName);
	soap_serialize_PointerTostd__string(soap, &this->ns1__BaseFaultType::ErrorCode);
	soap_serialize_PointerTostd__string(soap, &this->ns1__BaseFaultType::Description);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

int ns1__GenericFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GenericFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GenericFaultType(struct soap *soap, const char *tag, int id, const ns1__GenericFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GenericFaultType), "ns1:GenericFaultType"))
		return soap->error;
	if (soap_out_std__string(soap, "methodName", -1, &(a->ns1__BaseFaultType::methodName), ""))
		return soap->error;
	if (soap_out_time(soap, "Timestamp", -1, &(a->ns1__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ErrorCode", -1, &(a->ns1__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Description", -1, &(a->ns1__BaseFaultType::Description), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "FaultCause", -1, &(a->ns1__BaseFaultType::FaultCause), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__GenericFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__GenericFaultType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GenericFaultType * SOAP_FMAC4 soap_in_ns1__GenericFaultType(struct soap *soap, const char *tag, ns1__GenericFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GenericFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GenericFaultType, sizeof(ns1__GenericFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__GenericFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__GenericFaultType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_methodName2 = 1;
	size_t soap_flag_Timestamp2 = 1;
	size_t soap_flag_ErrorCode2 = 1;
	size_t soap_flag_Description2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_methodName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "methodName", &(a->ns1__BaseFaultType::methodName), "xsd:string"))
				{	soap_flag_methodName2--;
					continue;
				}
			if (soap_flag_Timestamp2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "Timestamp", &(a->ns1__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp2--;
					continue;
				}
			if (soap_flag_ErrorCode2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ErrorCode", &(a->ns1__BaseFaultType::ErrorCode), "xsd:string"))
				{	soap_flag_ErrorCode2--;
					continue;
				}
			if (soap_flag_Description2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Description", &(a->ns1__BaseFaultType::Description), "xsd:string"))
				{	soap_flag_Description2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "FaultCause", &(a->ns1__BaseFaultType::FaultCause), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__GenericFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GenericFaultType, 0, sizeof(ns1__GenericFaultType), 0, soap_copy_ns1__GenericFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_methodName2 > 0 || soap_flag_Timestamp2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__GenericFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__GenericFaultType);
	if (this->soap_out(soap, tag?tag:"ns1:GenericFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__GenericFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GenericFaultType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GenericFaultType * SOAP_FMAC4 soap_get_ns1__GenericFaultType(struct soap *soap, ns1__GenericFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GenericFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__GenericFaultType * SOAP_FMAC2 soap_instantiate_ns1__GenericFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GenericFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GenericFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__GenericFaultType);
		if (size)
			*size = sizeof(ns1__GenericFaultType);
		((ns1__GenericFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__GenericFaultType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__GenericFaultType);
		for (int i = 0; i < n; i++)
			((ns1__GenericFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__GenericFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GenericFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__GenericFaultType %p -> %p\n", q, p));
	*(ns1__GenericFaultType*)p = *(ns1__GenericFaultType*)q;
}

void ns1__BaseFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__BaseFaultType::methodName);
	soap_default_time(soap, &this->ns1__BaseFaultType::Timestamp);
	this->ns1__BaseFaultType::ErrorCode = NULL;
	this->ns1__BaseFaultType::Description = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

void ns1__BaseFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__BaseFaultType::methodName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__BaseFaultType::methodName);
	soap_serialize_PointerTostd__string(soap, &this->ns1__BaseFaultType::ErrorCode);
	soap_serialize_PointerTostd__string(soap, &this->ns1__BaseFaultType::Description);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__BaseFaultType::FaultCause);
	/* transient soap skipped */
}

int ns1__BaseFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__BaseFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BaseFaultType(struct soap *soap, const char *tag, int id, const ns1__BaseFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BaseFaultType), type))
		return soap->error;
	if (soap_out_std__string(soap, "methodName", -1, &(a->ns1__BaseFaultType::methodName), ""))
		return soap->error;
	if (soap_out_time(soap, "Timestamp", -1, &(a->ns1__BaseFaultType::Timestamp), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ErrorCode", -1, &(a->ns1__BaseFaultType::ErrorCode), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "Description", -1, &(a->ns1__BaseFaultType::Description), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "FaultCause", -1, &(a->ns1__BaseFaultType::FaultCause), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__BaseFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__BaseFaultType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__BaseFaultType * SOAP_FMAC4 soap_in_ns1__BaseFaultType(struct soap *soap, const char *tag, ns1__BaseFaultType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__BaseFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BaseFaultType, sizeof(ns1__BaseFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__BaseFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__BaseFaultType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_methodName1 = 1;
	size_t soap_flag_Timestamp1 = 1;
	size_t soap_flag_ErrorCode1 = 1;
	size_t soap_flag_Description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_methodName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "methodName", &(a->ns1__BaseFaultType::methodName), "xsd:string"))
				{	soap_flag_methodName1--;
					continue;
				}
			if (soap_flag_Timestamp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "Timestamp", &(a->ns1__BaseFaultType::Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp1--;
					continue;
				}
			if (soap_flag_ErrorCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ErrorCode", &(a->ns1__BaseFaultType::ErrorCode), "xsd:string"))
				{	soap_flag_ErrorCode1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "Description", &(a->ns1__BaseFaultType::Description), "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "FaultCause", &(a->ns1__BaseFaultType::FaultCause), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__BaseFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BaseFaultType, 0, sizeof(ns1__BaseFaultType), 0, soap_copy_ns1__BaseFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_methodName1 > 0 || soap_flag_Timestamp1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__BaseFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__BaseFaultType);
	if (this->soap_out(soap, tag?tag:"ns1:BaseFaultType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__BaseFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__BaseFaultType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__BaseFaultType * SOAP_FMAC4 soap_get_ns1__BaseFaultType(struct soap *soap, ns1__BaseFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BaseFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__BaseFaultType * SOAP_FMAC2 soap_instantiate_ns1__BaseFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__BaseFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__BaseFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns1:GenericFaultType"))
	{	cp->type = SOAP_TYPE_ns1__GenericFaultType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__GenericFaultType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__GenericFaultType);
			((ns1__GenericFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__GenericFaultType[n]);
			if (size)
				*size = n * sizeof(ns1__GenericFaultType);
			for (int i = 0; i < n; i++)
				((ns1__GenericFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__GenericFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:AuthenticationFaultType"))
	{	cp->type = SOAP_TYPE_ns1__AuthenticationFaultType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__AuthenticationFaultType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__AuthenticationFaultType);
			((ns1__AuthenticationFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__AuthenticationFaultType[n]);
			if (size)
				*size = n * sizeof(ns1__AuthenticationFaultType);
			for (int i = 0; i < n; i++)
				((ns1__AuthenticationFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__AuthenticationFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:AuthorizationFaultType"))
	{	cp->type = SOAP_TYPE_ns1__AuthorizationFaultType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__AuthorizationFaultType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__AuthorizationFaultType);
			((ns1__AuthorizationFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__AuthorizationFaultType[n]);
			if (size)
				*size = n * sizeof(ns1__AuthorizationFaultType);
			for (int i = 0; i < n; i++)
				((ns1__AuthorizationFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__AuthorizationFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:InvalidArgumentFaultType"))
	{	cp->type = SOAP_TYPE_ns1__InvalidArgumentFaultType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__InvalidArgumentFaultType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__InvalidArgumentFaultType);
			((ns1__InvalidArgumentFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__InvalidArgumentFaultType[n]);
			if (size)
				*size = n * sizeof(ns1__InvalidArgumentFaultType);
			for (int i = 0; i < n; i++)
				((ns1__InvalidArgumentFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__InvalidArgumentFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:GetQuotaManagementFaultType"))
	{	cp->type = SOAP_TYPE_ns1__GetQuotaManagementFaultType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__GetQuotaManagementFaultType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__GetQuotaManagementFaultType);
			((ns1__GetQuotaManagementFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__GetQuotaManagementFaultType[n]);
			if (size)
				*size = n * sizeof(ns1__GetQuotaManagementFaultType);
			for (int i = 0; i < n; i++)
				((ns1__GetQuotaManagementFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__GetQuotaManagementFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:NoSuitableResourcesFaultType"))
	{	cp->type = SOAP_TYPE_ns1__NoSuitableResourcesFaultType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__NoSuitableResourcesFaultType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__NoSuitableResourcesFaultType);
			((ns1__NoSuitableResourcesFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__NoSuitableResourcesFaultType[n]);
			if (size)
				*size = n * sizeof(ns1__NoSuitableResourcesFaultType);
			for (int i = 0; i < n; i++)
				((ns1__NoSuitableResourcesFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__NoSuitableResourcesFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:JobUnknownFaultType"))
	{	cp->type = SOAP_TYPE_ns1__JobUnknownFaultType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__JobUnknownFaultType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__JobUnknownFaultType);
			((ns1__JobUnknownFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__JobUnknownFaultType[n]);
			if (size)
				*size = n * sizeof(ns1__JobUnknownFaultType);
			for (int i = 0; i < n; i++)
				((ns1__JobUnknownFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__JobUnknownFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:OperationNotAllowedFaultType"))
	{	cp->type = SOAP_TYPE_ns1__OperationNotAllowedFaultType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__OperationNotAllowedFaultType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__OperationNotAllowedFaultType);
			((ns1__OperationNotAllowedFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__OperationNotAllowedFaultType[n]);
			if (size)
				*size = n * sizeof(ns1__OperationNotAllowedFaultType);
			for (int i = 0; i < n; i++)
				((ns1__OperationNotAllowedFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__OperationNotAllowedFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:ServerOverloadedFaultType"))
	{	cp->type = SOAP_TYPE_ns1__ServerOverloadedFaultType;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__ServerOverloadedFaultType);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__ServerOverloadedFaultType);
			((ns1__ServerOverloadedFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__ServerOverloadedFaultType[n]);
			if (size)
				*size = n * sizeof(ns1__ServerOverloadedFaultType);
			for (int i = 0; i < n; i++)
				((ns1__ServerOverloadedFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__ServerOverloadedFaultType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__BaseFaultType);
		if (size)
			*size = sizeof(ns1__BaseFaultType);
		((ns1__BaseFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__BaseFaultType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__BaseFaultType);
		for (int i = 0; i < n; i++)
			((ns1__BaseFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__BaseFaultType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__BaseFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__BaseFaultType %p -> %p\n", q, p));
	*(ns1__BaseFaultType*)p = *(ns1__BaseFaultType*)q;
}

void ns1__ProxyInfoStructType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__ProxyInfoStructType::Subject);
	soap_default_std__string(soap, &this->ns1__ProxyInfoStructType::Issuer);
	soap_default_std__string(soap, &this->ns1__ProxyInfoStructType::Identity);
	soap_default_std__string(soap, &this->ns1__ProxyInfoStructType::Type);
	soap_default_std__string(soap, &this->ns1__ProxyInfoStructType::Strength);
	soap_default_std__string(soap, &this->ns1__ProxyInfoStructType::StartTime);
	soap_default_std__string(soap, &this->ns1__ProxyInfoStructType::EndTime);
	soap_default_std__vectorTemplateOfPointerTons1__VOProxyInfoStructType(soap, &this->ns1__ProxyInfoStructType::VOsInfo);
	/* transient soap skipped */
}

void ns1__ProxyInfoStructType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__ProxyInfoStructType::Subject, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ProxyInfoStructType::Subject);
	soap_embedded(soap, &this->ns1__ProxyInfoStructType::Issuer, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ProxyInfoStructType::Issuer);
	soap_embedded(soap, &this->ns1__ProxyInfoStructType::Identity, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ProxyInfoStructType::Identity);
	soap_embedded(soap, &this->ns1__ProxyInfoStructType::Type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ProxyInfoStructType::Type);
	soap_embedded(soap, &this->ns1__ProxyInfoStructType::Strength, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ProxyInfoStructType::Strength);
	soap_embedded(soap, &this->ns1__ProxyInfoStructType::StartTime, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ProxyInfoStructType::StartTime);
	soap_embedded(soap, &this->ns1__ProxyInfoStructType::EndTime, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ProxyInfoStructType::EndTime);
	soap_serialize_std__vectorTemplateOfPointerTons1__VOProxyInfoStructType(soap, &this->ns1__ProxyInfoStructType::VOsInfo);
	/* transient soap skipped */
}

int ns1__ProxyInfoStructType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ProxyInfoStructType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ProxyInfoStructType(struct soap *soap, const char *tag, int id, const ns1__ProxyInfoStructType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ProxyInfoStructType), type))
		return soap->error;
	if (soap_out_std__string(soap, "Subject", -1, &(a->ns1__ProxyInfoStructType::Subject), ""))
		return soap->error;
	if (soap_out_std__string(soap, "Issuer", -1, &(a->ns1__ProxyInfoStructType::Issuer), ""))
		return soap->error;
	if (soap_out_std__string(soap, "Identity", -1, &(a->ns1__ProxyInfoStructType::Identity), ""))
		return soap->error;
	if (soap_out_std__string(soap, "Type", -1, &(a->ns1__ProxyInfoStructType::Type), ""))
		return soap->error;
	if (soap_out_std__string(soap, "Strength", -1, &(a->ns1__ProxyInfoStructType::Strength), ""))
		return soap->error;
	if (soap_out_std__string(soap, "StartTime", -1, &(a->ns1__ProxyInfoStructType::StartTime), ""))
		return soap->error;
	if (soap_out_std__string(soap, "EndTime", -1, &(a->ns1__ProxyInfoStructType::EndTime), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__VOProxyInfoStructType(soap, "VOsInfo", -1, &(a->ns1__ProxyInfoStructType::VOsInfo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ProxyInfoStructType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ProxyInfoStructType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ProxyInfoStructType * SOAP_FMAC4 soap_in_ns1__ProxyInfoStructType(struct soap *soap, const char *tag, ns1__ProxyInfoStructType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ProxyInfoStructType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ProxyInfoStructType, sizeof(ns1__ProxyInfoStructType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ProxyInfoStructType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ProxyInfoStructType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Subject1 = 1;
	size_t soap_flag_Issuer1 = 1;
	size_t soap_flag_Identity1 = 1;
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_Strength1 = 1;
	size_t soap_flag_StartTime1 = 1;
	size_t soap_flag_EndTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Subject1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "Subject", &(a->ns1__ProxyInfoStructType::Subject), "xsd:string"))
				{	soap_flag_Subject1--;
					continue;
				}
			if (soap_flag_Issuer1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "Issuer", &(a->ns1__ProxyInfoStructType::Issuer), "xsd:string"))
				{	soap_flag_Issuer1--;
					continue;
				}
			if (soap_flag_Identity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "Identity", &(a->ns1__ProxyInfoStructType::Identity), "xsd:string"))
				{	soap_flag_Identity1--;
					continue;
				}
			if (soap_flag_Type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "Type", &(a->ns1__ProxyInfoStructType::Type), "xsd:string"))
				{	soap_flag_Type1--;
					continue;
				}
			if (soap_flag_Strength1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "Strength", &(a->ns1__ProxyInfoStructType::Strength), "xsd:string"))
				{	soap_flag_Strength1--;
					continue;
				}
			if (soap_flag_StartTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "StartTime", &(a->ns1__ProxyInfoStructType::StartTime), "xsd:string"))
				{	soap_flag_StartTime1--;
					continue;
				}
			if (soap_flag_EndTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "EndTime", &(a->ns1__ProxyInfoStructType::EndTime), "xsd:string"))
				{	soap_flag_EndTime1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__VOProxyInfoStructType(soap, "VOsInfo", &(a->ns1__ProxyInfoStructType::VOsInfo), "ns1:VOProxyInfoStructType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ProxyInfoStructType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ProxyInfoStructType, 0, sizeof(ns1__ProxyInfoStructType), 0, soap_copy_ns1__ProxyInfoStructType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Subject1 > 0 || soap_flag_Issuer1 > 0 || soap_flag_Identity1 > 0 || soap_flag_Type1 > 0 || soap_flag_Strength1 > 0 || soap_flag_StartTime1 > 0 || soap_flag_EndTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__ProxyInfoStructType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ProxyInfoStructType);
	if (this->soap_out(soap, tag?tag:"ns1:ProxyInfoStructType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ProxyInfoStructType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ProxyInfoStructType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ProxyInfoStructType * SOAP_FMAC4 soap_get_ns1__ProxyInfoStructType(struct soap *soap, ns1__ProxyInfoStructType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ProxyInfoStructType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ProxyInfoStructType * SOAP_FMAC2 soap_instantiate_ns1__ProxyInfoStructType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ProxyInfoStructType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ProxyInfoStructType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ProxyInfoStructType);
		if (size)
			*size = sizeof(ns1__ProxyInfoStructType);
		((ns1__ProxyInfoStructType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ProxyInfoStructType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ProxyInfoStructType);
		for (int i = 0; i < n; i++)
			((ns1__ProxyInfoStructType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ProxyInfoStructType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ProxyInfoStructType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ProxyInfoStructType %p -> %p\n", q, p));
	*(ns1__ProxyInfoStructType*)p = *(ns1__ProxyInfoStructType*)q;
}

void ns1__VOProxyInfoStructType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__VOProxyInfoStructType::User);
	soap_default_std__string(soap, &this->ns1__VOProxyInfoStructType::UserCA);
	soap_default_std__string(soap, &this->ns1__VOProxyInfoStructType::Server);
	soap_default_std__string(soap, &this->ns1__VOProxyInfoStructType::ServerCA);
	soap_default_std__string(soap, &this->ns1__VOProxyInfoStructType::VOName);
	soap_default_std__string(soap, &this->ns1__VOProxyInfoStructType::URI);
	soap_default_std__string(soap, &this->ns1__VOProxyInfoStructType::StartTime);
	soap_default_std__string(soap, &this->ns1__VOProxyInfoStructType::EndTime);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__VOProxyInfoStructType::Attribute);
	/* transient soap skipped */
}

void ns1__VOProxyInfoStructType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__VOProxyInfoStructType::User, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__VOProxyInfoStructType::User);
	soap_embedded(soap, &this->ns1__VOProxyInfoStructType::UserCA, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__VOProxyInfoStructType::UserCA);
	soap_embedded(soap, &this->ns1__VOProxyInfoStructType::Server, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__VOProxyInfoStructType::Server);
	soap_embedded(soap, &this->ns1__VOProxyInfoStructType::ServerCA, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__VOProxyInfoStructType::ServerCA);
	soap_embedded(soap, &this->ns1__VOProxyInfoStructType::VOName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__VOProxyInfoStructType::VOName);
	soap_embedded(soap, &this->ns1__VOProxyInfoStructType::URI, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__VOProxyInfoStructType::URI);
	soap_embedded(soap, &this->ns1__VOProxyInfoStructType::StartTime, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__VOProxyInfoStructType::StartTime);
	soap_embedded(soap, &this->ns1__VOProxyInfoStructType::EndTime, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__VOProxyInfoStructType::EndTime);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__VOProxyInfoStructType::Attribute);
	/* transient soap skipped */
}

int ns1__VOProxyInfoStructType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__VOProxyInfoStructType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__VOProxyInfoStructType(struct soap *soap, const char *tag, int id, const ns1__VOProxyInfoStructType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__VOProxyInfoStructType), type))
		return soap->error;
	if (soap_out_std__string(soap, "User", -1, &(a->ns1__VOProxyInfoStructType::User), ""))
		return soap->error;
	if (soap_out_std__string(soap, "UserCA", -1, &(a->ns1__VOProxyInfoStructType::UserCA), ""))
		return soap->error;
	if (soap_out_std__string(soap, "Server", -1, &(a->ns1__VOProxyInfoStructType::Server), ""))
		return soap->error;
	if (soap_out_std__string(soap, "ServerCA", -1, &(a->ns1__VOProxyInfoStructType::ServerCA), ""))
		return soap->error;
	if (soap_out_std__string(soap, "VOName", -1, &(a->ns1__VOProxyInfoStructType::VOName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "URI", -1, &(a->ns1__VOProxyInfoStructType::URI), ""))
		return soap->error;
	if (soap_out_std__string(soap, "StartTime", -1, &(a->ns1__VOProxyInfoStructType::StartTime), ""))
		return soap->error;
	if (soap_out_std__string(soap, "EndTime", -1, &(a->ns1__VOProxyInfoStructType::EndTime), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "Attribute", -1, &(a->ns1__VOProxyInfoStructType::Attribute), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__VOProxyInfoStructType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__VOProxyInfoStructType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__VOProxyInfoStructType * SOAP_FMAC4 soap_in_ns1__VOProxyInfoStructType(struct soap *soap, const char *tag, ns1__VOProxyInfoStructType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__VOProxyInfoStructType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__VOProxyInfoStructType, sizeof(ns1__VOProxyInfoStructType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__VOProxyInfoStructType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__VOProxyInfoStructType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_User1 = 1;
	size_t soap_flag_UserCA1 = 1;
	size_t soap_flag_Server1 = 1;
	size_t soap_flag_ServerCA1 = 1;
	size_t soap_flag_VOName1 = 1;
	size_t soap_flag_URI1 = 1;
	size_t soap_flag_StartTime1 = 1;
	size_t soap_flag_EndTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_User1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "User", &(a->ns1__VOProxyInfoStructType::User), "xsd:string"))
				{	soap_flag_User1--;
					continue;
				}
			if (soap_flag_UserCA1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "UserCA", &(a->ns1__VOProxyInfoStructType::UserCA), "xsd:string"))
				{	soap_flag_UserCA1--;
					continue;
				}
			if (soap_flag_Server1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "Server", &(a->ns1__VOProxyInfoStructType::Server), "xsd:string"))
				{	soap_flag_Server1--;
					continue;
				}
			if (soap_flag_ServerCA1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ServerCA", &(a->ns1__VOProxyInfoStructType::ServerCA), "xsd:string"))
				{	soap_flag_ServerCA1--;
					continue;
				}
			if (soap_flag_VOName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "VOName", &(a->ns1__VOProxyInfoStructType::VOName), "xsd:string"))
				{	soap_flag_VOName1--;
					continue;
				}
			if (soap_flag_URI1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "URI", &(a->ns1__VOProxyInfoStructType::URI), "xsd:string"))
				{	soap_flag_URI1--;
					continue;
				}
			if (soap_flag_StartTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "StartTime", &(a->ns1__VOProxyInfoStructType::StartTime), "xsd:string"))
				{	soap_flag_StartTime1--;
					continue;
				}
			if (soap_flag_EndTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "EndTime", &(a->ns1__VOProxyInfoStructType::EndTime), "xsd:string"))
				{	soap_flag_EndTime1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "Attribute", &(a->ns1__VOProxyInfoStructType::Attribute), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__VOProxyInfoStructType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__VOProxyInfoStructType, 0, sizeof(ns1__VOProxyInfoStructType), 0, soap_copy_ns1__VOProxyInfoStructType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_User1 > 0 || soap_flag_UserCA1 > 0 || soap_flag_Server1 > 0 || soap_flag_ServerCA1 > 0 || soap_flag_VOName1 > 0 || soap_flag_URI1 > 0 || soap_flag_StartTime1 > 0 || soap_flag_EndTime1 > 0 || a->ns1__VOProxyInfoStructType::Attribute.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__VOProxyInfoStructType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__VOProxyInfoStructType);
	if (this->soap_out(soap, tag?tag:"ns1:VOProxyInfoStructType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__VOProxyInfoStructType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__VOProxyInfoStructType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__VOProxyInfoStructType * SOAP_FMAC4 soap_get_ns1__VOProxyInfoStructType(struct soap *soap, ns1__VOProxyInfoStructType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__VOProxyInfoStructType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__VOProxyInfoStructType * SOAP_FMAC2 soap_instantiate_ns1__VOProxyInfoStructType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__VOProxyInfoStructType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__VOProxyInfoStructType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__VOProxyInfoStructType);
		if (size)
			*size = sizeof(ns1__VOProxyInfoStructType);
		((ns1__VOProxyInfoStructType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__VOProxyInfoStructType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__VOProxyInfoStructType);
		for (int i = 0; i < n; i++)
			((ns1__VOProxyInfoStructType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__VOProxyInfoStructType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__VOProxyInfoStructType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__VOProxyInfoStructType %p -> %p\n", q, p));
	*(ns1__VOProxyInfoStructType*)p = *(ns1__VOProxyInfoStructType*)q;
}

void ns1__GraphStructType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__GraphStructType::name = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__GraphStructType(soap, &this->ns1__GraphStructType::childrenJob);
	/* transient soap skipped */
}

void ns1__GraphStructType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__GraphStructType::name);
	soap_serialize_std__vectorTemplateOfPointerTons1__GraphStructType(soap, &this->ns1__GraphStructType::childrenJob);
	/* transient soap skipped */
}

int ns1__GraphStructType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GraphStructType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GraphStructType(struct soap *soap, const char *tag, int id, const ns1__GraphStructType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GraphStructType), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns1__GraphStructType::name), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__GraphStructType(soap, "childrenJob", -1, &(a->ns1__GraphStructType::childrenJob), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__GraphStructType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__GraphStructType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GraphStructType * SOAP_FMAC4 soap_in_ns1__GraphStructType(struct soap *soap, const char *tag, ns1__GraphStructType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GraphStructType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GraphStructType, sizeof(ns1__GraphStructType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__GraphStructType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__GraphStructType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "name", &(a->ns1__GraphStructType::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__GraphStructType(soap, "childrenJob", &(a->ns1__GraphStructType::childrenJob), "ns1:GraphStructType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__GraphStructType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GraphStructType, 0, sizeof(ns1__GraphStructType), 0, soap_copy_ns1__GraphStructType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__GraphStructType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__GraphStructType);
	if (this->soap_out(soap, tag?tag:"ns1:GraphStructType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__GraphStructType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GraphStructType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GraphStructType * SOAP_FMAC4 soap_get_ns1__GraphStructType(struct soap *soap, ns1__GraphStructType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GraphStructType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__GraphStructType * SOAP_FMAC2 soap_instantiate_ns1__GraphStructType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GraphStructType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GraphStructType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__GraphStructType);
		if (size)
			*size = sizeof(ns1__GraphStructType);
		((ns1__GraphStructType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__GraphStructType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__GraphStructType);
		for (int i = 0; i < n; i++)
			((ns1__GraphStructType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__GraphStructType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GraphStructType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__GraphStructType %p -> %p\n", q, p));
	*(ns1__GraphStructType*)p = *(ns1__GraphStructType*)q;
}

void ns1__JobIdStructType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__JobIdStructType::id);
	this->ns1__JobIdStructType::name = NULL;
	this->ns1__JobIdStructType::path = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__JobIdStructType(soap, &this->ns1__JobIdStructType::childrenJob);
	/* transient soap skipped */
}

void ns1__JobIdStructType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__JobIdStructType::id, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__JobIdStructType::id);
	soap_serialize_PointerTostd__string(soap, &this->ns1__JobIdStructType::name);
	soap_serialize_PointerTostd__string(soap, &this->ns1__JobIdStructType::path);
	soap_serialize_std__vectorTemplateOfPointerTons1__JobIdStructType(soap, &this->ns1__JobIdStructType::childrenJob);
	/* transient soap skipped */
}

int ns1__JobIdStructType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__JobIdStructType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__JobIdStructType(struct soap *soap, const char *tag, int id, const ns1__JobIdStructType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__JobIdStructType), type))
		return soap->error;
	if (soap_out_std__string(soap, "id", -1, &(a->ns1__JobIdStructType::id), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "name", -1, &(a->ns1__JobIdStructType::name), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "path", -1, &(a->ns1__JobIdStructType::path), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__JobIdStructType(soap, "childrenJob", -1, &(a->ns1__JobIdStructType::childrenJob), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__JobIdStructType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__JobIdStructType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__JobIdStructType * SOAP_FMAC4 soap_in_ns1__JobIdStructType(struct soap *soap, const char *tag, ns1__JobIdStructType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__JobIdStructType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__JobIdStructType, sizeof(ns1__JobIdStructType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__JobIdStructType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__JobIdStructType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_path1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "id", &(a->ns1__JobIdStructType::id), "xsd:string"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "name", &(a->ns1__JobIdStructType::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_path1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "path", &(a->ns1__JobIdStructType::path), "xsd:string"))
				{	soap_flag_path1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__JobIdStructType(soap, "childrenJob", &(a->ns1__JobIdStructType::childrenJob), "ns1:JobIdStructType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__JobIdStructType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__JobIdStructType, 0, sizeof(ns1__JobIdStructType), 0, soap_copy_ns1__JobIdStructType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_name1 > 0 || soap_flag_path1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__JobIdStructType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__JobIdStructType);
	if (this->soap_out(soap, tag?tag:"ns1:JobIdStructType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__JobIdStructType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__JobIdStructType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__JobIdStructType * SOAP_FMAC4 soap_get_ns1__JobIdStructType(struct soap *soap, ns1__JobIdStructType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__JobIdStructType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__JobIdStructType * SOAP_FMAC2 soap_instantiate_ns1__JobIdStructType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__JobIdStructType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__JobIdStructType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__JobIdStructType);
		if (size)
			*size = sizeof(ns1__JobIdStructType);
		((ns1__JobIdStructType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__JobIdStructType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__JobIdStructType);
		for (int i = 0; i < n; i++)
			((ns1__JobIdStructType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__JobIdStructType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__JobIdStructType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__JobIdStructType %p -> %p\n", q, p));
	*(ns1__JobIdStructType*)p = *(ns1__JobIdStructType*)q;
}

void ns1__JobStatusStructType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__JobStatusStructType::jobid);
	soap_default_std__string(soap, &this->ns1__JobStatusStructType::status);
	soap_default_std__vectorTemplateOfPointerTons1__JobStatusStructType(soap, &this->ns1__JobStatusStructType::childrenJob);
	/* transient soap skipped */
}

void ns1__JobStatusStructType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__JobStatusStructType::jobid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__JobStatusStructType::jobid);
	soap_embedded(soap, &this->ns1__JobStatusStructType::status, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__JobStatusStructType::status);
	soap_serialize_std__vectorTemplateOfPointerTons1__JobStatusStructType(soap, &this->ns1__JobStatusStructType::childrenJob);
	/* transient soap skipped */
}

int ns1__JobStatusStructType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__JobStatusStructType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__JobStatusStructType(struct soap *soap, const char *tag, int id, const ns1__JobStatusStructType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__JobStatusStructType), type))
		return soap->error;
	if (soap_out_std__string(soap, "jobid", -1, &(a->ns1__JobStatusStructType::jobid), ""))
		return soap->error;
	if (soap_out_std__string(soap, "status", -1, &(a->ns1__JobStatusStructType::status), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__JobStatusStructType(soap, "childrenJob", -1, &(a->ns1__JobStatusStructType::childrenJob), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__JobStatusStructType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__JobStatusStructType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__JobStatusStructType * SOAP_FMAC4 soap_in_ns1__JobStatusStructType(struct soap *soap, const char *tag, ns1__JobStatusStructType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__JobStatusStructType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__JobStatusStructType, sizeof(ns1__JobStatusStructType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__JobStatusStructType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__JobStatusStructType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_jobid1 = 1;
	size_t soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jobid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "jobid", &(a->ns1__JobStatusStructType::jobid), "xsd:string"))
				{	soap_flag_jobid1--;
					continue;
				}
			if (soap_flag_status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "status", &(a->ns1__JobStatusStructType::status), "xsd:string"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__JobStatusStructType(soap, "childrenJob", &(a->ns1__JobStatusStructType::childrenJob), "ns1:JobStatusStructType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__JobStatusStructType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__JobStatusStructType, 0, sizeof(ns1__JobStatusStructType), 0, soap_copy_ns1__JobStatusStructType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jobid1 > 0 || soap_flag_status1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__JobStatusStructType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__JobStatusStructType);
	if (this->soap_out(soap, tag?tag:"ns1:JobStatusStructType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__JobStatusStructType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__JobStatusStructType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__JobStatusStructType * SOAP_FMAC4 soap_get_ns1__JobStatusStructType(struct soap *soap, ns1__JobStatusStructType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__JobStatusStructType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__JobStatusStructType * SOAP_FMAC2 soap_instantiate_ns1__JobStatusStructType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__JobStatusStructType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__JobStatusStructType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__JobStatusStructType);
		if (size)
			*size = sizeof(ns1__JobStatusStructType);
		((ns1__JobStatusStructType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__JobStatusStructType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__JobStatusStructType);
		for (int i = 0; i < n; i++)
			((ns1__JobStatusStructType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__JobStatusStructType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__JobStatusStructType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__JobStatusStructType %p -> %p\n", q, p));
	*(ns1__JobStatusStructType*)p = *(ns1__JobStatusStructType*)q;
}

void ns1__StringAndLongList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__StringAndLongType(soap, &this->ns1__StringAndLongList::file);
	/* transient soap skipped */
}

void ns1__StringAndLongList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__StringAndLongType(soap, &this->ns1__StringAndLongList::file);
	/* transient soap skipped */
}

int ns1__StringAndLongList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__StringAndLongList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__StringAndLongList(struct soap *soap, const char *tag, int id, const ns1__StringAndLongList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__StringAndLongList), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__StringAndLongType(soap, "file", -1, &(a->ns1__StringAndLongList::file), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__StringAndLongList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__StringAndLongList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__StringAndLongList * SOAP_FMAC4 soap_in_ns1__StringAndLongList(struct soap *soap, const char *tag, ns1__StringAndLongList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__StringAndLongList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__StringAndLongList, sizeof(ns1__StringAndLongList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__StringAndLongList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__StringAndLongList *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__StringAndLongType(soap, "file", &(a->ns1__StringAndLongList::file), "ns1:StringAndLongType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__StringAndLongList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__StringAndLongList, 0, sizeof(ns1__StringAndLongList), 0, soap_copy_ns1__StringAndLongList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__StringAndLongList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__StringAndLongList);
	if (this->soap_out(soap, tag?tag:"ns1:StringAndLongList", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__StringAndLongList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__StringAndLongList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__StringAndLongList * SOAP_FMAC4 soap_get_ns1__StringAndLongList(struct soap *soap, ns1__StringAndLongList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__StringAndLongList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__StringAndLongList * SOAP_FMAC2 soap_instantiate_ns1__StringAndLongList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__StringAndLongList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__StringAndLongList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__StringAndLongList);
		if (size)
			*size = sizeof(ns1__StringAndLongList);
		((ns1__StringAndLongList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__StringAndLongList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__StringAndLongList);
		for (int i = 0; i < n; i++)
			((ns1__StringAndLongList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__StringAndLongList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__StringAndLongList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__StringAndLongList %p -> %p\n", q, p));
	*(ns1__StringAndLongList*)p = *(ns1__StringAndLongList*)q;
}

void ns1__StringAndLongType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__StringAndLongType::name);
	soap_default_LONG64(soap, &this->ns1__StringAndLongType::size);
	/* transient soap skipped */
}

void ns1__StringAndLongType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__StringAndLongType::name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__StringAndLongType::name);
	/* transient soap skipped */
}

int ns1__StringAndLongType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__StringAndLongType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__StringAndLongType(struct soap *soap, const char *tag, int id, const ns1__StringAndLongType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__StringAndLongType), type))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &(a->ns1__StringAndLongType::name), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "size", -1, &(a->ns1__StringAndLongType::size), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__StringAndLongType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__StringAndLongType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__StringAndLongType * SOAP_FMAC4 soap_in_ns1__StringAndLongType(struct soap *soap, const char *tag, ns1__StringAndLongType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__StringAndLongType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__StringAndLongType, sizeof(ns1__StringAndLongType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__StringAndLongType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__StringAndLongType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_size1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(a->ns1__StringAndLongType::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_size1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "size", &(a->ns1__StringAndLongType::size), "xsd:long"))
				{	soap_flag_size1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__StringAndLongType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__StringAndLongType, 0, sizeof(ns1__StringAndLongType), 0, soap_copy_ns1__StringAndLongType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0 || soap_flag_size1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__StringAndLongType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__StringAndLongType);
	if (this->soap_out(soap, tag?tag:"ns1:StringAndLongType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__StringAndLongType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__StringAndLongType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__StringAndLongType * SOAP_FMAC4 soap_get_ns1__StringAndLongType(struct soap *soap, ns1__StringAndLongType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__StringAndLongType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__StringAndLongType * SOAP_FMAC2 soap_instantiate_ns1__StringAndLongType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__StringAndLongType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__StringAndLongType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__StringAndLongType);
		if (size)
			*size = sizeof(ns1__StringAndLongType);
		((ns1__StringAndLongType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__StringAndLongType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__StringAndLongType);
		for (int i = 0; i < n; i++)
			((ns1__StringAndLongType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__StringAndLongType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__StringAndLongType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__StringAndLongType %p -> %p\n", q, p));
	*(ns1__StringAndLongType*)p = *(ns1__StringAndLongType*)q;
}

void ns1__DestURIsStructType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__DestURIStructType(soap, &this->ns1__DestURIsStructType::Item);
	/* transient soap skipped */
}

void ns1__DestURIsStructType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__DestURIStructType(soap, &this->ns1__DestURIsStructType::Item);
	/* transient soap skipped */
}

int ns1__DestURIsStructType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DestURIsStructType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DestURIsStructType(struct soap *soap, const char *tag, int id, const ns1__DestURIsStructType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DestURIsStructType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__DestURIStructType(soap, "Item", -1, &(a->ns1__DestURIsStructType::Item), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__DestURIsStructType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__DestURIsStructType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DestURIsStructType * SOAP_FMAC4 soap_in_ns1__DestURIsStructType(struct soap *soap, const char *tag, ns1__DestURIsStructType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DestURIsStructType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DestURIsStructType, sizeof(ns1__DestURIsStructType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__DestURIsStructType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__DestURIsStructType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__DestURIStructType(soap, "Item", &(a->ns1__DestURIsStructType::Item), "ns1:DestURIStructType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__DestURIsStructType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DestURIsStructType, 0, sizeof(ns1__DestURIsStructType), 0, soap_copy_ns1__DestURIsStructType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns1__DestURIsStructType::Item.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__DestURIsStructType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__DestURIsStructType);
	if (this->soap_out(soap, tag?tag:"ns1:DestURIsStructType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__DestURIsStructType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DestURIsStructType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DestURIsStructType * SOAP_FMAC4 soap_get_ns1__DestURIsStructType(struct soap *soap, ns1__DestURIsStructType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DestURIsStructType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__DestURIsStructType * SOAP_FMAC2 soap_instantiate_ns1__DestURIsStructType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DestURIsStructType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__DestURIsStructType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__DestURIsStructType);
		if (size)
			*size = sizeof(ns1__DestURIsStructType);
		((ns1__DestURIsStructType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__DestURIsStructType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__DestURIsStructType);
		for (int i = 0; i < n; i++)
			((ns1__DestURIsStructType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__DestURIsStructType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__DestURIsStructType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__DestURIsStructType %p -> %p\n", q, p));
	*(ns1__DestURIsStructType*)p = *(ns1__DestURIsStructType*)q;
}

void ns1__DestURIStructType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__DestURIStructType::id);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__DestURIStructType::Item);
	/* transient soap skipped */
}

void ns1__DestURIStructType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__DestURIStructType::id, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__DestURIStructType::id);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__DestURIStructType::Item);
	/* transient soap skipped */
}

int ns1__DestURIStructType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DestURIStructType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DestURIStructType(struct soap *soap, const char *tag, int id, const ns1__DestURIStructType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DestURIStructType), type))
		return soap->error;
	if (soap_out_std__string(soap, "id", -1, &(a->ns1__DestURIStructType::id), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "Item", -1, &(a->ns1__DestURIStructType::Item), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__DestURIStructType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__DestURIStructType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DestURIStructType * SOAP_FMAC4 soap_in_ns1__DestURIStructType(struct soap *soap, const char *tag, ns1__DestURIStructType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DestURIStructType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DestURIStructType, sizeof(ns1__DestURIStructType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__DestURIStructType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__DestURIStructType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "id", &(a->ns1__DestURIStructType::id), "xsd:string"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "Item", &(a->ns1__DestURIStructType::Item), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__DestURIStructType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DestURIStructType, 0, sizeof(ns1__DestURIStructType), 0, soap_copy_ns1__DestURIStructType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || a->ns1__DestURIStructType::Item.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__DestURIStructType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__DestURIStructType);
	if (this->soap_out(soap, tag?tag:"ns1:DestURIStructType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__DestURIStructType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DestURIStructType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DestURIStructType * SOAP_FMAC4 soap_get_ns1__DestURIStructType(struct soap *soap, ns1__DestURIStructType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DestURIStructType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__DestURIStructType * SOAP_FMAC2 soap_instantiate_ns1__DestURIStructType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DestURIStructType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__DestURIStructType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__DestURIStructType);
		if (size)
			*size = sizeof(ns1__DestURIStructType);
		((ns1__DestURIStructType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__DestURIStructType[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__DestURIStructType);
		for (int i = 0; i < n; i++)
			((ns1__DestURIStructType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__DestURIStructType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__DestURIStructType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__DestURIStructType %p -> %p\n", q, p));
	*(ns1__DestURIStructType*)p = *(ns1__DestURIStructType*)q;
}

void ns1__StringList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__StringList::Item);
	/* transient soap skipped */
}

void ns1__StringList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__StringList::Item);
	/* transient soap skipped */
}

int ns1__StringList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__StringList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__StringList(struct soap *soap, const char *tag, int id, const ns1__StringList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__StringList), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "Item", -1, &(a->ns1__StringList::Item), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__StringList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__StringList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__StringList * SOAP_FMAC4 soap_in_ns1__StringList(struct soap *soap, const char *tag, ns1__StringList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__StringList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__StringList, sizeof(ns1__StringList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__StringList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__StringList *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "Item", &(a->ns1__StringList::Item), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__StringList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__StringList, 0, sizeof(ns1__StringList), 0, soap_copy_ns1__StringList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__StringList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__StringList);
	if (this->soap_out(soap, tag?tag:"ns1:StringList", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__StringList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__StringList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__StringList * SOAP_FMAC4 soap_get_ns1__StringList(struct soap *soap, ns1__StringList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__StringList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__StringList * SOAP_FMAC2 soap_instantiate_ns1__StringList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__StringList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__StringList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__StringList);
		if (size)
			*size = sizeof(ns1__StringList);
		((ns1__StringList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__StringList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__StringList);
		for (int i = 0; i < n; i++)
			((ns1__StringList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__StringList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__StringList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__StringList %p -> %p\n", q, p));
	*(ns1__StringList*)p = *(ns1__StringList*)q;
}

void ns1__JobTypeList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfns1__JobType(soap, &this->ns1__JobTypeList::jobType);
	/* transient soap skipped */
}

void ns1__JobTypeList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfns1__JobType(soap, &this->ns1__JobTypeList::jobType);
	/* transient soap skipped */
}

int ns1__JobTypeList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__JobTypeList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__JobTypeList(struct soap *soap, const char *tag, int id, const ns1__JobTypeList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__JobTypeList), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns1__JobType(soap, "jobType", -1, &(a->ns1__JobTypeList::jobType), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__JobTypeList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__JobTypeList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__JobTypeList * SOAP_FMAC4 soap_in_ns1__JobTypeList(struct soap *soap, const char *tag, ns1__JobTypeList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__JobTypeList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__JobTypeList, sizeof(ns1__JobTypeList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__JobTypeList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__JobTypeList *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfns1__JobType(soap, "jobType", &(a->ns1__JobTypeList::jobType), "ns1:JobType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__JobTypeList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__JobTypeList, 0, sizeof(ns1__JobTypeList), 0, soap_copy_ns1__JobTypeList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__JobTypeList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__JobTypeList);
	if (this->soap_out(soap, tag?tag:"ns1:JobTypeList", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__JobTypeList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__JobTypeList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__JobTypeList * SOAP_FMAC4 soap_get_ns1__JobTypeList(struct soap *soap, ns1__JobTypeList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__JobTypeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__JobTypeList * SOAP_FMAC2 soap_instantiate_ns1__JobTypeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__JobTypeList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__JobTypeList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__JobTypeList);
		if (size)
			*size = sizeof(ns1__JobTypeList);
		((ns1__JobTypeList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__JobTypeList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__JobTypeList);
		for (int i = 0; i < n; i++)
			((ns1__JobTypeList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__JobTypeList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__JobTypeList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__JobTypeList %p -> %p\n", q, p));
	*(ns1__JobTypeList*)p = *(ns1__JobTypeList*)q;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__normalizedString(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__normalizedString), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__normalizedString(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__normalizedString, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__normalizedString, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__normalizedString, 0, sizeof(std::string), 0, soap_copy_xsd__normalizedString);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__normalizedString(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__normalizedString);
	if (soap_out_xsd__normalizedString(soap, tag?tag:"xsd:normalizedString", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__normalizedString(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__normalizedString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__nonNegativeInteger), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__nonNegativeInteger(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__nonNegativeInteger, 0, sizeof(std::string), 0, soap_copy_xsd__nonNegativeInteger);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__nonNegativeInteger(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__nonNegativeInteger);
	if (soap_out_xsd__nonNegativeInteger(soap, tag?tag:"xsd:nonNegativeInteger", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__nonNegativeInteger(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__anyURI), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__anyURI, 0, sizeof(std::string), 0, soap_copy_xsd__anyURI);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyURI);
	if (soap_out_xsd__anyURI(soap, tag?tag:"xsd:anyURI", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NCName(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__NCName), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__NCName(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__NCName, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__NCName, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__NCName, 0, sizeof(std::string), 0, soap_copy_xsd__NCName);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NCName(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__NCName);
	if (soap_out_xsd__NCName(soap, tag?tag:"xsd:NCName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__NCName(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NCName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__ID(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__ID), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__ID(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__ID, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__ID, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__ID, 0, sizeof(std::string), 0, soap_copy_xsd__ID);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__ID(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__ID);
	if (soap_out_xsd__ID(soap, tag?tag:"xsd:ID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__ID(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__ID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::string[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getJobStatus(struct soap *soap, struct ns1__getJobStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->jobId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getJobStatus(struct soap *soap, const struct ns1__getJobStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->jobId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->jobId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getJobStatus(struct soap *soap, const char *tag, int id, const struct ns1__getJobStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getJobStatus), type))
		return soap->error;
	if (soap_out_std__string(soap, "jobId", -1, &a->jobId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getJobStatus * SOAP_FMAC4 soap_in_ns1__getJobStatus(struct soap *soap, const char *tag, struct ns1__getJobStatus *a, const char *type)
{
	size_t soap_flag_jobId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getJobStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getJobStatus, sizeof(struct ns1__getJobStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getJobStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jobId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "jobId", &a->jobId, "xsd:string"))
				{	soap_flag_jobId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getJobStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getJobStatus, 0, sizeof(struct ns1__getJobStatus), 0, soap_copy_ns1__getJobStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jobId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getJobStatus(struct soap *soap, const struct ns1__getJobStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getJobStatus);
	if (soap_out_ns1__getJobStatus(soap, tag?tag:"ns1:getJobStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getJobStatus * SOAP_FMAC4 soap_get_ns1__getJobStatus(struct soap *soap, struct ns1__getJobStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getJobStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getJobStatus * SOAP_FMAC2 soap_instantiate_ns1__getJobStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getJobStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getJobStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getJobStatus);
		if (size)
			*size = sizeof(struct ns1__getJobStatus);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getJobStatus[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getJobStatus);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getJobStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getJobStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getJobStatus %p -> %p\n", q, p));
	*(struct ns1__getJobStatus*)p = *(struct ns1__getJobStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getJobStatusResponse(struct soap *soap, struct ns1__getJobStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->JobStatusStruct = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getJobStatusResponse(struct soap *soap, const struct ns1__getJobStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__JobStatusStructType(soap, &a->JobStatusStruct);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getJobStatusResponse(struct soap *soap, const char *tag, int id, const struct ns1__getJobStatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getJobStatusResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__JobStatusStructType(soap, "JobStatusStruct", -1, &a->JobStatusStruct, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getJobStatusResponse * SOAP_FMAC4 soap_in_ns1__getJobStatusResponse(struct soap *soap, const char *tag, struct ns1__getJobStatusResponse *a, const char *type)
{
	size_t soap_flag_JobStatusStruct = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getJobStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getJobStatusResponse, sizeof(struct ns1__getJobStatusResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getJobStatusResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobStatusStruct && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__JobStatusStructType(soap, "JobStatusStruct", &a->JobStatusStruct, "ns1:JobStatusStructType"))
				{	soap_flag_JobStatusStruct--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getJobStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getJobStatusResponse, 0, sizeof(struct ns1__getJobStatusResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getJobStatusResponse(struct soap *soap, const struct ns1__getJobStatusResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getJobStatusResponse);
	if (soap_out_ns1__getJobStatusResponse(soap, tag?tag:"ns1:getJobStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getJobStatusResponse * SOAP_FMAC4 soap_get_ns1__getJobStatusResponse(struct soap *soap, struct ns1__getJobStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getJobStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getJobStatusResponse * SOAP_FMAC2 soap_instantiate_ns1__getJobStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getJobStatusResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getJobStatusResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getJobStatusResponse);
		if (size)
			*size = sizeof(struct ns1__getJobStatusResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getJobStatusResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getJobStatusResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getJobStatusResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getJobStatusResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getJobStatusResponse %p -> %p\n", q, p));
	*(struct ns1__getJobStatusResponse*)p = *(struct ns1__getJobStatusResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTransferProtocols(struct soap *soap, struct ns1__getTransferProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTransferProtocols(struct soap *soap, const struct ns1__getTransferProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTransferProtocols(struct soap *soap, const char *tag, int id, const struct ns1__getTransferProtocols *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTransferProtocols), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTransferProtocols * SOAP_FMAC4 soap_in_ns1__getTransferProtocols(struct soap *soap, const char *tag, struct ns1__getTransferProtocols *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getTransferProtocols *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTransferProtocols, sizeof(struct ns1__getTransferProtocols), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTransferProtocols(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTransferProtocols *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTransferProtocols, 0, sizeof(struct ns1__getTransferProtocols), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTransferProtocols(struct soap *soap, const struct ns1__getTransferProtocols *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getTransferProtocols);
	if (soap_out_ns1__getTransferProtocols(soap, tag?tag:"ns1:getTransferProtocols", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTransferProtocols * SOAP_FMAC4 soap_get_ns1__getTransferProtocols(struct soap *soap, struct ns1__getTransferProtocols *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTransferProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getTransferProtocols * SOAP_FMAC2 soap_instantiate_ns1__getTransferProtocols(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTransferProtocols(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTransferProtocols, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getTransferProtocols);
		if (size)
			*size = sizeof(struct ns1__getTransferProtocols);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getTransferProtocols[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getTransferProtocols);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getTransferProtocols*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTransferProtocols(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getTransferProtocols %p -> %p\n", q, p));
	*(struct ns1__getTransferProtocols*)p = *(struct ns1__getTransferProtocols*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTransferProtocolsResponse(struct soap *soap, struct ns1__getTransferProtocolsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->items = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTransferProtocolsResponse(struct soap *soap, const struct ns1__getTransferProtocolsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__StringList(soap, &a->items);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTransferProtocolsResponse(struct soap *soap, const char *tag, int id, const struct ns1__getTransferProtocolsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTransferProtocolsResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__StringList(soap, "items", -1, &a->items, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTransferProtocolsResponse * SOAP_FMAC4 soap_in_ns1__getTransferProtocolsResponse(struct soap *soap, const char *tag, struct ns1__getTransferProtocolsResponse *a, const char *type)
{
	size_t soap_flag_items = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getTransferProtocolsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTransferProtocolsResponse, sizeof(struct ns1__getTransferProtocolsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTransferProtocolsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_items && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__StringList(soap, "items", &a->items, "ns1:StringList"))
				{	soap_flag_items--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTransferProtocolsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTransferProtocolsResponse, 0, sizeof(struct ns1__getTransferProtocolsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTransferProtocolsResponse(struct soap *soap, const struct ns1__getTransferProtocolsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getTransferProtocolsResponse);
	if (soap_out_ns1__getTransferProtocolsResponse(soap, tag?tag:"ns1:getTransferProtocolsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTransferProtocolsResponse * SOAP_FMAC4 soap_get_ns1__getTransferProtocolsResponse(struct soap *soap, struct ns1__getTransferProtocolsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTransferProtocolsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getTransferProtocolsResponse * SOAP_FMAC2 soap_instantiate_ns1__getTransferProtocolsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTransferProtocolsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTransferProtocolsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getTransferProtocolsResponse);
		if (size)
			*size = sizeof(struct ns1__getTransferProtocolsResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getTransferProtocolsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getTransferProtocolsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getTransferProtocolsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTransferProtocolsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getTransferProtocolsResponse %p -> %p\n", q, p));
	*(struct ns1__getTransferProtocolsResponse*)p = *(struct ns1__getTransferProtocolsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getPerusalFiles(struct soap *soap, struct ns1__getPerusalFiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_jobId);
	soap_default_std__string(soap, &a->_file);
	soap_default_bool(soap, &a->_allChunks);
	soap_default_std__string(soap, &a->_protocol);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getPerusalFiles(struct soap *soap, const struct ns1__getPerusalFiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_jobId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_jobId);
	soap_embedded(soap, &a->_file, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_file);
	soap_embedded(soap, &a->_allChunks, SOAP_TYPE_bool);
	soap_embedded(soap, &a->_protocol, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_protocol);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getPerusalFiles(struct soap *soap, const char *tag, int id, const struct ns1__getPerusalFiles *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getPerusalFiles), type))
		return soap->error;
	if (soap_out_std__string(soap, "jobId", -1, &a->_jobId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "file", -1, &a->_file, ""))
		return soap->error;
	if (soap_out_bool(soap, "allChunks", -1, &a->_allChunks, ""))
		return soap->error;
	if (soap_out_std__string(soap, "protocol", -1, &a->_protocol, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getPerusalFiles * SOAP_FMAC4 soap_in_ns1__getPerusalFiles(struct soap *soap, const char *tag, struct ns1__getPerusalFiles *a, const char *type)
{
	size_t soap_flag__jobId = 1;
	size_t soap_flag__file = 1;
	size_t soap_flag__allChunks = 1;
	size_t soap_flag__protocol = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getPerusalFiles *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getPerusalFiles, sizeof(struct ns1__getPerusalFiles), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getPerusalFiles(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_jobId, "xsd:string"))
				{	soap_flag__jobId--;
					continue;
				}
			if (soap_flag__file && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_file, "xsd:string"))
				{	soap_flag__file--;
					continue;
				}
			if (soap_flag__allChunks && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, NULL, &a->_allChunks, "xsd:boolean"))
				{	soap_flag__allChunks--;
					continue;
				}
			if (soap_flag__protocol && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_protocol, "xsd:string"))
				{	soap_flag__protocol--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getPerusalFiles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getPerusalFiles, 0, sizeof(struct ns1__getPerusalFiles), 0, soap_copy_ns1__getPerusalFiles);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__jobId > 0 || soap_flag__file > 0 || soap_flag__allChunks > 0 || soap_flag__protocol > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getPerusalFiles(struct soap *soap, const struct ns1__getPerusalFiles *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getPerusalFiles);
	if (soap_out_ns1__getPerusalFiles(soap, tag?tag:"ns1:getPerusalFiles", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getPerusalFiles * SOAP_FMAC4 soap_get_ns1__getPerusalFiles(struct soap *soap, struct ns1__getPerusalFiles *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getPerusalFiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getPerusalFiles * SOAP_FMAC2 soap_instantiate_ns1__getPerusalFiles(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getPerusalFiles(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getPerusalFiles, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getPerusalFiles);
		if (size)
			*size = sizeof(struct ns1__getPerusalFiles);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getPerusalFiles[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getPerusalFiles);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getPerusalFiles*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getPerusalFiles(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getPerusalFiles %p -> %p\n", q, p));
	*(struct ns1__getPerusalFiles*)p = *(struct ns1__getPerusalFiles*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getPerusalFilesResponse(struct soap *soap, struct ns1__getPerusalFilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_fileList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getPerusalFilesResponse(struct soap *soap, const struct ns1__getPerusalFilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__StringList(soap, &a->_fileList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getPerusalFilesResponse(struct soap *soap, const char *tag, int id, const struct ns1__getPerusalFilesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getPerusalFilesResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__StringList(soap, "fileList", -1, &a->_fileList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getPerusalFilesResponse * SOAP_FMAC4 soap_in_ns1__getPerusalFilesResponse(struct soap *soap, const char *tag, struct ns1__getPerusalFilesResponse *a, const char *type)
{
	size_t soap_flag__fileList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getPerusalFilesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getPerusalFilesResponse, sizeof(struct ns1__getPerusalFilesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getPerusalFilesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__fileList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__StringList(soap, NULL, &a->_fileList, "ns1:StringList"))
				{	soap_flag__fileList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getPerusalFilesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getPerusalFilesResponse, 0, sizeof(struct ns1__getPerusalFilesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getPerusalFilesResponse(struct soap *soap, const struct ns1__getPerusalFilesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getPerusalFilesResponse);
	if (soap_out_ns1__getPerusalFilesResponse(soap, tag?tag:"ns1:getPerusalFilesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getPerusalFilesResponse * SOAP_FMAC4 soap_get_ns1__getPerusalFilesResponse(struct soap *soap, struct ns1__getPerusalFilesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getPerusalFilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getPerusalFilesResponse * SOAP_FMAC2 soap_instantiate_ns1__getPerusalFilesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getPerusalFilesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getPerusalFilesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getPerusalFilesResponse);
		if (size)
			*size = sizeof(struct ns1__getPerusalFilesResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getPerusalFilesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getPerusalFilesResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getPerusalFilesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getPerusalFilesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getPerusalFilesResponse %p -> %p\n", q, p));
	*(struct ns1__getPerusalFilesResponse*)p = *(struct ns1__getPerusalFilesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__enableFilePerusal(struct soap *soap, struct ns1__enableFilePerusal *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_jobId);
	a->_fileList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__enableFilePerusal(struct soap *soap, const struct ns1__enableFilePerusal *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_jobId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_jobId);
	soap_serialize_PointerTons1__StringList(soap, &a->_fileList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__enableFilePerusal(struct soap *soap, const char *tag, int id, const struct ns1__enableFilePerusal *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__enableFilePerusal), type))
		return soap->error;
	if (soap_out_std__string(soap, "jobId", -1, &a->_jobId, ""))
		return soap->error;
	if (soap_out_PointerTons1__StringList(soap, "fileList", -1, &a->_fileList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__enableFilePerusal * SOAP_FMAC4 soap_in_ns1__enableFilePerusal(struct soap *soap, const char *tag, struct ns1__enableFilePerusal *a, const char *type)
{
	size_t soap_flag__jobId = 1;
	size_t soap_flag__fileList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__enableFilePerusal *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__enableFilePerusal, sizeof(struct ns1__enableFilePerusal), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__enableFilePerusal(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_jobId, "xsd:string"))
				{	soap_flag__jobId--;
					continue;
				}
			if (soap_flag__fileList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__StringList(soap, NULL, &a->_fileList, "ns1:StringList"))
				{	soap_flag__fileList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__enableFilePerusal *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__enableFilePerusal, 0, sizeof(struct ns1__enableFilePerusal), 0, soap_copy_ns1__enableFilePerusal);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__jobId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__enableFilePerusal(struct soap *soap, const struct ns1__enableFilePerusal *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__enableFilePerusal);
	if (soap_out_ns1__enableFilePerusal(soap, tag?tag:"ns1:enableFilePerusal", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__enableFilePerusal * SOAP_FMAC4 soap_get_ns1__enableFilePerusal(struct soap *soap, struct ns1__enableFilePerusal *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__enableFilePerusal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__enableFilePerusal * SOAP_FMAC2 soap_instantiate_ns1__enableFilePerusal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__enableFilePerusal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__enableFilePerusal, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__enableFilePerusal);
		if (size)
			*size = sizeof(struct ns1__enableFilePerusal);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__enableFilePerusal[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__enableFilePerusal);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__enableFilePerusal*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__enableFilePerusal(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__enableFilePerusal %p -> %p\n", q, p));
	*(struct ns1__enableFilePerusal*)p = *(struct ns1__enableFilePerusal*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__enableFilePerusalResponse(struct soap *soap, struct ns1__enableFilePerusalResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__enableFilePerusalResponse(struct soap *soap, const struct ns1__enableFilePerusalResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__enableFilePerusalResponse(struct soap *soap, const char *tag, int id, const struct ns1__enableFilePerusalResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__enableFilePerusalResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__enableFilePerusalResponse * SOAP_FMAC4 soap_in_ns1__enableFilePerusalResponse(struct soap *soap, const char *tag, struct ns1__enableFilePerusalResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__enableFilePerusalResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__enableFilePerusalResponse, sizeof(struct ns1__enableFilePerusalResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__enableFilePerusalResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__enableFilePerusalResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__enableFilePerusalResponse, 0, sizeof(struct ns1__enableFilePerusalResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__enableFilePerusalResponse(struct soap *soap, const struct ns1__enableFilePerusalResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__enableFilePerusalResponse);
	if (soap_out_ns1__enableFilePerusalResponse(soap, tag?tag:"ns1:enableFilePerusalResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__enableFilePerusalResponse * SOAP_FMAC4 soap_get_ns1__enableFilePerusalResponse(struct soap *soap, struct ns1__enableFilePerusalResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__enableFilePerusalResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__enableFilePerusalResponse * SOAP_FMAC2 soap_instantiate_ns1__enableFilePerusalResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__enableFilePerusalResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__enableFilePerusalResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__enableFilePerusalResponse);
		if (size)
			*size = sizeof(struct ns1__enableFilePerusalResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__enableFilePerusalResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__enableFilePerusalResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__enableFilePerusalResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__enableFilePerusalResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__enableFilePerusalResponse %p -> %p\n", q, p));
	*(struct ns1__enableFilePerusalResponse*)p = *(struct ns1__enableFilePerusalResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getJobProxyInfo(struct soap *soap, struct ns1__getJobProxyInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_jobId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getJobProxyInfo(struct soap *soap, const struct ns1__getJobProxyInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_jobId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_jobId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getJobProxyInfo(struct soap *soap, const char *tag, int id, const struct ns1__getJobProxyInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getJobProxyInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "jobId", -1, &a->_jobId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getJobProxyInfo * SOAP_FMAC4 soap_in_ns1__getJobProxyInfo(struct soap *soap, const char *tag, struct ns1__getJobProxyInfo *a, const char *type)
{
	size_t soap_flag__jobId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getJobProxyInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getJobProxyInfo, sizeof(struct ns1__getJobProxyInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getJobProxyInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_jobId, "xsd:string"))
				{	soap_flag__jobId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getJobProxyInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getJobProxyInfo, 0, sizeof(struct ns1__getJobProxyInfo), 0, soap_copy_ns1__getJobProxyInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__jobId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getJobProxyInfo(struct soap *soap, const struct ns1__getJobProxyInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getJobProxyInfo);
	if (soap_out_ns1__getJobProxyInfo(soap, tag?tag:"ns1:getJobProxyInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getJobProxyInfo * SOAP_FMAC4 soap_get_ns1__getJobProxyInfo(struct soap *soap, struct ns1__getJobProxyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getJobProxyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getJobProxyInfo * SOAP_FMAC2 soap_instantiate_ns1__getJobProxyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getJobProxyInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getJobProxyInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getJobProxyInfo);
		if (size)
			*size = sizeof(struct ns1__getJobProxyInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getJobProxyInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getJobProxyInfo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getJobProxyInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getJobProxyInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getJobProxyInfo %p -> %p\n", q, p));
	*(struct ns1__getJobProxyInfo*)p = *(struct ns1__getJobProxyInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getJobProxyInfoResponse(struct soap *soap, struct ns1__getJobProxyInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_items = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getJobProxyInfoResponse(struct soap *soap, const struct ns1__getJobProxyInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ProxyInfoStructType(soap, &a->_items);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getJobProxyInfoResponse(struct soap *soap, const char *tag, int id, const struct ns1__getJobProxyInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getJobProxyInfoResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__ProxyInfoStructType(soap, "items", -1, &a->_items, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getJobProxyInfoResponse * SOAP_FMAC4 soap_in_ns1__getJobProxyInfoResponse(struct soap *soap, const char *tag, struct ns1__getJobProxyInfoResponse *a, const char *type)
{
	size_t soap_flag__items = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getJobProxyInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getJobProxyInfoResponse, sizeof(struct ns1__getJobProxyInfoResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getJobProxyInfoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__items && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ProxyInfoStructType(soap, NULL, &a->_items, "ns1:ProxyInfoStructType"))
				{	soap_flag__items--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getJobProxyInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getJobProxyInfoResponse, 0, sizeof(struct ns1__getJobProxyInfoResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getJobProxyInfoResponse(struct soap *soap, const struct ns1__getJobProxyInfoResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getJobProxyInfoResponse);
	if (soap_out_ns1__getJobProxyInfoResponse(soap, tag?tag:"ns1:getJobProxyInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getJobProxyInfoResponse * SOAP_FMAC4 soap_get_ns1__getJobProxyInfoResponse(struct soap *soap, struct ns1__getJobProxyInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getJobProxyInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getJobProxyInfoResponse * SOAP_FMAC2 soap_instantiate_ns1__getJobProxyInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getJobProxyInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getJobProxyInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getJobProxyInfoResponse);
		if (size)
			*size = sizeof(struct ns1__getJobProxyInfoResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getJobProxyInfoResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getJobProxyInfoResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getJobProxyInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getJobProxyInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getJobProxyInfoResponse %p -> %p\n", q, p));
	*(struct ns1__getJobProxyInfoResponse*)p = *(struct ns1__getJobProxyInfoResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDelegatedProxyInfo(struct soap *soap, struct ns1__getDelegatedProxyInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_delegationID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDelegatedProxyInfo(struct soap *soap, const struct ns1__getDelegatedProxyInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_delegationID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_delegationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDelegatedProxyInfo(struct soap *soap, const char *tag, int id, const struct ns1__getDelegatedProxyInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDelegatedProxyInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "delegationID", -1, &a->_delegationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDelegatedProxyInfo * SOAP_FMAC4 soap_in_ns1__getDelegatedProxyInfo(struct soap *soap, const char *tag, struct ns1__getDelegatedProxyInfo *a, const char *type)
{
	size_t soap_flag__delegationID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDelegatedProxyInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDelegatedProxyInfo, sizeof(struct ns1__getDelegatedProxyInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getDelegatedProxyInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__delegationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_delegationID, "xsd:string"))
				{	soap_flag__delegationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDelegatedProxyInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDelegatedProxyInfo, 0, sizeof(struct ns1__getDelegatedProxyInfo), 0, soap_copy_ns1__getDelegatedProxyInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__delegationID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDelegatedProxyInfo(struct soap *soap, const struct ns1__getDelegatedProxyInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getDelegatedProxyInfo);
	if (soap_out_ns1__getDelegatedProxyInfo(soap, tag?tag:"ns1:getDelegatedProxyInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getDelegatedProxyInfo * SOAP_FMAC4 soap_get_ns1__getDelegatedProxyInfo(struct soap *soap, struct ns1__getDelegatedProxyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDelegatedProxyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getDelegatedProxyInfo * SOAP_FMAC2 soap_instantiate_ns1__getDelegatedProxyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDelegatedProxyInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDelegatedProxyInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getDelegatedProxyInfo);
		if (size)
			*size = sizeof(struct ns1__getDelegatedProxyInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getDelegatedProxyInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getDelegatedProxyInfo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getDelegatedProxyInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDelegatedProxyInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getDelegatedProxyInfo %p -> %p\n", q, p));
	*(struct ns1__getDelegatedProxyInfo*)p = *(struct ns1__getDelegatedProxyInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDelegatedProxyInfoResponse(struct soap *soap, struct ns1__getDelegatedProxyInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_items = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDelegatedProxyInfoResponse(struct soap *soap, const struct ns1__getDelegatedProxyInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ProxyInfoStructType(soap, &a->_items);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDelegatedProxyInfoResponse(struct soap *soap, const char *tag, int id, const struct ns1__getDelegatedProxyInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDelegatedProxyInfoResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__ProxyInfoStructType(soap, "items", -1, &a->_items, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDelegatedProxyInfoResponse * SOAP_FMAC4 soap_in_ns1__getDelegatedProxyInfoResponse(struct soap *soap, const char *tag, struct ns1__getDelegatedProxyInfoResponse *a, const char *type)
{
	size_t soap_flag__items = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDelegatedProxyInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDelegatedProxyInfoResponse, sizeof(struct ns1__getDelegatedProxyInfoResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getDelegatedProxyInfoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__items && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ProxyInfoStructType(soap, NULL, &a->_items, "ns1:ProxyInfoStructType"))
				{	soap_flag__items--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDelegatedProxyInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDelegatedProxyInfoResponse, 0, sizeof(struct ns1__getDelegatedProxyInfoResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDelegatedProxyInfoResponse(struct soap *soap, const struct ns1__getDelegatedProxyInfoResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getDelegatedProxyInfoResponse);
	if (soap_out_ns1__getDelegatedProxyInfoResponse(soap, tag?tag:"ns1:getDelegatedProxyInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getDelegatedProxyInfoResponse * SOAP_FMAC4 soap_get_ns1__getDelegatedProxyInfoResponse(struct soap *soap, struct ns1__getDelegatedProxyInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDelegatedProxyInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getDelegatedProxyInfoResponse * SOAP_FMAC2 soap_instantiate_ns1__getDelegatedProxyInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDelegatedProxyInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDelegatedProxyInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getDelegatedProxyInfoResponse);
		if (size)
			*size = sizeof(struct ns1__getDelegatedProxyInfoResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getDelegatedProxyInfoResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getDelegatedProxyInfoResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getDelegatedProxyInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDelegatedProxyInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getDelegatedProxyInfoResponse %p -> %p\n", q, p));
	*(struct ns1__getDelegatedProxyInfoResponse*)p = *(struct ns1__getDelegatedProxyInfoResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__removeACLItem(struct soap *soap, struct ns1__removeACLItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_jobId);
	soap_default_std__string(soap, &a->_item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__removeACLItem(struct soap *soap, const struct ns1__removeACLItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_jobId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_jobId);
	soap_embedded(soap, &a->_item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removeACLItem(struct soap *soap, const char *tag, int id, const struct ns1__removeACLItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__removeACLItem), type))
		return soap->error;
	if (soap_out_std__string(soap, "jobId", -1, &a->_jobId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "item", -1, &a->_item, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__removeACLItem * SOAP_FMAC4 soap_in_ns1__removeACLItem(struct soap *soap, const char *tag, struct ns1__removeACLItem *a, const char *type)
{
	size_t soap_flag__jobId = 1;
	size_t soap_flag__item = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__removeACLItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removeACLItem, sizeof(struct ns1__removeACLItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__removeACLItem(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_jobId, "xsd:string"))
				{	soap_flag__jobId--;
					continue;
				}
			if (soap_flag__item && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_item, "xsd:string"))
				{	soap_flag__item--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__removeACLItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__removeACLItem, 0, sizeof(struct ns1__removeACLItem), 0, soap_copy_ns1__removeACLItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__jobId > 0 || soap_flag__item > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__removeACLItem(struct soap *soap, const struct ns1__removeACLItem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__removeACLItem);
	if (soap_out_ns1__removeACLItem(soap, tag?tag:"ns1:removeACLItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__removeACLItem * SOAP_FMAC4 soap_get_ns1__removeACLItem(struct soap *soap, struct ns1__removeACLItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removeACLItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__removeACLItem * SOAP_FMAC2 soap_instantiate_ns1__removeACLItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removeACLItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removeACLItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__removeACLItem);
		if (size)
			*size = sizeof(struct ns1__removeACLItem);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__removeACLItem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__removeACLItem);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__removeACLItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removeACLItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__removeACLItem %p -> %p\n", q, p));
	*(struct ns1__removeACLItem*)p = *(struct ns1__removeACLItem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__removeACLItemResponse(struct soap *soap, struct ns1__removeACLItemResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__removeACLItemResponse(struct soap *soap, const struct ns1__removeACLItemResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removeACLItemResponse(struct soap *soap, const char *tag, int id, const struct ns1__removeACLItemResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__removeACLItemResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__removeACLItemResponse * SOAP_FMAC4 soap_in_ns1__removeACLItemResponse(struct soap *soap, const char *tag, struct ns1__removeACLItemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__removeACLItemResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removeACLItemResponse, sizeof(struct ns1__removeACLItemResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__removeACLItemResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__removeACLItemResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__removeACLItemResponse, 0, sizeof(struct ns1__removeACLItemResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__removeACLItemResponse(struct soap *soap, const struct ns1__removeACLItemResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__removeACLItemResponse);
	if (soap_out_ns1__removeACLItemResponse(soap, tag?tag:"ns1:removeACLItemResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__removeACLItemResponse * SOAP_FMAC4 soap_get_ns1__removeACLItemResponse(struct soap *soap, struct ns1__removeACLItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removeACLItemResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__removeACLItemResponse * SOAP_FMAC2 soap_instantiate_ns1__removeACLItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removeACLItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removeACLItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__removeACLItemResponse);
		if (size)
			*size = sizeof(struct ns1__removeACLItemResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__removeACLItemResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__removeACLItemResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__removeACLItemResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removeACLItemResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__removeACLItemResponse %p -> %p\n", q, p));
	*(struct ns1__removeACLItemResponse*)p = *(struct ns1__removeACLItemResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addACLItems(struct soap *soap, struct ns1__addACLItems *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_jobId);
	a->_items = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addACLItems(struct soap *soap, const struct ns1__addACLItems *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_jobId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_jobId);
	soap_serialize_PointerTons1__StringList(soap, &a->_items);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addACLItems(struct soap *soap, const char *tag, int id, const struct ns1__addACLItems *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addACLItems), type))
		return soap->error;
	if (soap_out_std__string(soap, "jobId", -1, &a->_jobId, ""))
		return soap->error;
	if (soap_out_PointerTons1__StringList(soap, "items", -1, &a->_items, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addACLItems * SOAP_FMAC4 soap_in_ns1__addACLItems(struct soap *soap, const char *tag, struct ns1__addACLItems *a, const char *type)
{
	size_t soap_flag__jobId = 1;
	size_t soap_flag__items = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addACLItems *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addACLItems, sizeof(struct ns1__addACLItems), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__addACLItems(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_jobId, "xsd:string"))
				{	soap_flag__jobId--;
					continue;
				}
			if (soap_flag__items && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__StringList(soap, NULL, &a->_items, "ns1:StringList"))
				{	soap_flag__items--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addACLItems *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addACLItems, 0, sizeof(struct ns1__addACLItems), 0, soap_copy_ns1__addACLItems);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__jobId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addACLItems(struct soap *soap, const struct ns1__addACLItems *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addACLItems);
	if (soap_out_ns1__addACLItems(soap, tag?tag:"ns1:addACLItems", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addACLItems * SOAP_FMAC4 soap_get_ns1__addACLItems(struct soap *soap, struct ns1__addACLItems *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addACLItems(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addACLItems * SOAP_FMAC2 soap_instantiate_ns1__addACLItems(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addACLItems(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addACLItems, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addACLItems);
		if (size)
			*size = sizeof(struct ns1__addACLItems);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addACLItems[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__addACLItems);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__addACLItems*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addACLItems(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addACLItems %p -> %p\n", q, p));
	*(struct ns1__addACLItems*)p = *(struct ns1__addACLItems*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addACLItemsResponse(struct soap *soap, struct ns1__addACLItemsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addACLItemsResponse(struct soap *soap, const struct ns1__addACLItemsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addACLItemsResponse(struct soap *soap, const char *tag, int id, const struct ns1__addACLItemsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addACLItemsResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addACLItemsResponse * SOAP_FMAC4 soap_in_ns1__addACLItemsResponse(struct soap *soap, const char *tag, struct ns1__addACLItemsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addACLItemsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addACLItemsResponse, sizeof(struct ns1__addACLItemsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addACLItemsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addACLItemsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addACLItemsResponse, 0, sizeof(struct ns1__addACLItemsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addACLItemsResponse(struct soap *soap, const struct ns1__addACLItemsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addACLItemsResponse);
	if (soap_out_ns1__addACLItemsResponse(soap, tag?tag:"ns1:addACLItemsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addACLItemsResponse * SOAP_FMAC4 soap_get_ns1__addACLItemsResponse(struct soap *soap, struct ns1__addACLItemsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addACLItemsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addACLItemsResponse * SOAP_FMAC2 soap_instantiate_ns1__addACLItemsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addACLItemsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addACLItemsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addACLItemsResponse);
		if (size)
			*size = sizeof(struct ns1__addACLItemsResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addACLItemsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__addACLItemsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__addACLItemsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addACLItemsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addACLItemsResponse %p -> %p\n", q, p));
	*(struct ns1__addACLItemsResponse*)p = *(struct ns1__addACLItemsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getACLItems(struct soap *soap, struct ns1__getACLItems *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_jobId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getACLItems(struct soap *soap, const struct ns1__getACLItems *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_jobId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_jobId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getACLItems(struct soap *soap, const char *tag, int id, const struct ns1__getACLItems *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getACLItems), type))
		return soap->error;
	if (soap_out_std__string(soap, "jobId", -1, &a->_jobId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getACLItems * SOAP_FMAC4 soap_in_ns1__getACLItems(struct soap *soap, const char *tag, struct ns1__getACLItems *a, const char *type)
{
	size_t soap_flag__jobId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getACLItems *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getACLItems, sizeof(struct ns1__getACLItems), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getACLItems(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_jobId, "xsd:string"))
				{	soap_flag__jobId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getACLItems *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getACLItems, 0, sizeof(struct ns1__getACLItems), 0, soap_copy_ns1__getACLItems);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__jobId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getACLItems(struct soap *soap, const struct ns1__getACLItems *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getACLItems);
	if (soap_out_ns1__getACLItems(soap, tag?tag:"ns1:getACLItems", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getACLItems * SOAP_FMAC4 soap_get_ns1__getACLItems(struct soap *soap, struct ns1__getACLItems *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getACLItems(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getACLItems * SOAP_FMAC2 soap_instantiate_ns1__getACLItems(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getACLItems(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getACLItems, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getACLItems);
		if (size)
			*size = sizeof(struct ns1__getACLItems);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getACLItems[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getACLItems);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getACLItems*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getACLItems(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getACLItems %p -> %p\n", q, p));
	*(struct ns1__getACLItems*)p = *(struct ns1__getACLItems*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getACLItemsResponse(struct soap *soap, struct ns1__getACLItemsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_items = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getACLItemsResponse(struct soap *soap, const struct ns1__getACLItemsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__StringList(soap, &a->_items);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getACLItemsResponse(struct soap *soap, const char *tag, int id, const struct ns1__getACLItemsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getACLItemsResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__StringList(soap, "items", -1, &a->_items, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getACLItemsResponse * SOAP_FMAC4 soap_in_ns1__getACLItemsResponse(struct soap *soap, const char *tag, struct ns1__getACLItemsResponse *a, const char *type)
{
	size_t soap_flag__items = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getACLItemsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getACLItemsResponse, sizeof(struct ns1__getACLItemsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getACLItemsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__items && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__StringList(soap, NULL, &a->_items, "ns1:StringList"))
				{	soap_flag__items--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getACLItemsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getACLItemsResponse, 0, sizeof(struct ns1__getACLItemsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getACLItemsResponse(struct soap *soap, const struct ns1__getACLItemsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getACLItemsResponse);
	if (soap_out_ns1__getACLItemsResponse(soap, tag?tag:"ns1:getACLItemsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getACLItemsResponse * SOAP_FMAC4 soap_get_ns1__getACLItemsResponse(struct soap *soap, struct ns1__getACLItemsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getACLItemsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getACLItemsResponse * SOAP_FMAC2 soap_instantiate_ns1__getACLItemsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getACLItemsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getACLItemsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getACLItemsResponse);
		if (size)
			*size = sizeof(struct ns1__getACLItemsResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getACLItemsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getACLItemsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getACLItemsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getACLItemsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getACLItemsResponse %p -> %p\n", q, p));
	*(struct ns1__getACLItemsResponse*)p = *(struct ns1__getACLItemsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getStringParametricJobTemplate(struct soap *soap, struct ns1__getStringParametricJobTemplate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_attributes = NULL;
	a->_param = NULL;
	soap_default_std__string(soap, &a->_requirements);
	soap_default_std__string(soap, &a->_rank);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getStringParametricJobTemplate(struct soap *soap, const struct ns1__getStringParametricJobTemplate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__StringList(soap, &a->_attributes);
	soap_serialize_PointerTons1__StringList(soap, &a->_param);
	soap_embedded(soap, &a->_requirements, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_requirements);
	soap_embedded(soap, &a->_rank, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_rank);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getStringParametricJobTemplate(struct soap *soap, const char *tag, int id, const struct ns1__getStringParametricJobTemplate *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getStringParametricJobTemplate), type))
		return soap->error;
	if (soap_out_PointerTons1__StringList(soap, "attributes", -1, &a->_attributes, ""))
		return soap->error;
	if (soap_out_PointerTons1__StringList(soap, "param", -1, &a->_param, ""))
		return soap->error;
	if (soap_out_std__string(soap, "requirements", -1, &a->_requirements, ""))
		return soap->error;
	if (soap_out_std__string(soap, "rank", -1, &a->_rank, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getStringParametricJobTemplate * SOAP_FMAC4 soap_in_ns1__getStringParametricJobTemplate(struct soap *soap, const char *tag, struct ns1__getStringParametricJobTemplate *a, const char *type)
{
	size_t soap_flag__attributes = 1;
	size_t soap_flag__param = 1;
	size_t soap_flag__requirements = 1;
	size_t soap_flag__rank = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getStringParametricJobTemplate *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getStringParametricJobTemplate, sizeof(struct ns1__getStringParametricJobTemplate), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getStringParametricJobTemplate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__attributes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__StringList(soap, NULL, &a->_attributes, "ns1:StringList"))
				{	soap_flag__attributes--;
					continue;
				}
			if (soap_flag__param && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__StringList(soap, NULL, &a->_param, "ns1:StringList"))
				{	soap_flag__param--;
					continue;
				}
			if (soap_flag__requirements && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_requirements, "xsd:string"))
				{	soap_flag__requirements--;
					continue;
				}
			if (soap_flag__rank && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_rank, "xsd:string"))
				{	soap_flag__rank--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getStringParametricJobTemplate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getStringParametricJobTemplate, 0, sizeof(struct ns1__getStringParametricJobTemplate), 0, soap_copy_ns1__getStringParametricJobTemplate);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__requirements > 0 || soap_flag__rank > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getStringParametricJobTemplate(struct soap *soap, const struct ns1__getStringParametricJobTemplate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getStringParametricJobTemplate);
	if (soap_out_ns1__getStringParametricJobTemplate(soap, tag?tag:"ns1:getStringParametricJobTemplate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getStringParametricJobTemplate * SOAP_FMAC4 soap_get_ns1__getStringParametricJobTemplate(struct soap *soap, struct ns1__getStringParametricJobTemplate *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getStringParametricJobTemplate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getStringParametricJobTemplate * SOAP_FMAC2 soap_instantiate_ns1__getStringParametricJobTemplate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getStringParametricJobTemplate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getStringParametricJobTemplate, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getStringParametricJobTemplate);
		if (size)
			*size = sizeof(struct ns1__getStringParametricJobTemplate);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getStringParametricJobTemplate[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getStringParametricJobTemplate);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getStringParametricJobTemplate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getStringParametricJobTemplate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getStringParametricJobTemplate %p -> %p\n", q, p));
	*(struct ns1__getStringParametricJobTemplate*)p = *(struct ns1__getStringParametricJobTemplate*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getStringParametricJobTemplateResponse(struct soap *soap, struct ns1__getStringParametricJobTemplateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_jdl);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getStringParametricJobTemplateResponse(struct soap *soap, const struct ns1__getStringParametricJobTemplateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_jdl, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_jdl);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getStringParametricJobTemplateResponse(struct soap *soap, const char *tag, int id, const struct ns1__getStringParametricJobTemplateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getStringParametricJobTemplateResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "jdl", -1, &a->_jdl, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getStringParametricJobTemplateResponse * SOAP_FMAC4 soap_in_ns1__getStringParametricJobTemplateResponse(struct soap *soap, const char *tag, struct ns1__getStringParametricJobTemplateResponse *a, const char *type)
{
	size_t soap_flag__jdl = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getStringParametricJobTemplateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getStringParametricJobTemplateResponse, sizeof(struct ns1__getStringParametricJobTemplateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getStringParametricJobTemplateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jdl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_jdl, "xsd:string"))
				{	soap_flag__jdl--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getStringParametricJobTemplateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getStringParametricJobTemplateResponse, 0, sizeof(struct ns1__getStringParametricJobTemplateResponse), 0, soap_copy_ns1__getStringParametricJobTemplateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__jdl > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getStringParametricJobTemplateResponse(struct soap *soap, const struct ns1__getStringParametricJobTemplateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getStringParametricJobTemplateResponse);
	if (soap_out_ns1__getStringParametricJobTemplateResponse(soap, tag?tag:"ns1:getStringParametricJobTemplateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getStringParametricJobTemplateResponse * SOAP_FMAC4 soap_get_ns1__getStringParametricJobTemplateResponse(struct soap *soap, struct ns1__getStringParametricJobTemplateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getStringParametricJobTemplateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getStringParametricJobTemplateResponse * SOAP_FMAC2 soap_instantiate_ns1__getStringParametricJobTemplateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getStringParametricJobTemplateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getStringParametricJobTemplateResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getStringParametricJobTemplateResponse);
		if (size)
			*size = sizeof(struct ns1__getStringParametricJobTemplateResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getStringParametricJobTemplateResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getStringParametricJobTemplateResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getStringParametricJobTemplateResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getStringParametricJobTemplateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getStringParametricJobTemplateResponse %p -> %p\n", q, p));
	*(struct ns1__getStringParametricJobTemplateResponse*)p = *(struct ns1__getStringParametricJobTemplateResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getIntParametricJobTemplate(struct soap *soap, struct ns1__getIntParametricJobTemplate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_attributes = NULL;
	soap_default_int(soap, &a->_param);
	soap_default_int(soap, &a->_parameterStart);
	soap_default_int(soap, &a->_parameterStep);
	soap_default_std__string(soap, &a->_requirements);
	soap_default_std__string(soap, &a->_rank);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getIntParametricJobTemplate(struct soap *soap, const struct ns1__getIntParametricJobTemplate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__StringList(soap, &a->_attributes);
	soap_embedded(soap, &a->_requirements, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_requirements);
	soap_embedded(soap, &a->_rank, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_rank);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getIntParametricJobTemplate(struct soap *soap, const char *tag, int id, const struct ns1__getIntParametricJobTemplate *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getIntParametricJobTemplate), type))
		return soap->error;
	if (soap_out_PointerTons1__StringList(soap, "attributes", -1, &a->_attributes, ""))
		return soap->error;
	if (soap_out_int(soap, "param", -1, &a->_param, ""))
		return soap->error;
	if (soap_out_int(soap, "parameterStart", -1, &a->_parameterStart, ""))
		return soap->error;
	if (soap_out_int(soap, "parameterStep", -1, &a->_parameterStep, ""))
		return soap->error;
	if (soap_out_std__string(soap, "requirements", -1, &a->_requirements, ""))
		return soap->error;
	if (soap_out_std__string(soap, "rank", -1, &a->_rank, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getIntParametricJobTemplate * SOAP_FMAC4 soap_in_ns1__getIntParametricJobTemplate(struct soap *soap, const char *tag, struct ns1__getIntParametricJobTemplate *a, const char *type)
{
	size_t soap_flag__attributes = 1;
	size_t soap_flag__param = 1;
	size_t soap_flag__parameterStart = 1;
	size_t soap_flag__parameterStep = 1;
	size_t soap_flag__requirements = 1;
	size_t soap_flag__rank = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getIntParametricJobTemplate *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getIntParametricJobTemplate, sizeof(struct ns1__getIntParametricJobTemplate), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getIntParametricJobTemplate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__attributes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__StringList(soap, NULL, &a->_attributes, "ns1:StringList"))
				{	soap_flag__attributes--;
					continue;
				}
			if (soap_flag__param && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_param, "xsd:int"))
				{	soap_flag__param--;
					continue;
				}
			if (soap_flag__parameterStart && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_parameterStart, "xsd:int"))
				{	soap_flag__parameterStart--;
					continue;
				}
			if (soap_flag__parameterStep && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_parameterStep, "xsd:int"))
				{	soap_flag__parameterStep--;
					continue;
				}
			if (soap_flag__requirements && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_requirements, "xsd:string"))
				{	soap_flag__requirements--;
					continue;
				}
			if (soap_flag__rank && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_rank, "xsd:string"))
				{	soap_flag__rank--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getIntParametricJobTemplate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getIntParametricJobTemplate, 0, sizeof(struct ns1__getIntParametricJobTemplate), 0, soap_copy_ns1__getIntParametricJobTemplate);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__param > 0 || soap_flag__parameterStart > 0 || soap_flag__parameterStep > 0 || soap_flag__requirements > 0 || soap_flag__rank > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getIntParametricJobTemplate(struct soap *soap, const struct ns1__getIntParametricJobTemplate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getIntParametricJobTemplate);
	if (soap_out_ns1__getIntParametricJobTemplate(soap, tag?tag:"ns1:getIntParametricJobTemplate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getIntParametricJobTemplate * SOAP_FMAC4 soap_get_ns1__getIntParametricJobTemplate(struct soap *soap, struct ns1__getIntParametricJobTemplate *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getIntParametricJobTemplate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getIntParametricJobTemplate * SOAP_FMAC2 soap_instantiate_ns1__getIntParametricJobTemplate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getIntParametricJobTemplate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getIntParametricJobTemplate, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getIntParametricJobTemplate);
		if (size)
			*size = sizeof(struct ns1__getIntParametricJobTemplate);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getIntParametricJobTemplate[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getIntParametricJobTemplate);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getIntParametricJobTemplate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getIntParametricJobTemplate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getIntParametricJobTemplate %p -> %p\n", q, p));
	*(struct ns1__getIntParametricJobTemplate*)p = *(struct ns1__getIntParametricJobTemplate*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getIntParametricJobTemplateResponse(struct soap *soap, struct ns1__getIntParametricJobTemplateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_jdl);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getIntParametricJobTemplateResponse(struct soap *soap, const struct ns1__getIntParametricJobTemplateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_jdl, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_jdl);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getIntParametricJobTemplateResponse(struct soap *soap, const char *tag, int id, const struct ns1__getIntParametricJobTemplateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getIntParametricJobTemplateResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "jdl", -1, &a->_jdl, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getIntParametricJobTemplateResponse * SOAP_FMAC4 soap_in_ns1__getIntParametricJobTemplateResponse(struct soap *soap, const char *tag, struct ns1__getIntParametricJobTemplateResponse *a, const char *type)
{
	size_t soap_flag__jdl = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getIntParametricJobTemplateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getIntParametricJobTemplateResponse, sizeof(struct ns1__getIntParametricJobTemplateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getIntParametricJobTemplateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jdl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_jdl, "xsd:string"))
				{	soap_flag__jdl--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getIntParametricJobTemplateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getIntParametricJobTemplateResponse, 0, sizeof(struct ns1__getIntParametricJobTemplateResponse), 0, soap_copy_ns1__getIntParametricJobTemplateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__jdl > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getIntParametricJobTemplateResponse(struct soap *soap, const struct ns1__getIntParametricJobTemplateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getIntParametricJobTemplateResponse);
	if (soap_out_ns1__getIntParametricJobTemplateResponse(soap, tag?tag:"ns1:getIntParametricJobTemplateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getIntParametricJobTemplateResponse * SOAP_FMAC4 soap_get_ns1__getIntParametricJobTemplateResponse(struct soap *soap, struct ns1__getIntParametricJobTemplateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getIntParametricJobTemplateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getIntParametricJobTemplateResponse * SOAP_FMAC2 soap_instantiate_ns1__getIntParametricJobTemplateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getIntParametricJobTemplateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getIntParametricJobTemplateResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getIntParametricJobTemplateResponse);
		if (size)
			*size = sizeof(struct ns1__getIntParametricJobTemplateResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getIntParametricJobTemplateResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getIntParametricJobTemplateResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getIntParametricJobTemplateResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getIntParametricJobTemplateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getIntParametricJobTemplateResponse %p -> %p\n", q, p));
	*(struct ns1__getIntParametricJobTemplateResponse*)p = *(struct ns1__getIntParametricJobTemplateResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getCollectionTemplate(struct soap *soap, struct ns1__getCollectionTemplate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_jobNumber);
	soap_default_std__string(soap, &a->_requirements);
	soap_default_std__string(soap, &a->_rank);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getCollectionTemplate(struct soap *soap, const struct ns1__getCollectionTemplate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_requirements, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_requirements);
	soap_embedded(soap, &a->_rank, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_rank);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getCollectionTemplate(struct soap *soap, const char *tag, int id, const struct ns1__getCollectionTemplate *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getCollectionTemplate), type))
		return soap->error;
	if (soap_out_int(soap, "jobNumber", -1, &a->_jobNumber, ""))
		return soap->error;
	if (soap_out_std__string(soap, "requirements", -1, &a->_requirements, ""))
		return soap->error;
	if (soap_out_std__string(soap, "rank", -1, &a->_rank, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getCollectionTemplate * SOAP_FMAC4 soap_in_ns1__getCollectionTemplate(struct soap *soap, const char *tag, struct ns1__getCollectionTemplate *a, const char *type)
{
	size_t soap_flag__jobNumber = 1;
	size_t soap_flag__requirements = 1;
	size_t soap_flag__rank = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getCollectionTemplate *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getCollectionTemplate, sizeof(struct ns1__getCollectionTemplate), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getCollectionTemplate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_jobNumber, "xsd:int"))
				{	soap_flag__jobNumber--;
					continue;
				}
			if (soap_flag__requirements && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_requirements, "xsd:string"))
				{	soap_flag__requirements--;
					continue;
				}
			if (soap_flag__rank && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_rank, "xsd:string"))
				{	soap_flag__rank--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getCollectionTemplate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getCollectionTemplate, 0, sizeof(struct ns1__getCollectionTemplate), 0, soap_copy_ns1__getCollectionTemplate);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__jobNumber > 0 || soap_flag__requirements > 0 || soap_flag__rank > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getCollectionTemplate(struct soap *soap, const struct ns1__getCollectionTemplate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getCollectionTemplate);
	if (soap_out_ns1__getCollectionTemplate(soap, tag?tag:"ns1:getCollectionTemplate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getCollectionTemplate * SOAP_FMAC4 soap_get_ns1__getCollectionTemplate(struct soap *soap, struct ns1__getCollectionTemplate *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getCollectionTemplate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getCollectionTemplate * SOAP_FMAC2 soap_instantiate_ns1__getCollectionTemplate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getCollectionTemplate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getCollectionTemplate, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getCollectionTemplate);
		if (size)
			*size = sizeof(struct ns1__getCollectionTemplate);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getCollectionTemplate[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getCollectionTemplate);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getCollectionTemplate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getCollectionTemplate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getCollectionTemplate %p -> %p\n", q, p));
	*(struct ns1__getCollectionTemplate*)p = *(struct ns1__getCollectionTemplate*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getCollectionTemplateResponse(struct soap *soap, struct ns1__getCollectionTemplateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_jdl);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getCollectionTemplateResponse(struct soap *soap, const struct ns1__getCollectionTemplateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_jdl, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_jdl);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getCollectionTemplateResponse(struct soap *soap, const char *tag, int id, const struct ns1__getCollectionTemplateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getCollectionTemplateResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "jdl", -1, &a->_jdl, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getCollectionTemplateResponse * SOAP_FMAC4 soap_in_ns1__getCollectionTemplateResponse(struct soap *soap, const char *tag, struct ns1__getCollectionTemplateResponse *a, const char *type)
{
	size_t soap_flag__jdl = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getCollectionTemplateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getCollectionTemplateResponse, sizeof(struct ns1__getCollectionTemplateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getCollectionTemplateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jdl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_jdl, "xsd:string"))
				{	soap_flag__jdl--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getCollectionTemplateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getCollectionTemplateResponse, 0, sizeof(struct ns1__getCollectionTemplateResponse), 0, soap_copy_ns1__getCollectionTemplateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__jdl > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getCollectionTemplateResponse(struct soap *soap, const struct ns1__getCollectionTemplateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getCollectionTemplateResponse);
	if (soap_out_ns1__getCollectionTemplateResponse(soap, tag?tag:"ns1:getCollectionTemplateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getCollectionTemplateResponse * SOAP_FMAC4 soap_get_ns1__getCollectionTemplateResponse(struct soap *soap, struct ns1__getCollectionTemplateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getCollectionTemplateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getCollectionTemplateResponse * SOAP_FMAC2 soap_instantiate_ns1__getCollectionTemplateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getCollectionTemplateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getCollectionTemplateResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getCollectionTemplateResponse);
		if (size)
			*size = sizeof(struct ns1__getCollectionTemplateResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getCollectionTemplateResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getCollectionTemplateResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getCollectionTemplateResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getCollectionTemplateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getCollectionTemplateResponse %p -> %p\n", q, p));
	*(struct ns1__getCollectionTemplateResponse*)p = *(struct ns1__getCollectionTemplateResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDAGTemplate(struct soap *soap, struct ns1__getDAGTemplate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_dependencies = NULL;
	soap_default_std__string(soap, &a->_requirements);
	soap_default_std__string(soap, &a->_rank);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDAGTemplate(struct soap *soap, const struct ns1__getDAGTemplate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__GraphStructType(soap, &a->_dependencies);
	soap_embedded(soap, &a->_requirements, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_requirements);
	soap_embedded(soap, &a->_rank, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_rank);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDAGTemplate(struct soap *soap, const char *tag, int id, const struct ns1__getDAGTemplate *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDAGTemplate), type))
		return soap->error;
	if (soap_out_PointerTons1__GraphStructType(soap, "dependencies", -1, &a->_dependencies, ""))
		return soap->error;
	if (soap_out_std__string(soap, "requirements", -1, &a->_requirements, ""))
		return soap->error;
	if (soap_out_std__string(soap, "rank", -1, &a->_rank, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDAGTemplate * SOAP_FMAC4 soap_in_ns1__getDAGTemplate(struct soap *soap, const char *tag, struct ns1__getDAGTemplate *a, const char *type)
{
	size_t soap_flag__dependencies = 1;
	size_t soap_flag__requirements = 1;
	size_t soap_flag__rank = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDAGTemplate *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDAGTemplate, sizeof(struct ns1__getDAGTemplate), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getDAGTemplate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__dependencies && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__GraphStructType(soap, NULL, &a->_dependencies, "ns1:GraphStructType"))
				{	soap_flag__dependencies--;
					continue;
				}
			if (soap_flag__requirements && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_requirements, "xsd:string"))
				{	soap_flag__requirements--;
					continue;
				}
			if (soap_flag__rank && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_rank, "xsd:string"))
				{	soap_flag__rank--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDAGTemplate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDAGTemplate, 0, sizeof(struct ns1__getDAGTemplate), 0, soap_copy_ns1__getDAGTemplate);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__requirements > 0 || soap_flag__rank > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDAGTemplate(struct soap *soap, const struct ns1__getDAGTemplate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getDAGTemplate);
	if (soap_out_ns1__getDAGTemplate(soap, tag?tag:"ns1:getDAGTemplate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getDAGTemplate * SOAP_FMAC4 soap_get_ns1__getDAGTemplate(struct soap *soap, struct ns1__getDAGTemplate *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDAGTemplate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getDAGTemplate * SOAP_FMAC2 soap_instantiate_ns1__getDAGTemplate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDAGTemplate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDAGTemplate, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getDAGTemplate);
		if (size)
			*size = sizeof(struct ns1__getDAGTemplate);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getDAGTemplate[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getDAGTemplate);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getDAGTemplate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDAGTemplate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getDAGTemplate %p -> %p\n", q, p));
	*(struct ns1__getDAGTemplate*)p = *(struct ns1__getDAGTemplate*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDAGTemplateResponse(struct soap *soap, struct ns1__getDAGTemplateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_jdl);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDAGTemplateResponse(struct soap *soap, const struct ns1__getDAGTemplateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_jdl, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_jdl);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDAGTemplateResponse(struct soap *soap, const char *tag, int id, const struct ns1__getDAGTemplateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDAGTemplateResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "jdl", -1, &a->_jdl, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDAGTemplateResponse * SOAP_FMAC4 soap_in_ns1__getDAGTemplateResponse(struct soap *soap, const char *tag, struct ns1__getDAGTemplateResponse *a, const char *type)
{
	size_t soap_flag__jdl = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDAGTemplateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDAGTemplateResponse, sizeof(struct ns1__getDAGTemplateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getDAGTemplateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jdl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_jdl, "xsd:string"))
				{	soap_flag__jdl--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDAGTemplateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDAGTemplateResponse, 0, sizeof(struct ns1__getDAGTemplateResponse), 0, soap_copy_ns1__getDAGTemplateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__jdl > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDAGTemplateResponse(struct soap *soap, const struct ns1__getDAGTemplateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getDAGTemplateResponse);
	if (soap_out_ns1__getDAGTemplateResponse(soap, tag?tag:"ns1:getDAGTemplateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getDAGTemplateResponse * SOAP_FMAC4 soap_get_ns1__getDAGTemplateResponse(struct soap *soap, struct ns1__getDAGTemplateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDAGTemplateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getDAGTemplateResponse * SOAP_FMAC2 soap_instantiate_ns1__getDAGTemplateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDAGTemplateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDAGTemplateResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getDAGTemplateResponse);
		if (size)
			*size = sizeof(struct ns1__getDAGTemplateResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getDAGTemplateResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getDAGTemplateResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getDAGTemplateResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDAGTemplateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getDAGTemplateResponse %p -> %p\n", q, p));
	*(struct ns1__getDAGTemplateResponse*)p = *(struct ns1__getDAGTemplateResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getJobTemplate(struct soap *soap, struct ns1__getJobTemplate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobType = NULL;
	soap_default_std__string(soap, &a->_executable);
	soap_default_std__string(soap, &a->_arguments);
	soap_default_std__string(soap, &a->_requirements);
	soap_default_std__string(soap, &a->_rank);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getJobTemplate(struct soap *soap, const struct ns1__getJobTemplate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__JobTypeList(soap, &a->_jobType);
	soap_embedded(soap, &a->_executable, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_executable);
	soap_embedded(soap, &a->_arguments, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_arguments);
	soap_embedded(soap, &a->_requirements, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_requirements);
	soap_embedded(soap, &a->_rank, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_rank);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getJobTemplate(struct soap *soap, const char *tag, int id, const struct ns1__getJobTemplate *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getJobTemplate), type))
		return soap->error;
	if (soap_out_PointerTons1__JobTypeList(soap, "jobType", -1, &a->_jobType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "executable", -1, &a->_executable, ""))
		return soap->error;
	if (soap_out_std__string(soap, "arguments", -1, &a->_arguments, ""))
		return soap->error;
	if (soap_out_std__string(soap, "requirements", -1, &a->_requirements, ""))
		return soap->error;
	if (soap_out_std__string(soap, "rank", -1, &a->_rank, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getJobTemplate * SOAP_FMAC4 soap_in_ns1__getJobTemplate(struct soap *soap, const char *tag, struct ns1__getJobTemplate *a, const char *type)
{
	size_t soap_flag__jobType = 1;
	size_t soap_flag__executable = 1;
	size_t soap_flag__arguments = 1;
	size_t soap_flag__requirements = 1;
	size_t soap_flag__rank = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getJobTemplate *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getJobTemplate, sizeof(struct ns1__getJobTemplate), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getJobTemplate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__JobTypeList(soap, NULL, &a->_jobType, "ns1:JobTypeList"))
				{	soap_flag__jobType--;
					continue;
				}
			if (soap_flag__executable && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_executable, "xsd:string"))
				{	soap_flag__executable--;
					continue;
				}
			if (soap_flag__arguments && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_arguments, "xsd:string"))
				{	soap_flag__arguments--;
					continue;
				}
			if (soap_flag__requirements && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_requirements, "xsd:string"))
				{	soap_flag__requirements--;
					continue;
				}
			if (soap_flag__rank && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_rank, "xsd:string"))
				{	soap_flag__rank--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getJobTemplate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getJobTemplate, 0, sizeof(struct ns1__getJobTemplate), 0, soap_copy_ns1__getJobTemplate);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__executable > 0 || soap_flag__arguments > 0 || soap_flag__requirements > 0 || soap_flag__rank > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getJobTemplate(struct soap *soap, const struct ns1__getJobTemplate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getJobTemplate);
	if (soap_out_ns1__getJobTemplate(soap, tag?tag:"ns1:getJobTemplate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getJobTemplate * SOAP_FMAC4 soap_get_ns1__getJobTemplate(struct soap *soap, struct ns1__getJobTemplate *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getJobTemplate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getJobTemplate * SOAP_FMAC2 soap_instantiate_ns1__getJobTemplate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getJobTemplate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getJobTemplate, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getJobTemplate);
		if (size)
			*size = sizeof(struct ns1__getJobTemplate);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getJobTemplate[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getJobTemplate);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getJobTemplate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getJobTemplate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getJobTemplate %p -> %p\n", q, p));
	*(struct ns1__getJobTemplate*)p = *(struct ns1__getJobTemplate*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getJobTemplateResponse(struct soap *soap, struct ns1__getJobTemplateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_jdl);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getJobTemplateResponse(struct soap *soap, const struct ns1__getJobTemplateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_jdl, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_jdl);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getJobTemplateResponse(struct soap *soap, const char *tag, int id, const struct ns1__getJobTemplateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getJobTemplateResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "jdl", -1, &a->_jdl, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getJobTemplateResponse * SOAP_FMAC4 soap_in_ns1__getJobTemplateResponse(struct soap *soap, const char *tag, struct ns1__getJobTemplateResponse *a, const char *type)
{
	size_t soap_flag__jdl = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getJobTemplateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getJobTemplateResponse, sizeof(struct ns1__getJobTemplateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getJobTemplateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jdl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_jdl, "xsd:string"))
				{	soap_flag__jdl--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getJobTemplateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getJobTemplateResponse, 0, sizeof(struct ns1__getJobTemplateResponse), 0, soap_copy_ns1__getJobTemplateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__jdl > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getJobTemplateResponse(struct soap *soap, const struct ns1__getJobTemplateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getJobTemplateResponse);
	if (soap_out_ns1__getJobTemplateResponse(soap, tag?tag:"ns1:getJobTemplateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getJobTemplateResponse * SOAP_FMAC4 soap_get_ns1__getJobTemplateResponse(struct soap *soap, struct ns1__getJobTemplateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getJobTemplateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getJobTemplateResponse * SOAP_FMAC2 soap_instantiate_ns1__getJobTemplateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getJobTemplateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getJobTemplateResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getJobTemplateResponse);
		if (size)
			*size = sizeof(struct ns1__getJobTemplateResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getJobTemplateResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getJobTemplateResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getJobTemplateResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getJobTemplateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getJobTemplateResponse %p -> %p\n", q, p));
	*(struct ns1__getJobTemplateResponse*)p = *(struct ns1__getJobTemplateResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__jobListMatchJSDL(struct soap *soap, struct ns1__jobListMatchJSDL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jsdl = NULL;
	soap_default_std__string(soap, &a->_delegationId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__jobListMatchJSDL(struct soap *soap, const struct ns1__jobListMatchJSDL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__JobDefinition_USCOREType(soap, &a->_jsdl);
	soap_embedded(soap, &a->_delegationId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_delegationId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__jobListMatchJSDL(struct soap *soap, const char *tag, int id, const struct ns1__jobListMatchJSDL *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__jobListMatchJSDL), type))
		return soap->error;
	if (soap_out_PointerTojsdl__JobDefinition_USCOREType(soap, "jsdl", -1, &a->_jsdl, ""))
		return soap->error;
	if (soap_out_std__string(soap, "delegationId", -1, &a->_delegationId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__jobListMatchJSDL * SOAP_FMAC4 soap_in_ns1__jobListMatchJSDL(struct soap *soap, const char *tag, struct ns1__jobListMatchJSDL *a, const char *type)
{
	size_t soap_flag__jsdl = 1;
	size_t soap_flag__delegationId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__jobListMatchJSDL *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__jobListMatchJSDL, sizeof(struct ns1__jobListMatchJSDL), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__jobListMatchJSDL(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jsdl && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__JobDefinition_USCOREType(soap, NULL, &a->_jsdl, "jsdl:JobDefinition_Type"))
				{	soap_flag__jsdl--;
					continue;
				}
			if (soap_flag__delegationId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_delegationId, "xsd:string"))
				{	soap_flag__delegationId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__jobListMatchJSDL *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__jobListMatchJSDL, 0, sizeof(struct ns1__jobListMatchJSDL), 0, soap_copy_ns1__jobListMatchJSDL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__delegationId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__jobListMatchJSDL(struct soap *soap, const struct ns1__jobListMatchJSDL *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__jobListMatchJSDL);
	if (soap_out_ns1__jobListMatchJSDL(soap, tag?tag:"ns1:jobListMatchJSDL", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__jobListMatchJSDL * SOAP_FMAC4 soap_get_ns1__jobListMatchJSDL(struct soap *soap, struct ns1__jobListMatchJSDL *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__jobListMatchJSDL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__jobListMatchJSDL * SOAP_FMAC2 soap_instantiate_ns1__jobListMatchJSDL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__jobListMatchJSDL(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__jobListMatchJSDL, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobListMatchJSDL);
		if (size)
			*size = sizeof(struct ns1__jobListMatchJSDL);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobListMatchJSDL[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__jobListMatchJSDL);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__jobListMatchJSDL*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__jobListMatchJSDL(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__jobListMatchJSDL %p -> %p\n", q, p));
	*(struct ns1__jobListMatchJSDL*)p = *(struct ns1__jobListMatchJSDL*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__jobListMatchJSDLResponse(struct soap *soap, struct ns1__jobListMatchJSDLResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_CEIdAndRankList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__jobListMatchJSDLResponse(struct soap *soap, const struct ns1__jobListMatchJSDLResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__StringAndLongList(soap, &a->_CEIdAndRankList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__jobListMatchJSDLResponse(struct soap *soap, const char *tag, int id, const struct ns1__jobListMatchJSDLResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__jobListMatchJSDLResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__StringAndLongList(soap, "CEIdAndRankList", -1, &a->_CEIdAndRankList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__jobListMatchJSDLResponse * SOAP_FMAC4 soap_in_ns1__jobListMatchJSDLResponse(struct soap *soap, const char *tag, struct ns1__jobListMatchJSDLResponse *a, const char *type)
{
	size_t soap_flag__CEIdAndRankList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__jobListMatchJSDLResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__jobListMatchJSDLResponse, sizeof(struct ns1__jobListMatchJSDLResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__jobListMatchJSDLResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__CEIdAndRankList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__StringAndLongList(soap, NULL, &a->_CEIdAndRankList, "ns1:StringAndLongList"))
				{	soap_flag__CEIdAndRankList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__jobListMatchJSDLResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__jobListMatchJSDLResponse, 0, sizeof(struct ns1__jobListMatchJSDLResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__jobListMatchJSDLResponse(struct soap *soap, const struct ns1__jobListMatchJSDLResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__jobListMatchJSDLResponse);
	if (soap_out_ns1__jobListMatchJSDLResponse(soap, tag?tag:"ns1:jobListMatchJSDLResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__jobListMatchJSDLResponse * SOAP_FMAC4 soap_get_ns1__jobListMatchJSDLResponse(struct soap *soap, struct ns1__jobListMatchJSDLResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__jobListMatchJSDLResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__jobListMatchJSDLResponse * SOAP_FMAC2 soap_instantiate_ns1__jobListMatchJSDLResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__jobListMatchJSDLResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__jobListMatchJSDLResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobListMatchJSDLResponse);
		if (size)
			*size = sizeof(struct ns1__jobListMatchJSDLResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobListMatchJSDLResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__jobListMatchJSDLResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__jobListMatchJSDLResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__jobListMatchJSDLResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__jobListMatchJSDLResponse %p -> %p\n", q, p));
	*(struct ns1__jobListMatchJSDLResponse*)p = *(struct ns1__jobListMatchJSDLResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__jobListMatch(struct soap *soap, struct ns1__jobListMatch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_jdl);
	soap_default_std__string(soap, &a->_delegationId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__jobListMatch(struct soap *soap, const struct ns1__jobListMatch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_jdl, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_jdl);
	soap_embedded(soap, &a->_delegationId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_delegationId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__jobListMatch(struct soap *soap, const char *tag, int id, const struct ns1__jobListMatch *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__jobListMatch), type))
		return soap->error;
	if (soap_out_std__string(soap, "jdl", -1, &a->_jdl, ""))
		return soap->error;
	if (soap_out_std__string(soap, "delegationId", -1, &a->_delegationId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__jobListMatch * SOAP_FMAC4 soap_in_ns1__jobListMatch(struct soap *soap, const char *tag, struct ns1__jobListMatch *a, const char *type)
{
	size_t soap_flag__jdl = 1;
	size_t soap_flag__delegationId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__jobListMatch *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__jobListMatch, sizeof(struct ns1__jobListMatch), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__jobListMatch(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jdl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_jdl, "xsd:string"))
				{	soap_flag__jdl--;
					continue;
				}
			if (soap_flag__delegationId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_delegationId, "xsd:string"))
				{	soap_flag__delegationId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__jobListMatch *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__jobListMatch, 0, sizeof(struct ns1__jobListMatch), 0, soap_copy_ns1__jobListMatch);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__jdl > 0 || soap_flag__delegationId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__jobListMatch(struct soap *soap, const struct ns1__jobListMatch *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__jobListMatch);
	if (soap_out_ns1__jobListMatch(soap, tag?tag:"ns1:jobListMatch", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__jobListMatch * SOAP_FMAC4 soap_get_ns1__jobListMatch(struct soap *soap, struct ns1__jobListMatch *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__jobListMatch(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__jobListMatch * SOAP_FMAC2 soap_instantiate_ns1__jobListMatch(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__jobListMatch(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__jobListMatch, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobListMatch);
		if (size)
			*size = sizeof(struct ns1__jobListMatch);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobListMatch[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__jobListMatch);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__jobListMatch*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__jobListMatch(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__jobListMatch %p -> %p\n", q, p));
	*(struct ns1__jobListMatch*)p = *(struct ns1__jobListMatch*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__jobListMatchResponse(struct soap *soap, struct ns1__jobListMatchResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_CEIdAndRankList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__jobListMatchResponse(struct soap *soap, const struct ns1__jobListMatchResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__StringAndLongList(soap, &a->_CEIdAndRankList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__jobListMatchResponse(struct soap *soap, const char *tag, int id, const struct ns1__jobListMatchResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__jobListMatchResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__StringAndLongList(soap, "CEIdAndRankList", -1, &a->_CEIdAndRankList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__jobListMatchResponse * SOAP_FMAC4 soap_in_ns1__jobListMatchResponse(struct soap *soap, const char *tag, struct ns1__jobListMatchResponse *a, const char *type)
{
	size_t soap_flag__CEIdAndRankList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__jobListMatchResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__jobListMatchResponse, sizeof(struct ns1__jobListMatchResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__jobListMatchResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__CEIdAndRankList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__StringAndLongList(soap, NULL, &a->_CEIdAndRankList, "ns1:StringAndLongList"))
				{	soap_flag__CEIdAndRankList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__jobListMatchResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__jobListMatchResponse, 0, sizeof(struct ns1__jobListMatchResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__jobListMatchResponse(struct soap *soap, const struct ns1__jobListMatchResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__jobListMatchResponse);
	if (soap_out_ns1__jobListMatchResponse(soap, tag?tag:"ns1:jobListMatchResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__jobListMatchResponse * SOAP_FMAC4 soap_get_ns1__jobListMatchResponse(struct soap *soap, struct ns1__jobListMatchResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__jobListMatchResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__jobListMatchResponse * SOAP_FMAC2 soap_instantiate_ns1__jobListMatchResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__jobListMatchResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__jobListMatchResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobListMatchResponse);
		if (size)
			*size = sizeof(struct ns1__jobListMatchResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobListMatchResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__jobListMatchResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__jobListMatchResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__jobListMatchResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__jobListMatchResponse %p -> %p\n", q, p));
	*(struct ns1__jobListMatchResponse*)p = *(struct ns1__jobListMatchResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getOutputFileList(struct soap *soap, struct ns1__getOutputFileList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_jobId);
	soap_default_std__string(soap, &a->_protocol);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getOutputFileList(struct soap *soap, const struct ns1__getOutputFileList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_jobId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_jobId);
	soap_embedded(soap, &a->_protocol, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_protocol);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getOutputFileList(struct soap *soap, const char *tag, int id, const struct ns1__getOutputFileList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getOutputFileList), type))
		return soap->error;
	if (soap_out_std__string(soap, "jobId", -1, &a->_jobId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "protocol", -1, &a->_protocol, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getOutputFileList * SOAP_FMAC4 soap_in_ns1__getOutputFileList(struct soap *soap, const char *tag, struct ns1__getOutputFileList *a, const char *type)
{
	size_t soap_flag__jobId = 1;
	size_t soap_flag__protocol = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getOutputFileList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getOutputFileList, sizeof(struct ns1__getOutputFileList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getOutputFileList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_jobId, "xsd:string"))
				{	soap_flag__jobId--;
					continue;
				}
			if (soap_flag__protocol && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_protocol, "xsd:string"))
				{	soap_flag__protocol--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getOutputFileList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getOutputFileList, 0, sizeof(struct ns1__getOutputFileList), 0, soap_copy_ns1__getOutputFileList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__jobId > 0 || soap_flag__protocol > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getOutputFileList(struct soap *soap, const struct ns1__getOutputFileList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getOutputFileList);
	if (soap_out_ns1__getOutputFileList(soap, tag?tag:"ns1:getOutputFileList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getOutputFileList * SOAP_FMAC4 soap_get_ns1__getOutputFileList(struct soap *soap, struct ns1__getOutputFileList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getOutputFileList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getOutputFileList * SOAP_FMAC2 soap_instantiate_ns1__getOutputFileList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getOutputFileList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getOutputFileList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getOutputFileList);
		if (size)
			*size = sizeof(struct ns1__getOutputFileList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getOutputFileList[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getOutputFileList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getOutputFileList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getOutputFileList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getOutputFileList %p -> %p\n", q, p));
	*(struct ns1__getOutputFileList*)p = *(struct ns1__getOutputFileList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getOutputFileListResponse(struct soap *soap, struct ns1__getOutputFileListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_OutputFileAndSizeList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getOutputFileListResponse(struct soap *soap, const struct ns1__getOutputFileListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__StringAndLongList(soap, &a->_OutputFileAndSizeList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getOutputFileListResponse(struct soap *soap, const char *tag, int id, const struct ns1__getOutputFileListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getOutputFileListResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__StringAndLongList(soap, "OutputFileAndSizeList", -1, &a->_OutputFileAndSizeList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getOutputFileListResponse * SOAP_FMAC4 soap_in_ns1__getOutputFileListResponse(struct soap *soap, const char *tag, struct ns1__getOutputFileListResponse *a, const char *type)
{
	size_t soap_flag__OutputFileAndSizeList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getOutputFileListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getOutputFileListResponse, sizeof(struct ns1__getOutputFileListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getOutputFileListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__OutputFileAndSizeList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__StringAndLongList(soap, NULL, &a->_OutputFileAndSizeList, "ns1:StringAndLongList"))
				{	soap_flag__OutputFileAndSizeList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getOutputFileListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getOutputFileListResponse, 0, sizeof(struct ns1__getOutputFileListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getOutputFileListResponse(struct soap *soap, const struct ns1__getOutputFileListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getOutputFileListResponse);
	if (soap_out_ns1__getOutputFileListResponse(soap, tag?tag:"ns1:getOutputFileListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getOutputFileListResponse * SOAP_FMAC4 soap_get_ns1__getOutputFileListResponse(struct soap *soap, struct ns1__getOutputFileListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getOutputFileListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getOutputFileListResponse * SOAP_FMAC2 soap_instantiate_ns1__getOutputFileListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getOutputFileListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getOutputFileListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getOutputFileListResponse);
		if (size)
			*size = sizeof(struct ns1__getOutputFileListResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getOutputFileListResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getOutputFileListResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getOutputFileListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getOutputFileListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getOutputFileListResponse %p -> %p\n", q, p));
	*(struct ns1__getOutputFileListResponse*)p = *(struct ns1__getOutputFileListResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__jobPurge(struct soap *soap, struct ns1__jobPurge *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_jobId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__jobPurge(struct soap *soap, const struct ns1__jobPurge *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_jobId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_jobId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__jobPurge(struct soap *soap, const char *tag, int id, const struct ns1__jobPurge *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__jobPurge), type))
		return soap->error;
	if (soap_out_std__string(soap, "jobId", -1, &a->_jobId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__jobPurge * SOAP_FMAC4 soap_in_ns1__jobPurge(struct soap *soap, const char *tag, struct ns1__jobPurge *a, const char *type)
{
	size_t soap_flag__jobId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__jobPurge *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__jobPurge, sizeof(struct ns1__jobPurge), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__jobPurge(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_jobId, "xsd:string"))
				{	soap_flag__jobId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__jobPurge *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__jobPurge, 0, sizeof(struct ns1__jobPurge), 0, soap_copy_ns1__jobPurge);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__jobId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__jobPurge(struct soap *soap, const struct ns1__jobPurge *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__jobPurge);
	if (soap_out_ns1__jobPurge(soap, tag?tag:"ns1:jobPurge", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__jobPurge * SOAP_FMAC4 soap_get_ns1__jobPurge(struct soap *soap, struct ns1__jobPurge *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__jobPurge(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__jobPurge * SOAP_FMAC2 soap_instantiate_ns1__jobPurge(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__jobPurge(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__jobPurge, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobPurge);
		if (size)
			*size = sizeof(struct ns1__jobPurge);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobPurge[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__jobPurge);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__jobPurge*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__jobPurge(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__jobPurge %p -> %p\n", q, p));
	*(struct ns1__jobPurge*)p = *(struct ns1__jobPurge*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__jobPurgeResponse(struct soap *soap, struct ns1__jobPurgeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__jobPurgeResponse(struct soap *soap, const struct ns1__jobPurgeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__jobPurgeResponse(struct soap *soap, const char *tag, int id, const struct ns1__jobPurgeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__jobPurgeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__jobPurgeResponse * SOAP_FMAC4 soap_in_ns1__jobPurgeResponse(struct soap *soap, const char *tag, struct ns1__jobPurgeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__jobPurgeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__jobPurgeResponse, sizeof(struct ns1__jobPurgeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__jobPurgeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__jobPurgeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__jobPurgeResponse, 0, sizeof(struct ns1__jobPurgeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__jobPurgeResponse(struct soap *soap, const struct ns1__jobPurgeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__jobPurgeResponse);
	if (soap_out_ns1__jobPurgeResponse(soap, tag?tag:"ns1:jobPurgeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__jobPurgeResponse * SOAP_FMAC4 soap_get_ns1__jobPurgeResponse(struct soap *soap, struct ns1__jobPurgeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__jobPurgeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__jobPurgeResponse * SOAP_FMAC2 soap_instantiate_ns1__jobPurgeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__jobPurgeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__jobPurgeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobPurgeResponse);
		if (size)
			*size = sizeof(struct ns1__jobPurgeResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobPurgeResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__jobPurgeResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__jobPurgeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__jobPurgeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__jobPurgeResponse %p -> %p\n", q, p));
	*(struct ns1__jobPurgeResponse*)p = *(struct ns1__jobPurgeResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getFreeQuota(struct soap *soap, struct ns1__getFreeQuota *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getFreeQuota(struct soap *soap, const struct ns1__getFreeQuota *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getFreeQuota(struct soap *soap, const char *tag, int id, const struct ns1__getFreeQuota *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getFreeQuota), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getFreeQuota * SOAP_FMAC4 soap_in_ns1__getFreeQuota(struct soap *soap, const char *tag, struct ns1__getFreeQuota *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getFreeQuota *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getFreeQuota, sizeof(struct ns1__getFreeQuota), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getFreeQuota(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getFreeQuota *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getFreeQuota, 0, sizeof(struct ns1__getFreeQuota), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getFreeQuota(struct soap *soap, const struct ns1__getFreeQuota *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getFreeQuota);
	if (soap_out_ns1__getFreeQuota(soap, tag?tag:"ns1:getFreeQuota", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getFreeQuota * SOAP_FMAC4 soap_get_ns1__getFreeQuota(struct soap *soap, struct ns1__getFreeQuota *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getFreeQuota(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getFreeQuota * SOAP_FMAC2 soap_instantiate_ns1__getFreeQuota(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getFreeQuota(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getFreeQuota, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getFreeQuota);
		if (size)
			*size = sizeof(struct ns1__getFreeQuota);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getFreeQuota[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getFreeQuota);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getFreeQuota*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getFreeQuota(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getFreeQuota %p -> %p\n", q, p));
	*(struct ns1__getFreeQuota*)p = *(struct ns1__getFreeQuota*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getFreeQuotaResponse(struct soap *soap, struct ns1__getFreeQuotaResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->softLimit);
	soap_default_LONG64(soap, &a->hardLimit);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getFreeQuotaResponse(struct soap *soap, const struct ns1__getFreeQuotaResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getFreeQuotaResponse(struct soap *soap, const char *tag, int id, const struct ns1__getFreeQuotaResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getFreeQuotaResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "softLimit", -1, &a->softLimit, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "hardLimit", -1, &a->hardLimit, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getFreeQuotaResponse * SOAP_FMAC4 soap_in_ns1__getFreeQuotaResponse(struct soap *soap, const char *tag, struct ns1__getFreeQuotaResponse *a, const char *type)
{
	size_t soap_flag_softLimit = 1;
	size_t soap_flag_hardLimit = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getFreeQuotaResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getFreeQuotaResponse, sizeof(struct ns1__getFreeQuotaResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getFreeQuotaResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_softLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "softLimit", &a->softLimit, "xsd:long"))
				{	soap_flag_softLimit--;
					continue;
				}
			if (soap_flag_hardLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "hardLimit", &a->hardLimit, "xsd:long"))
				{	soap_flag_hardLimit--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getFreeQuotaResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getFreeQuotaResponse, 0, sizeof(struct ns1__getFreeQuotaResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_softLimit > 0 || soap_flag_hardLimit > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getFreeQuotaResponse(struct soap *soap, const struct ns1__getFreeQuotaResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getFreeQuotaResponse);
	if (soap_out_ns1__getFreeQuotaResponse(soap, tag?tag:"ns1:getFreeQuotaResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getFreeQuotaResponse * SOAP_FMAC4 soap_get_ns1__getFreeQuotaResponse(struct soap *soap, struct ns1__getFreeQuotaResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getFreeQuotaResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getFreeQuotaResponse * SOAP_FMAC2 soap_instantiate_ns1__getFreeQuotaResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getFreeQuotaResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getFreeQuotaResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getFreeQuotaResponse);
		if (size)
			*size = sizeof(struct ns1__getFreeQuotaResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getFreeQuotaResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getFreeQuotaResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getFreeQuotaResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getFreeQuotaResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getFreeQuotaResponse %p -> %p\n", q, p));
	*(struct ns1__getFreeQuotaResponse*)p = *(struct ns1__getFreeQuotaResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTotalQuota(struct soap *soap, struct ns1__getTotalQuota *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTotalQuota(struct soap *soap, const struct ns1__getTotalQuota *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTotalQuota(struct soap *soap, const char *tag, int id, const struct ns1__getTotalQuota *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTotalQuota), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTotalQuota * SOAP_FMAC4 soap_in_ns1__getTotalQuota(struct soap *soap, const char *tag, struct ns1__getTotalQuota *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getTotalQuota *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTotalQuota, sizeof(struct ns1__getTotalQuota), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTotalQuota(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTotalQuota *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTotalQuota, 0, sizeof(struct ns1__getTotalQuota), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTotalQuota(struct soap *soap, const struct ns1__getTotalQuota *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getTotalQuota);
	if (soap_out_ns1__getTotalQuota(soap, tag?tag:"ns1:getTotalQuota", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTotalQuota * SOAP_FMAC4 soap_get_ns1__getTotalQuota(struct soap *soap, struct ns1__getTotalQuota *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTotalQuota(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getTotalQuota * SOAP_FMAC2 soap_instantiate_ns1__getTotalQuota(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTotalQuota(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTotalQuota, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getTotalQuota);
		if (size)
			*size = sizeof(struct ns1__getTotalQuota);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getTotalQuota[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getTotalQuota);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getTotalQuota*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTotalQuota(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getTotalQuota %p -> %p\n", q, p));
	*(struct ns1__getTotalQuota*)p = *(struct ns1__getTotalQuota*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTotalQuotaResponse(struct soap *soap, struct ns1__getTotalQuotaResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->softLimit);
	soap_default_LONG64(soap, &a->hardLimit);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTotalQuotaResponse(struct soap *soap, const struct ns1__getTotalQuotaResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTotalQuotaResponse(struct soap *soap, const char *tag, int id, const struct ns1__getTotalQuotaResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTotalQuotaResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "softLimit", -1, &a->softLimit, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "hardLimit", -1, &a->hardLimit, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTotalQuotaResponse * SOAP_FMAC4 soap_in_ns1__getTotalQuotaResponse(struct soap *soap, const char *tag, struct ns1__getTotalQuotaResponse *a, const char *type)
{
	size_t soap_flag_softLimit = 1;
	size_t soap_flag_hardLimit = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getTotalQuotaResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTotalQuotaResponse, sizeof(struct ns1__getTotalQuotaResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTotalQuotaResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_softLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "softLimit", &a->softLimit, "xsd:long"))
				{	soap_flag_softLimit--;
					continue;
				}
			if (soap_flag_hardLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "hardLimit", &a->hardLimit, "xsd:long"))
				{	soap_flag_hardLimit--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTotalQuotaResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTotalQuotaResponse, 0, sizeof(struct ns1__getTotalQuotaResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_softLimit > 0 || soap_flag_hardLimit > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTotalQuotaResponse(struct soap *soap, const struct ns1__getTotalQuotaResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getTotalQuotaResponse);
	if (soap_out_ns1__getTotalQuotaResponse(soap, tag?tag:"ns1:getTotalQuotaResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTotalQuotaResponse * SOAP_FMAC4 soap_get_ns1__getTotalQuotaResponse(struct soap *soap, struct ns1__getTotalQuotaResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTotalQuotaResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getTotalQuotaResponse * SOAP_FMAC2 soap_instantiate_ns1__getTotalQuotaResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTotalQuotaResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTotalQuotaResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getTotalQuotaResponse);
		if (size)
			*size = sizeof(struct ns1__getTotalQuotaResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getTotalQuotaResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getTotalQuotaResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getTotalQuotaResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTotalQuotaResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getTotalQuotaResponse %p -> %p\n", q, p));
	*(struct ns1__getTotalQuotaResponse*)p = *(struct ns1__getTotalQuotaResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getSandboxBulkDestURI(struct soap *soap, struct ns1__getSandboxBulkDestURI *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_jobId);
	soap_default_std__string(soap, &a->_protocol);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getSandboxBulkDestURI(struct soap *soap, const struct ns1__getSandboxBulkDestURI *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_jobId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_jobId);
	soap_embedded(soap, &a->_protocol, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_protocol);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getSandboxBulkDestURI(struct soap *soap, const char *tag, int id, const struct ns1__getSandboxBulkDestURI *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getSandboxBulkDestURI), type))
		return soap->error;
	if (soap_out_std__string(soap, "jobId", -1, &a->_jobId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "protocol", -1, &a->_protocol, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getSandboxBulkDestURI * SOAP_FMAC4 soap_in_ns1__getSandboxBulkDestURI(struct soap *soap, const char *tag, struct ns1__getSandboxBulkDestURI *a, const char *type)
{
	size_t soap_flag__jobId = 1;
	size_t soap_flag__protocol = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getSandboxBulkDestURI *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getSandboxBulkDestURI, sizeof(struct ns1__getSandboxBulkDestURI), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getSandboxBulkDestURI(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_jobId, "xsd:string"))
				{	soap_flag__jobId--;
					continue;
				}
			if (soap_flag__protocol && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_protocol, "xsd:string"))
				{	soap_flag__protocol--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getSandboxBulkDestURI *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getSandboxBulkDestURI, 0, sizeof(struct ns1__getSandboxBulkDestURI), 0, soap_copy_ns1__getSandboxBulkDestURI);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__jobId > 0 || soap_flag__protocol > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getSandboxBulkDestURI(struct soap *soap, const struct ns1__getSandboxBulkDestURI *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getSandboxBulkDestURI);
	if (soap_out_ns1__getSandboxBulkDestURI(soap, tag?tag:"ns1:getSandboxBulkDestURI", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getSandboxBulkDestURI * SOAP_FMAC4 soap_get_ns1__getSandboxBulkDestURI(struct soap *soap, struct ns1__getSandboxBulkDestURI *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getSandboxBulkDestURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getSandboxBulkDestURI * SOAP_FMAC2 soap_instantiate_ns1__getSandboxBulkDestURI(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getSandboxBulkDestURI(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getSandboxBulkDestURI, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getSandboxBulkDestURI);
		if (size)
			*size = sizeof(struct ns1__getSandboxBulkDestURI);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getSandboxBulkDestURI[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getSandboxBulkDestURI);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getSandboxBulkDestURI*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getSandboxBulkDestURI(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getSandboxBulkDestURI %p -> %p\n", q, p));
	*(struct ns1__getSandboxBulkDestURI*)p = *(struct ns1__getSandboxBulkDestURI*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getSandboxBulkDestURIResponse(struct soap *soap, struct ns1__getSandboxBulkDestURIResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_DestURIsStructType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getSandboxBulkDestURIResponse(struct soap *soap, const struct ns1__getSandboxBulkDestURIResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__DestURIsStructType(soap, &a->_DestURIsStructType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getSandboxBulkDestURIResponse(struct soap *soap, const char *tag, int id, const struct ns1__getSandboxBulkDestURIResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getSandboxBulkDestURIResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__DestURIsStructType(soap, "DestURIsStructType", -1, &a->_DestURIsStructType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getSandboxBulkDestURIResponse * SOAP_FMAC4 soap_in_ns1__getSandboxBulkDestURIResponse(struct soap *soap, const char *tag, struct ns1__getSandboxBulkDestURIResponse *a, const char *type)
{
	size_t soap_flag__DestURIsStructType = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getSandboxBulkDestURIResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getSandboxBulkDestURIResponse, sizeof(struct ns1__getSandboxBulkDestURIResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getSandboxBulkDestURIResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__DestURIsStructType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__DestURIsStructType(soap, NULL, &a->_DestURIsStructType, "ns1:DestURIsStructType"))
				{	soap_flag__DestURIsStructType--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getSandboxBulkDestURIResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getSandboxBulkDestURIResponse, 0, sizeof(struct ns1__getSandboxBulkDestURIResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getSandboxBulkDestURIResponse(struct soap *soap, const struct ns1__getSandboxBulkDestURIResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getSandboxBulkDestURIResponse);
	if (soap_out_ns1__getSandboxBulkDestURIResponse(soap, tag?tag:"ns1:getSandboxBulkDestURIResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getSandboxBulkDestURIResponse * SOAP_FMAC4 soap_get_ns1__getSandboxBulkDestURIResponse(struct soap *soap, struct ns1__getSandboxBulkDestURIResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getSandboxBulkDestURIResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getSandboxBulkDestURIResponse * SOAP_FMAC2 soap_instantiate_ns1__getSandboxBulkDestURIResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getSandboxBulkDestURIResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getSandboxBulkDestURIResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getSandboxBulkDestURIResponse);
		if (size)
			*size = sizeof(struct ns1__getSandboxBulkDestURIResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getSandboxBulkDestURIResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getSandboxBulkDestURIResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getSandboxBulkDestURIResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getSandboxBulkDestURIResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getSandboxBulkDestURIResponse %p -> %p\n", q, p));
	*(struct ns1__getSandboxBulkDestURIResponse*)p = *(struct ns1__getSandboxBulkDestURIResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getSandboxDestURI(struct soap *soap, struct ns1__getSandboxDestURI *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_jobId);
	soap_default_std__string(soap, &a->_protocol);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getSandboxDestURI(struct soap *soap, const struct ns1__getSandboxDestURI *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_jobId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_jobId);
	soap_embedded(soap, &a->_protocol, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_protocol);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getSandboxDestURI(struct soap *soap, const char *tag, int id, const struct ns1__getSandboxDestURI *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getSandboxDestURI), type))
		return soap->error;
	if (soap_out_std__string(soap, "jobId", -1, &a->_jobId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "protocol", -1, &a->_protocol, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getSandboxDestURI * SOAP_FMAC4 soap_in_ns1__getSandboxDestURI(struct soap *soap, const char *tag, struct ns1__getSandboxDestURI *a, const char *type)
{
	size_t soap_flag__jobId = 1;
	size_t soap_flag__protocol = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getSandboxDestURI *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getSandboxDestURI, sizeof(struct ns1__getSandboxDestURI), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getSandboxDestURI(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_jobId, "xsd:string"))
				{	soap_flag__jobId--;
					continue;
				}
			if (soap_flag__protocol && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_protocol, "xsd:string"))
				{	soap_flag__protocol--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getSandboxDestURI *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getSandboxDestURI, 0, sizeof(struct ns1__getSandboxDestURI), 0, soap_copy_ns1__getSandboxDestURI);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__jobId > 0 || soap_flag__protocol > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getSandboxDestURI(struct soap *soap, const struct ns1__getSandboxDestURI *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getSandboxDestURI);
	if (soap_out_ns1__getSandboxDestURI(soap, tag?tag:"ns1:getSandboxDestURI", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getSandboxDestURI * SOAP_FMAC4 soap_get_ns1__getSandboxDestURI(struct soap *soap, struct ns1__getSandboxDestURI *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getSandboxDestURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getSandboxDestURI * SOAP_FMAC2 soap_instantiate_ns1__getSandboxDestURI(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getSandboxDestURI(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getSandboxDestURI, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getSandboxDestURI);
		if (size)
			*size = sizeof(struct ns1__getSandboxDestURI);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getSandboxDestURI[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getSandboxDestURI);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getSandboxDestURI*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getSandboxDestURI(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getSandboxDestURI %p -> %p\n", q, p));
	*(struct ns1__getSandboxDestURI*)p = *(struct ns1__getSandboxDestURI*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getSandboxDestURIResponse(struct soap *soap, struct ns1__getSandboxDestURIResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_path = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getSandboxDestURIResponse(struct soap *soap, const struct ns1__getSandboxDestURIResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__StringList(soap, &a->_path);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getSandboxDestURIResponse(struct soap *soap, const char *tag, int id, const struct ns1__getSandboxDestURIResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getSandboxDestURIResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__StringList(soap, "path", -1, &a->_path, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getSandboxDestURIResponse * SOAP_FMAC4 soap_in_ns1__getSandboxDestURIResponse(struct soap *soap, const char *tag, struct ns1__getSandboxDestURIResponse *a, const char *type)
{
	size_t soap_flag__path = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getSandboxDestURIResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getSandboxDestURIResponse, sizeof(struct ns1__getSandboxDestURIResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getSandboxDestURIResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__path && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__StringList(soap, NULL, &a->_path, "ns1:StringList"))
				{	soap_flag__path--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getSandboxDestURIResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getSandboxDestURIResponse, 0, sizeof(struct ns1__getSandboxDestURIResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getSandboxDestURIResponse(struct soap *soap, const struct ns1__getSandboxDestURIResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getSandboxDestURIResponse);
	if (soap_out_ns1__getSandboxDestURIResponse(soap, tag?tag:"ns1:getSandboxDestURIResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getSandboxDestURIResponse * SOAP_FMAC4 soap_get_ns1__getSandboxDestURIResponse(struct soap *soap, struct ns1__getSandboxDestURIResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getSandboxDestURIResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getSandboxDestURIResponse * SOAP_FMAC2 soap_instantiate_ns1__getSandboxDestURIResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getSandboxDestURIResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getSandboxDestURIResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getSandboxDestURIResponse);
		if (size)
			*size = sizeof(struct ns1__getSandboxDestURIResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getSandboxDestURIResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getSandboxDestURIResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getSandboxDestURIResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getSandboxDestURIResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getSandboxDestURIResponse %p -> %p\n", q, p));
	*(struct ns1__getSandboxDestURIResponse*)p = *(struct ns1__getSandboxDestURIResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getMaxInputSandboxSize(struct soap *soap, struct ns1__getMaxInputSandboxSize *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getMaxInputSandboxSize(struct soap *soap, const struct ns1__getMaxInputSandboxSize *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getMaxInputSandboxSize(struct soap *soap, const char *tag, int id, const struct ns1__getMaxInputSandboxSize *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getMaxInputSandboxSize), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getMaxInputSandboxSize * SOAP_FMAC4 soap_in_ns1__getMaxInputSandboxSize(struct soap *soap, const char *tag, struct ns1__getMaxInputSandboxSize *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getMaxInputSandboxSize *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getMaxInputSandboxSize, sizeof(struct ns1__getMaxInputSandboxSize), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getMaxInputSandboxSize(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getMaxInputSandboxSize *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getMaxInputSandboxSize, 0, sizeof(struct ns1__getMaxInputSandboxSize), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getMaxInputSandboxSize(struct soap *soap, const struct ns1__getMaxInputSandboxSize *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getMaxInputSandboxSize);
	if (soap_out_ns1__getMaxInputSandboxSize(soap, tag?tag:"ns1:getMaxInputSandboxSize", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getMaxInputSandboxSize * SOAP_FMAC4 soap_get_ns1__getMaxInputSandboxSize(struct soap *soap, struct ns1__getMaxInputSandboxSize *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getMaxInputSandboxSize(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getMaxInputSandboxSize * SOAP_FMAC2 soap_instantiate_ns1__getMaxInputSandboxSize(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getMaxInputSandboxSize(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getMaxInputSandboxSize, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getMaxInputSandboxSize);
		if (size)
			*size = sizeof(struct ns1__getMaxInputSandboxSize);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getMaxInputSandboxSize[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getMaxInputSandboxSize);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getMaxInputSandboxSize*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getMaxInputSandboxSize(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getMaxInputSandboxSize %p -> %p\n", q, p));
	*(struct ns1__getMaxInputSandboxSize*)p = *(struct ns1__getMaxInputSandboxSize*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getMaxInputSandboxSizeResponse(struct soap *soap, struct ns1__getMaxInputSandboxSizeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->size);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getMaxInputSandboxSizeResponse(struct soap *soap, const struct ns1__getMaxInputSandboxSizeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getMaxInputSandboxSizeResponse(struct soap *soap, const char *tag, int id, const struct ns1__getMaxInputSandboxSizeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getMaxInputSandboxSizeResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "size", -1, &a->size, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getMaxInputSandboxSizeResponse * SOAP_FMAC4 soap_in_ns1__getMaxInputSandboxSizeResponse(struct soap *soap, const char *tag, struct ns1__getMaxInputSandboxSizeResponse *a, const char *type)
{
	size_t soap_flag_size = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getMaxInputSandboxSizeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getMaxInputSandboxSizeResponse, sizeof(struct ns1__getMaxInputSandboxSizeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getMaxInputSandboxSizeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_size && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "size", &a->size, "xsd:long"))
				{	soap_flag_size--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getMaxInputSandboxSizeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getMaxInputSandboxSizeResponse, 0, sizeof(struct ns1__getMaxInputSandboxSizeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_size > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getMaxInputSandboxSizeResponse(struct soap *soap, const struct ns1__getMaxInputSandboxSizeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getMaxInputSandboxSizeResponse);
	if (soap_out_ns1__getMaxInputSandboxSizeResponse(soap, tag?tag:"ns1:getMaxInputSandboxSizeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getMaxInputSandboxSizeResponse * SOAP_FMAC4 soap_get_ns1__getMaxInputSandboxSizeResponse(struct soap *soap, struct ns1__getMaxInputSandboxSizeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getMaxInputSandboxSizeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getMaxInputSandboxSizeResponse * SOAP_FMAC2 soap_instantiate_ns1__getMaxInputSandboxSizeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getMaxInputSandboxSizeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getMaxInputSandboxSizeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getMaxInputSandboxSizeResponse);
		if (size)
			*size = sizeof(struct ns1__getMaxInputSandboxSizeResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getMaxInputSandboxSizeResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getMaxInputSandboxSizeResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getMaxInputSandboxSizeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getMaxInputSandboxSizeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getMaxInputSandboxSizeResponse %p -> %p\n", q, p));
	*(struct ns1__getMaxInputSandboxSizeResponse*)p = *(struct ns1__getMaxInputSandboxSizeResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__jobCancel(struct soap *soap, struct ns1__jobCancel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_jobId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__jobCancel(struct soap *soap, const struct ns1__jobCancel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_jobId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_jobId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__jobCancel(struct soap *soap, const char *tag, int id, const struct ns1__jobCancel *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__jobCancel), type))
		return soap->error;
	if (soap_out_std__string(soap, "jobId", -1, &a->_jobId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__jobCancel * SOAP_FMAC4 soap_in_ns1__jobCancel(struct soap *soap, const char *tag, struct ns1__jobCancel *a, const char *type)
{
	size_t soap_flag__jobId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__jobCancel *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__jobCancel, sizeof(struct ns1__jobCancel), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__jobCancel(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_jobId, "xsd:string"))
				{	soap_flag__jobId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__jobCancel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__jobCancel, 0, sizeof(struct ns1__jobCancel), 0, soap_copy_ns1__jobCancel);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__jobId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__jobCancel(struct soap *soap, const struct ns1__jobCancel *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__jobCancel);
	if (soap_out_ns1__jobCancel(soap, tag?tag:"ns1:jobCancel", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__jobCancel * SOAP_FMAC4 soap_get_ns1__jobCancel(struct soap *soap, struct ns1__jobCancel *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__jobCancel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__jobCancel * SOAP_FMAC2 soap_instantiate_ns1__jobCancel(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__jobCancel(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__jobCancel, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobCancel);
		if (size)
			*size = sizeof(struct ns1__jobCancel);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobCancel[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__jobCancel);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__jobCancel*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__jobCancel(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__jobCancel %p -> %p\n", q, p));
	*(struct ns1__jobCancel*)p = *(struct ns1__jobCancel*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__jobCancelResponse(struct soap *soap, struct ns1__jobCancelResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__jobCancelResponse(struct soap *soap, const struct ns1__jobCancelResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__jobCancelResponse(struct soap *soap, const char *tag, int id, const struct ns1__jobCancelResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__jobCancelResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__jobCancelResponse * SOAP_FMAC4 soap_in_ns1__jobCancelResponse(struct soap *soap, const char *tag, struct ns1__jobCancelResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__jobCancelResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__jobCancelResponse, sizeof(struct ns1__jobCancelResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__jobCancelResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__jobCancelResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__jobCancelResponse, 0, sizeof(struct ns1__jobCancelResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__jobCancelResponse(struct soap *soap, const struct ns1__jobCancelResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__jobCancelResponse);
	if (soap_out_ns1__jobCancelResponse(soap, tag?tag:"ns1:jobCancelResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__jobCancelResponse * SOAP_FMAC4 soap_get_ns1__jobCancelResponse(struct soap *soap, struct ns1__jobCancelResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__jobCancelResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__jobCancelResponse * SOAP_FMAC2 soap_instantiate_ns1__jobCancelResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__jobCancelResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__jobCancelResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobCancelResponse);
		if (size)
			*size = sizeof(struct ns1__jobCancelResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobCancelResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__jobCancelResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__jobCancelResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__jobCancelResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__jobCancelResponse %p -> %p\n", q, p));
	*(struct ns1__jobCancelResponse*)p = *(struct ns1__jobCancelResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__jobSubmitJSDL(struct soap *soap, struct ns1__jobSubmitJSDL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_delegationId);
	a->_jsdl = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__jobSubmitJSDL(struct soap *soap, const struct ns1__jobSubmitJSDL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_delegationId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_delegationId);
	soap_serialize_PointerTojsdl__JobDefinition_USCOREType(soap, &a->_jsdl);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__jobSubmitJSDL(struct soap *soap, const char *tag, int id, const struct ns1__jobSubmitJSDL *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__jobSubmitJSDL), type))
		return soap->error;
	if (soap_out_std__string(soap, "delegationId", -1, &a->_delegationId, ""))
		return soap->error;
	if (soap_out_PointerTojsdl__JobDefinition_USCOREType(soap, "jsdl", -1, &a->_jsdl, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__jobSubmitJSDL * SOAP_FMAC4 soap_in_ns1__jobSubmitJSDL(struct soap *soap, const char *tag, struct ns1__jobSubmitJSDL *a, const char *type)
{
	size_t soap_flag__delegationId = 1;
	size_t soap_flag__jsdl = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__jobSubmitJSDL *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__jobSubmitJSDL, sizeof(struct ns1__jobSubmitJSDL), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__jobSubmitJSDL(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__delegationId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_delegationId, "xsd:string"))
				{	soap_flag__delegationId--;
					continue;
				}
			if (soap_flag__jsdl && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__JobDefinition_USCOREType(soap, NULL, &a->_jsdl, "jsdl:JobDefinition_Type"))
				{	soap_flag__jsdl--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__jobSubmitJSDL *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__jobSubmitJSDL, 0, sizeof(struct ns1__jobSubmitJSDL), 0, soap_copy_ns1__jobSubmitJSDL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__delegationId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__jobSubmitJSDL(struct soap *soap, const struct ns1__jobSubmitJSDL *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__jobSubmitJSDL);
	if (soap_out_ns1__jobSubmitJSDL(soap, tag?tag:"ns1:jobSubmitJSDL", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__jobSubmitJSDL * SOAP_FMAC4 soap_get_ns1__jobSubmitJSDL(struct soap *soap, struct ns1__jobSubmitJSDL *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__jobSubmitJSDL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__jobSubmitJSDL * SOAP_FMAC2 soap_instantiate_ns1__jobSubmitJSDL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__jobSubmitJSDL(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__jobSubmitJSDL, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobSubmitJSDL);
		if (size)
			*size = sizeof(struct ns1__jobSubmitJSDL);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobSubmitJSDL[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__jobSubmitJSDL);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__jobSubmitJSDL*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__jobSubmitJSDL(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__jobSubmitJSDL %p -> %p\n", q, p));
	*(struct ns1__jobSubmitJSDL*)p = *(struct ns1__jobSubmitJSDL*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__jobSubmitJSDLResponse(struct soap *soap, struct ns1__jobSubmitJSDLResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobIdStruct = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__jobSubmitJSDLResponse(struct soap *soap, const struct ns1__jobSubmitJSDLResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__JobIdStructType(soap, &a->_jobIdStruct);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__jobSubmitJSDLResponse(struct soap *soap, const char *tag, int id, const struct ns1__jobSubmitJSDLResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__jobSubmitJSDLResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__JobIdStructType(soap, "jobIdStruct", -1, &a->_jobIdStruct, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__jobSubmitJSDLResponse * SOAP_FMAC4 soap_in_ns1__jobSubmitJSDLResponse(struct soap *soap, const char *tag, struct ns1__jobSubmitJSDLResponse *a, const char *type)
{
	size_t soap_flag__jobIdStruct = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__jobSubmitJSDLResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__jobSubmitJSDLResponse, sizeof(struct ns1__jobSubmitJSDLResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__jobSubmitJSDLResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobIdStruct && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__JobIdStructType(soap, NULL, &a->_jobIdStruct, "ns1:JobIdStructType"))
				{	soap_flag__jobIdStruct--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__jobSubmitJSDLResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__jobSubmitJSDLResponse, 0, sizeof(struct ns1__jobSubmitJSDLResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__jobSubmitJSDLResponse(struct soap *soap, const struct ns1__jobSubmitJSDLResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__jobSubmitJSDLResponse);
	if (soap_out_ns1__jobSubmitJSDLResponse(soap, tag?tag:"ns1:jobSubmitJSDLResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__jobSubmitJSDLResponse * SOAP_FMAC4 soap_get_ns1__jobSubmitJSDLResponse(struct soap *soap, struct ns1__jobSubmitJSDLResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__jobSubmitJSDLResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__jobSubmitJSDLResponse * SOAP_FMAC2 soap_instantiate_ns1__jobSubmitJSDLResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__jobSubmitJSDLResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__jobSubmitJSDLResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobSubmitJSDLResponse);
		if (size)
			*size = sizeof(struct ns1__jobSubmitJSDLResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobSubmitJSDLResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__jobSubmitJSDLResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__jobSubmitJSDLResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__jobSubmitJSDLResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__jobSubmitJSDLResponse %p -> %p\n", q, p));
	*(struct ns1__jobSubmitJSDLResponse*)p = *(struct ns1__jobSubmitJSDLResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__jobSubmit(struct soap *soap, struct ns1__jobSubmit *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_jdl);
	soap_default_std__string(soap, &a->_delegationId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__jobSubmit(struct soap *soap, const struct ns1__jobSubmit *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_jdl, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_jdl);
	soap_embedded(soap, &a->_delegationId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_delegationId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__jobSubmit(struct soap *soap, const char *tag, int id, const struct ns1__jobSubmit *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__jobSubmit), type))
		return soap->error;
	if (soap_out_std__string(soap, "jdl", -1, &a->_jdl, ""))
		return soap->error;
	if (soap_out_std__string(soap, "delegationId", -1, &a->_delegationId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__jobSubmit * SOAP_FMAC4 soap_in_ns1__jobSubmit(struct soap *soap, const char *tag, struct ns1__jobSubmit *a, const char *type)
{
	size_t soap_flag__jdl = 1;
	size_t soap_flag__delegationId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__jobSubmit *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__jobSubmit, sizeof(struct ns1__jobSubmit), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__jobSubmit(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jdl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_jdl, "xsd:string"))
				{	soap_flag__jdl--;
					continue;
				}
			if (soap_flag__delegationId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_delegationId, "xsd:string"))
				{	soap_flag__delegationId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__jobSubmit *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__jobSubmit, 0, sizeof(struct ns1__jobSubmit), 0, soap_copy_ns1__jobSubmit);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__jdl > 0 || soap_flag__delegationId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__jobSubmit(struct soap *soap, const struct ns1__jobSubmit *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__jobSubmit);
	if (soap_out_ns1__jobSubmit(soap, tag?tag:"ns1:jobSubmit", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__jobSubmit * SOAP_FMAC4 soap_get_ns1__jobSubmit(struct soap *soap, struct ns1__jobSubmit *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__jobSubmit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__jobSubmit * SOAP_FMAC2 soap_instantiate_ns1__jobSubmit(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__jobSubmit(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__jobSubmit, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobSubmit);
		if (size)
			*size = sizeof(struct ns1__jobSubmit);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobSubmit[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__jobSubmit);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__jobSubmit*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__jobSubmit(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__jobSubmit %p -> %p\n", q, p));
	*(struct ns1__jobSubmit*)p = *(struct ns1__jobSubmit*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__jobSubmitResponse(struct soap *soap, struct ns1__jobSubmitResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobIdStruct = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__jobSubmitResponse(struct soap *soap, const struct ns1__jobSubmitResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__JobIdStructType(soap, &a->_jobIdStruct);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__jobSubmitResponse(struct soap *soap, const char *tag, int id, const struct ns1__jobSubmitResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__jobSubmitResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__JobIdStructType(soap, "jobIdStruct", -1, &a->_jobIdStruct, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__jobSubmitResponse * SOAP_FMAC4 soap_in_ns1__jobSubmitResponse(struct soap *soap, const char *tag, struct ns1__jobSubmitResponse *a, const char *type)
{
	size_t soap_flag__jobIdStruct = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__jobSubmitResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__jobSubmitResponse, sizeof(struct ns1__jobSubmitResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__jobSubmitResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobIdStruct && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__JobIdStructType(soap, NULL, &a->_jobIdStruct, "ns1:JobIdStructType"))
				{	soap_flag__jobIdStruct--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__jobSubmitResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__jobSubmitResponse, 0, sizeof(struct ns1__jobSubmitResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__jobSubmitResponse(struct soap *soap, const struct ns1__jobSubmitResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__jobSubmitResponse);
	if (soap_out_ns1__jobSubmitResponse(soap, tag?tag:"ns1:jobSubmitResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__jobSubmitResponse * SOAP_FMAC4 soap_get_ns1__jobSubmitResponse(struct soap *soap, struct ns1__jobSubmitResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__jobSubmitResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__jobSubmitResponse * SOAP_FMAC2 soap_instantiate_ns1__jobSubmitResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__jobSubmitResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__jobSubmitResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobSubmitResponse);
		if (size)
			*size = sizeof(struct ns1__jobSubmitResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobSubmitResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__jobSubmitResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__jobSubmitResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__jobSubmitResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__jobSubmitResponse %p -> %p\n", q, p));
	*(struct ns1__jobSubmitResponse*)p = *(struct ns1__jobSubmitResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__jobStart(struct soap *soap, struct ns1__jobStart *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_jobId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__jobStart(struct soap *soap, const struct ns1__jobStart *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_jobId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_jobId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__jobStart(struct soap *soap, const char *tag, int id, const struct ns1__jobStart *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__jobStart), type))
		return soap->error;
	if (soap_out_std__string(soap, "jobId", -1, &a->_jobId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__jobStart * SOAP_FMAC4 soap_in_ns1__jobStart(struct soap *soap, const char *tag, struct ns1__jobStart *a, const char *type)
{
	size_t soap_flag__jobId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__jobStart *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__jobStart, sizeof(struct ns1__jobStart), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__jobStart(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_jobId, "xsd:string"))
				{	soap_flag__jobId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__jobStart *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__jobStart, 0, sizeof(struct ns1__jobStart), 0, soap_copy_ns1__jobStart);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__jobId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__jobStart(struct soap *soap, const struct ns1__jobStart *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__jobStart);
	if (soap_out_ns1__jobStart(soap, tag?tag:"ns1:jobStart", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__jobStart * SOAP_FMAC4 soap_get_ns1__jobStart(struct soap *soap, struct ns1__jobStart *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__jobStart(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__jobStart * SOAP_FMAC2 soap_instantiate_ns1__jobStart(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__jobStart(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__jobStart, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobStart);
		if (size)
			*size = sizeof(struct ns1__jobStart);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobStart[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__jobStart);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__jobStart*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__jobStart(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__jobStart %p -> %p\n", q, p));
	*(struct ns1__jobStart*)p = *(struct ns1__jobStart*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__jobStartResponse(struct soap *soap, struct ns1__jobStartResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__jobStartResponse(struct soap *soap, const struct ns1__jobStartResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__jobStartResponse(struct soap *soap, const char *tag, int id, const struct ns1__jobStartResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__jobStartResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__jobStartResponse * SOAP_FMAC4 soap_in_ns1__jobStartResponse(struct soap *soap, const char *tag, struct ns1__jobStartResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__jobStartResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__jobStartResponse, sizeof(struct ns1__jobStartResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__jobStartResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__jobStartResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__jobStartResponse, 0, sizeof(struct ns1__jobStartResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__jobStartResponse(struct soap *soap, const struct ns1__jobStartResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__jobStartResponse);
	if (soap_out_ns1__jobStartResponse(soap, tag?tag:"ns1:jobStartResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__jobStartResponse * SOAP_FMAC4 soap_get_ns1__jobStartResponse(struct soap *soap, struct ns1__jobStartResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__jobStartResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__jobStartResponse * SOAP_FMAC2 soap_instantiate_ns1__jobStartResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__jobStartResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__jobStartResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobStartResponse);
		if (size)
			*size = sizeof(struct ns1__jobStartResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobStartResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__jobStartResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__jobStartResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__jobStartResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__jobStartResponse %p -> %p\n", q, p));
	*(struct ns1__jobStartResponse*)p = *(struct ns1__jobStartResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__jobRegisterJSDL(struct soap *soap, struct ns1__jobRegisterJSDL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jsdl = NULL;
	soap_default_std__string(soap, &a->_delegationId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__jobRegisterJSDL(struct soap *soap, const struct ns1__jobRegisterJSDL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__JobDefinition_USCOREType(soap, &a->_jsdl);
	soap_embedded(soap, &a->_delegationId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_delegationId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__jobRegisterJSDL(struct soap *soap, const char *tag, int id, const struct ns1__jobRegisterJSDL *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__jobRegisterJSDL), type))
		return soap->error;
	if (soap_out_PointerTojsdl__JobDefinition_USCOREType(soap, "jsdl", -1, &a->_jsdl, ""))
		return soap->error;
	if (soap_out_std__string(soap, "delegationId", -1, &a->_delegationId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__jobRegisterJSDL * SOAP_FMAC4 soap_in_ns1__jobRegisterJSDL(struct soap *soap, const char *tag, struct ns1__jobRegisterJSDL *a, const char *type)
{
	size_t soap_flag__jsdl = 1;
	size_t soap_flag__delegationId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__jobRegisterJSDL *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__jobRegisterJSDL, sizeof(struct ns1__jobRegisterJSDL), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__jobRegisterJSDL(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jsdl && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__JobDefinition_USCOREType(soap, NULL, &a->_jsdl, "jsdl:JobDefinition_Type"))
				{	soap_flag__jsdl--;
					continue;
				}
			if (soap_flag__delegationId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_delegationId, "xsd:string"))
				{	soap_flag__delegationId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__jobRegisterJSDL *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__jobRegisterJSDL, 0, sizeof(struct ns1__jobRegisterJSDL), 0, soap_copy_ns1__jobRegisterJSDL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__delegationId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__jobRegisterJSDL(struct soap *soap, const struct ns1__jobRegisterJSDL *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__jobRegisterJSDL);
	if (soap_out_ns1__jobRegisterJSDL(soap, tag?tag:"ns1:jobRegisterJSDL", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__jobRegisterJSDL * SOAP_FMAC4 soap_get_ns1__jobRegisterJSDL(struct soap *soap, struct ns1__jobRegisterJSDL *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__jobRegisterJSDL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__jobRegisterJSDL * SOAP_FMAC2 soap_instantiate_ns1__jobRegisterJSDL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__jobRegisterJSDL(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__jobRegisterJSDL, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobRegisterJSDL);
		if (size)
			*size = sizeof(struct ns1__jobRegisterJSDL);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobRegisterJSDL[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__jobRegisterJSDL);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__jobRegisterJSDL*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__jobRegisterJSDL(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__jobRegisterJSDL %p -> %p\n", q, p));
	*(struct ns1__jobRegisterJSDL*)p = *(struct ns1__jobRegisterJSDL*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__jobRegisterJSDLResponse(struct soap *soap, struct ns1__jobRegisterJSDLResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobIdStruct = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__jobRegisterJSDLResponse(struct soap *soap, const struct ns1__jobRegisterJSDLResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__JobIdStructType(soap, &a->_jobIdStruct);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__jobRegisterJSDLResponse(struct soap *soap, const char *tag, int id, const struct ns1__jobRegisterJSDLResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__jobRegisterJSDLResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__JobIdStructType(soap, "jobIdStruct", -1, &a->_jobIdStruct, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__jobRegisterJSDLResponse * SOAP_FMAC4 soap_in_ns1__jobRegisterJSDLResponse(struct soap *soap, const char *tag, struct ns1__jobRegisterJSDLResponse *a, const char *type)
{
	size_t soap_flag__jobIdStruct = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__jobRegisterJSDLResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__jobRegisterJSDLResponse, sizeof(struct ns1__jobRegisterJSDLResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__jobRegisterJSDLResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobIdStruct && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__JobIdStructType(soap, NULL, &a->_jobIdStruct, "ns1:JobIdStructType"))
				{	soap_flag__jobIdStruct--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__jobRegisterJSDLResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__jobRegisterJSDLResponse, 0, sizeof(struct ns1__jobRegisterJSDLResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__jobRegisterJSDLResponse(struct soap *soap, const struct ns1__jobRegisterJSDLResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__jobRegisterJSDLResponse);
	if (soap_out_ns1__jobRegisterJSDLResponse(soap, tag?tag:"ns1:jobRegisterJSDLResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__jobRegisterJSDLResponse * SOAP_FMAC4 soap_get_ns1__jobRegisterJSDLResponse(struct soap *soap, struct ns1__jobRegisterJSDLResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__jobRegisterJSDLResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__jobRegisterJSDLResponse * SOAP_FMAC2 soap_instantiate_ns1__jobRegisterJSDLResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__jobRegisterJSDLResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__jobRegisterJSDLResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobRegisterJSDLResponse);
		if (size)
			*size = sizeof(struct ns1__jobRegisterJSDLResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobRegisterJSDLResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__jobRegisterJSDLResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__jobRegisterJSDLResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__jobRegisterJSDLResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__jobRegisterJSDLResponse %p -> %p\n", q, p));
	*(struct ns1__jobRegisterJSDLResponse*)p = *(struct ns1__jobRegisterJSDLResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__jobRegister(struct soap *soap, struct ns1__jobRegister *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_jdl);
	soap_default_std__string(soap, &a->_delegationId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__jobRegister(struct soap *soap, const struct ns1__jobRegister *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_jdl, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_jdl);
	soap_embedded(soap, &a->_delegationId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_delegationId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__jobRegister(struct soap *soap, const char *tag, int id, const struct ns1__jobRegister *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__jobRegister), type))
		return soap->error;
	if (soap_out_std__string(soap, "jdl", -1, &a->_jdl, ""))
		return soap->error;
	if (soap_out_std__string(soap, "delegationId", -1, &a->_delegationId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__jobRegister * SOAP_FMAC4 soap_in_ns1__jobRegister(struct soap *soap, const char *tag, struct ns1__jobRegister *a, const char *type)
{
	size_t soap_flag__jdl = 1;
	size_t soap_flag__delegationId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__jobRegister *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__jobRegister, sizeof(struct ns1__jobRegister), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__jobRegister(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jdl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_jdl, "xsd:string"))
				{	soap_flag__jdl--;
					continue;
				}
			if (soap_flag__delegationId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_delegationId, "xsd:string"))
				{	soap_flag__delegationId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__jobRegister *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__jobRegister, 0, sizeof(struct ns1__jobRegister), 0, soap_copy_ns1__jobRegister);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__jdl > 0 || soap_flag__delegationId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__jobRegister(struct soap *soap, const struct ns1__jobRegister *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__jobRegister);
	if (soap_out_ns1__jobRegister(soap, tag?tag:"ns1:jobRegister", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__jobRegister * SOAP_FMAC4 soap_get_ns1__jobRegister(struct soap *soap, struct ns1__jobRegister *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__jobRegister(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__jobRegister * SOAP_FMAC2 soap_instantiate_ns1__jobRegister(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__jobRegister(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__jobRegister, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobRegister);
		if (size)
			*size = sizeof(struct ns1__jobRegister);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobRegister[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__jobRegister);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__jobRegister*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__jobRegister(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__jobRegister %p -> %p\n", q, p));
	*(struct ns1__jobRegister*)p = *(struct ns1__jobRegister*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__jobRegisterResponse(struct soap *soap, struct ns1__jobRegisterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_jobIdStruct = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__jobRegisterResponse(struct soap *soap, const struct ns1__jobRegisterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__JobIdStructType(soap, &a->_jobIdStruct);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__jobRegisterResponse(struct soap *soap, const char *tag, int id, const struct ns1__jobRegisterResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__jobRegisterResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__JobIdStructType(soap, "jobIdStruct", -1, &a->_jobIdStruct, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__jobRegisterResponse * SOAP_FMAC4 soap_in_ns1__jobRegisterResponse(struct soap *soap, const char *tag, struct ns1__jobRegisterResponse *a, const char *type)
{
	size_t soap_flag__jobIdStruct = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__jobRegisterResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__jobRegisterResponse, sizeof(struct ns1__jobRegisterResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__jobRegisterResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobIdStruct && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__JobIdStructType(soap, NULL, &a->_jobIdStruct, "ns1:JobIdStructType"))
				{	soap_flag__jobIdStruct--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__jobRegisterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__jobRegisterResponse, 0, sizeof(struct ns1__jobRegisterResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__jobRegisterResponse(struct soap *soap, const struct ns1__jobRegisterResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__jobRegisterResponse);
	if (soap_out_ns1__jobRegisterResponse(soap, tag?tag:"ns1:jobRegisterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__jobRegisterResponse * SOAP_FMAC4 soap_get_ns1__jobRegisterResponse(struct soap *soap, struct ns1__jobRegisterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__jobRegisterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__jobRegisterResponse * SOAP_FMAC2 soap_instantiate_ns1__jobRegisterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__jobRegisterResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__jobRegisterResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobRegisterResponse);
		if (size)
			*size = sizeof(struct ns1__jobRegisterResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__jobRegisterResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__jobRegisterResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__jobRegisterResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__jobRegisterResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__jobRegisterResponse %p -> %p\n", q, p));
	*(struct ns1__jobRegisterResponse*)p = *(struct ns1__jobRegisterResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getJDL(struct soap *soap, struct ns1__getJDL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_jobId);
	soap_default_ns1__JdlType(soap, &a->_type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getJDL(struct soap *soap, const struct ns1__getJDL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_jobId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_jobId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getJDL(struct soap *soap, const char *tag, int id, const struct ns1__getJDL *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getJDL), type))
		return soap->error;
	if (soap_out_std__string(soap, "jobId", -1, &a->_jobId, ""))
		return soap->error;
	if (soap_out_ns1__JdlType(soap, "type", -1, &a->_type, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getJDL * SOAP_FMAC4 soap_in_ns1__getJDL(struct soap *soap, const char *tag, struct ns1__getJDL *a, const char *type)
{
	size_t soap_flag__jobId = 1;
	size_t soap_flag__type = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getJDL *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getJDL, sizeof(struct ns1__getJDL), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getJDL(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jobId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_jobId, "xsd:string"))
				{	soap_flag__jobId--;
					continue;
				}
			if (soap_flag__type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__JdlType(soap, NULL, &a->_type, "ns1:JdlType"))
				{	soap_flag__type--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getJDL *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getJDL, 0, sizeof(struct ns1__getJDL), 0, soap_copy_ns1__getJDL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__jobId > 0 || soap_flag__type > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getJDL(struct soap *soap, const struct ns1__getJDL *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getJDL);
	if (soap_out_ns1__getJDL(soap, tag?tag:"ns1:getJDL", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getJDL * SOAP_FMAC4 soap_get_ns1__getJDL(struct soap *soap, struct ns1__getJDL *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getJDL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getJDL * SOAP_FMAC2 soap_instantiate_ns1__getJDL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getJDL(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getJDL, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getJDL);
		if (size)
			*size = sizeof(struct ns1__getJDL);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getJDL[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getJDL);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getJDL*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getJDL(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getJDL %p -> %p\n", q, p));
	*(struct ns1__getJDL*)p = *(struct ns1__getJDL*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getJDLResponse(struct soap *soap, struct ns1__getJDLResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_jdl);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getJDLResponse(struct soap *soap, const struct ns1__getJDLResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_jdl, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_jdl);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getJDLResponse(struct soap *soap, const char *tag, int id, const struct ns1__getJDLResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getJDLResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "jdl", -1, &a->_jdl, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getJDLResponse * SOAP_FMAC4 soap_in_ns1__getJDLResponse(struct soap *soap, const char *tag, struct ns1__getJDLResponse *a, const char *type)
{
	size_t soap_flag__jdl = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getJDLResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getJDLResponse, sizeof(struct ns1__getJDLResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getJDLResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__jdl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_jdl, "xsd:string"))
				{	soap_flag__jdl--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getJDLResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getJDLResponse, 0, sizeof(struct ns1__getJDLResponse), 0, soap_copy_ns1__getJDLResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__jdl > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getJDLResponse(struct soap *soap, const struct ns1__getJDLResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getJDLResponse);
	if (soap_out_ns1__getJDLResponse(soap, tag?tag:"ns1:getJDLResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getJDLResponse * SOAP_FMAC4 soap_get_ns1__getJDLResponse(struct soap *soap, struct ns1__getJDLResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getJDLResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getJDLResponse * SOAP_FMAC2 soap_instantiate_ns1__getJDLResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getJDLResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getJDLResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getJDLResponse);
		if (size)
			*size = sizeof(struct ns1__getJDLResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getJDLResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getJDLResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getJDLResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getJDLResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getJDLResponse %p -> %p\n", q, p));
	*(struct ns1__getJDLResponse*)p = *(struct ns1__getJDLResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getVersion(struct soap *soap, struct ns1__getVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getVersion(struct soap *soap, const struct ns1__getVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getVersion(struct soap *soap, const char *tag, int id, const struct ns1__getVersion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getVersion), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getVersion * SOAP_FMAC4 soap_in_ns1__getVersion(struct soap *soap, const char *tag, struct ns1__getVersion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getVersion, sizeof(struct ns1__getVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getVersion(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getVersion, 0, sizeof(struct ns1__getVersion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getVersion(struct soap *soap, const struct ns1__getVersion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getVersion);
	if (soap_out_ns1__getVersion(soap, tag?tag:"ns1:getVersion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getVersion * SOAP_FMAC4 soap_get_ns1__getVersion(struct soap *soap, struct ns1__getVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getVersion * SOAP_FMAC2 soap_instantiate_ns1__getVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getVersion);
		if (size)
			*size = sizeof(struct ns1__getVersion);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getVersion[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getVersion);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getVersion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getVersion %p -> %p\n", q, p));
	*(struct ns1__getVersion*)p = *(struct ns1__getVersion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getVersionResponse(struct soap *soap, struct ns1__getVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->version);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getVersionResponse(struct soap *soap, const struct ns1__getVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->version, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->version);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getVersionResponse(struct soap *soap, const char *tag, int id, const struct ns1__getVersionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getVersionResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "version", -1, &a->version, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getVersionResponse * SOAP_FMAC4 soap_in_ns1__getVersionResponse(struct soap *soap, const char *tag, struct ns1__getVersionResponse *a, const char *type)
{
	size_t soap_flag_version = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getVersionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getVersionResponse, sizeof(struct ns1__getVersionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getVersionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_version && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "version", &a->version, "xsd:string"))
				{	soap_flag_version--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getVersionResponse, 0, sizeof(struct ns1__getVersionResponse), 0, soap_copy_ns1__getVersionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_version > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getVersionResponse(struct soap *soap, const struct ns1__getVersionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getVersionResponse);
	if (soap_out_ns1__getVersionResponse(soap, tag?tag:"ns1:getVersionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getVersionResponse * SOAP_FMAC4 soap_get_ns1__getVersionResponse(struct soap *soap, struct ns1__getVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getVersionResponse * SOAP_FMAC2 soap_instantiate_ns1__getVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getVersionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getVersionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getVersionResponse);
		if (size)
			*size = sizeof(struct ns1__getVersionResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getVersionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getVersionResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getVersionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getVersionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getVersionResponse %p -> %p\n", q, p));
	*(struct ns1__getVersionResponse*)p = *(struct ns1__getVersionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__putProxy(struct soap *soap, struct ns1__putProxy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_delegationID);
	soap_default_std__string(soap, &a->_proxy);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__putProxy(struct soap *soap, const struct ns1__putProxy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_delegationID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_delegationID);
	soap_embedded(soap, &a->_proxy, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_proxy);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__putProxy(struct soap *soap, const char *tag, int id, const struct ns1__putProxy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__putProxy), type))
		return soap->error;
	if (soap_out_std__string(soap, "delegationID", -1, &a->_delegationID, ""))
		return soap->error;
	if (soap_out_std__string(soap, "proxy", -1, &a->_proxy, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__putProxy * SOAP_FMAC4 soap_in_ns1__putProxy(struct soap *soap, const char *tag, struct ns1__putProxy *a, const char *type)
{
	size_t soap_flag__delegationID = 1;
	size_t soap_flag__proxy = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__putProxy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__putProxy, sizeof(struct ns1__putProxy), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__putProxy(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__delegationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_delegationID, "xsd:string"))
				{	soap_flag__delegationID--;
					continue;
				}
			if (soap_flag__proxy && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_proxy, "xsd:string"))
				{	soap_flag__proxy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__putProxy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__putProxy, 0, sizeof(struct ns1__putProxy), 0, soap_copy_ns1__putProxy);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__delegationID > 0 || soap_flag__proxy > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__putProxy(struct soap *soap, const struct ns1__putProxy *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__putProxy);
	if (soap_out_ns1__putProxy(soap, tag?tag:"ns1:putProxy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__putProxy * SOAP_FMAC4 soap_get_ns1__putProxy(struct soap *soap, struct ns1__putProxy *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__putProxy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__putProxy * SOAP_FMAC2 soap_instantiate_ns1__putProxy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__putProxy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__putProxy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__putProxy);
		if (size)
			*size = sizeof(struct ns1__putProxy);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__putProxy[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__putProxy);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__putProxy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__putProxy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__putProxy %p -> %p\n", q, p));
	*(struct ns1__putProxy*)p = *(struct ns1__putProxy*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__putProxyResponse(struct soap *soap, struct ns1__putProxyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__putProxyResponse(struct soap *soap, const struct ns1__putProxyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__putProxyResponse(struct soap *soap, const char *tag, int id, const struct ns1__putProxyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__putProxyResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__putProxyResponse * SOAP_FMAC4 soap_in_ns1__putProxyResponse(struct soap *soap, const char *tag, struct ns1__putProxyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__putProxyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__putProxyResponse, sizeof(struct ns1__putProxyResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__putProxyResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__putProxyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__putProxyResponse, 0, sizeof(struct ns1__putProxyResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__putProxyResponse(struct soap *soap, const struct ns1__putProxyResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__putProxyResponse);
	if (soap_out_ns1__putProxyResponse(soap, tag?tag:"ns1:putProxyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__putProxyResponse * SOAP_FMAC4 soap_get_ns1__putProxyResponse(struct soap *soap, struct ns1__putProxyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__putProxyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__putProxyResponse * SOAP_FMAC2 soap_instantiate_ns1__putProxyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__putProxyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__putProxyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__putProxyResponse);
		if (size)
			*size = sizeof(struct ns1__putProxyResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__putProxyResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__putProxyResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__putProxyResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__putProxyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__putProxyResponse %p -> %p\n", q, p));
	*(struct ns1__putProxyResponse*)p = *(struct ns1__putProxyResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getProxyReq(struct soap *soap, struct ns1__getProxyReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_delegationID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getProxyReq(struct soap *soap, const struct ns1__getProxyReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_delegationID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_delegationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getProxyReq(struct soap *soap, const char *tag, int id, const struct ns1__getProxyReq *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getProxyReq), type))
		return soap->error;
	if (soap_out_std__string(soap, "delegationID", -1, &a->_delegationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getProxyReq * SOAP_FMAC4 soap_in_ns1__getProxyReq(struct soap *soap, const char *tag, struct ns1__getProxyReq *a, const char *type)
{
	size_t soap_flag__delegationID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getProxyReq *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getProxyReq, sizeof(struct ns1__getProxyReq), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getProxyReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__delegationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_delegationID, "xsd:string"))
				{	soap_flag__delegationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getProxyReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getProxyReq, 0, sizeof(struct ns1__getProxyReq), 0, soap_copy_ns1__getProxyReq);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__delegationID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getProxyReq(struct soap *soap, const struct ns1__getProxyReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getProxyReq);
	if (soap_out_ns1__getProxyReq(soap, tag?tag:"ns1:getProxyReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getProxyReq * SOAP_FMAC4 soap_get_ns1__getProxyReq(struct soap *soap, struct ns1__getProxyReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getProxyReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getProxyReq * SOAP_FMAC2 soap_instantiate_ns1__getProxyReq(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getProxyReq(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getProxyReq, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getProxyReq);
		if (size)
			*size = sizeof(struct ns1__getProxyReq);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getProxyReq[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getProxyReq);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getProxyReq*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getProxyReq(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getProxyReq %p -> %p\n", q, p));
	*(struct ns1__getProxyReq*)p = *(struct ns1__getProxyReq*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getProxyReqResponse(struct soap *soap, struct ns1__getProxyReqResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_request);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getProxyReqResponse(struct soap *soap, const struct ns1__getProxyReqResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_request, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_request);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getProxyReqResponse(struct soap *soap, const char *tag, int id, const struct ns1__getProxyReqResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getProxyReqResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "request", -1, &a->_request, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getProxyReqResponse * SOAP_FMAC4 soap_in_ns1__getProxyReqResponse(struct soap *soap, const char *tag, struct ns1__getProxyReqResponse *a, const char *type)
{
	size_t soap_flag__request = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getProxyReqResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getProxyReqResponse, sizeof(struct ns1__getProxyReqResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getProxyReqResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__request && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_request, "xsd:string"))
				{	soap_flag__request--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getProxyReqResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getProxyReqResponse, 0, sizeof(struct ns1__getProxyReqResponse), 0, soap_copy_ns1__getProxyReqResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__request > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getProxyReqResponse(struct soap *soap, const struct ns1__getProxyReqResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getProxyReqResponse);
	if (soap_out_ns1__getProxyReqResponse(soap, tag?tag:"ns1:getProxyReqResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getProxyReqResponse * SOAP_FMAC4 soap_get_ns1__getProxyReqResponse(struct soap *soap, struct ns1__getProxyReqResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getProxyReqResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getProxyReqResponse * SOAP_FMAC2 soap_instantiate_ns1__getProxyReqResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getProxyReqResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getProxyReqResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getProxyReqResponse);
		if (size)
			*size = sizeof(struct ns1__getProxyReqResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getProxyReqResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getProxyReqResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getProxyReqResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getProxyReqResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getProxyReqResponse %p -> %p\n", q, p));
	*(struct ns1__getProxyReqResponse*)p = *(struct ns1__getProxyReqResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegationns__destroy(struct soap *soap, struct delegationns__destroy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_delegationID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegationns__destroy(struct soap *soap, const struct delegationns__destroy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_delegationID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_delegationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegationns__destroy(struct soap *soap, const char *tag, int id, const struct delegationns__destroy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegationns__destroy), type))
		return soap->error;
	if (soap_out_std__string(soap, "delegationID", -1, &a->_delegationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegationns__destroy * SOAP_FMAC4 soap_in_delegationns__destroy(struct soap *soap, const char *tag, struct delegationns__destroy *a, const char *type)
{
	size_t soap_flag__delegationID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegationns__destroy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_delegationns__destroy, sizeof(struct delegationns__destroy), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegationns__destroy(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__delegationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_delegationID, "xsd:string"))
				{	soap_flag__delegationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegationns__destroy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegationns__destroy, 0, sizeof(struct delegationns__destroy), 0, soap_copy_delegationns__destroy);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__delegationID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegationns__destroy(struct soap *soap, const struct delegationns__destroy *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegationns__destroy);
	if (soap_out_delegationns__destroy(soap, tag?tag:"delegationns:destroy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegationns__destroy * SOAP_FMAC4 soap_get_delegationns__destroy(struct soap *soap, struct delegationns__destroy *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegationns__destroy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegationns__destroy * SOAP_FMAC2 soap_instantiate_delegationns__destroy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegationns__destroy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegationns__destroy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__destroy);
		if (size)
			*size = sizeof(struct delegationns__destroy);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__destroy[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegationns__destroy);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegationns__destroy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegationns__destroy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegationns__destroy %p -> %p\n", q, p));
	*(struct delegationns__destroy*)p = *(struct delegationns__destroy*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegationns__destroyResponse(struct soap *soap, struct delegationns__destroyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegationns__destroyResponse(struct soap *soap, const struct delegationns__destroyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegationns__destroyResponse(struct soap *soap, const char *tag, int id, const struct delegationns__destroyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegationns__destroyResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegationns__destroyResponse * SOAP_FMAC4 soap_in_delegationns__destroyResponse(struct soap *soap, const char *tag, struct delegationns__destroyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegationns__destroyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_delegationns__destroyResponse, sizeof(struct delegationns__destroyResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_delegationns__destroyResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegationns__destroyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegationns__destroyResponse, 0, sizeof(struct delegationns__destroyResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegationns__destroyResponse(struct soap *soap, const struct delegationns__destroyResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegationns__destroyResponse);
	if (soap_out_delegationns__destroyResponse(soap, tag?tag:"delegationns:destroyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegationns__destroyResponse * SOAP_FMAC4 soap_get_delegationns__destroyResponse(struct soap *soap, struct delegationns__destroyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegationns__destroyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegationns__destroyResponse * SOAP_FMAC2 soap_instantiate_delegationns__destroyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegationns__destroyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegationns__destroyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__destroyResponse);
		if (size)
			*size = sizeof(struct delegationns__destroyResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__destroyResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegationns__destroyResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegationns__destroyResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegationns__destroyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegationns__destroyResponse %p -> %p\n", q, p));
	*(struct delegationns__destroyResponse*)p = *(struct delegationns__destroyResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegationns__getTerminationTime(struct soap *soap, struct delegationns__getTerminationTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_delegationID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegationns__getTerminationTime(struct soap *soap, const struct delegationns__getTerminationTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_delegationID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_delegationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegationns__getTerminationTime(struct soap *soap, const char *tag, int id, const struct delegationns__getTerminationTime *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegationns__getTerminationTime), type))
		return soap->error;
	if (soap_out_std__string(soap, "delegationID", -1, &a->_delegationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegationns__getTerminationTime * SOAP_FMAC4 soap_in_delegationns__getTerminationTime(struct soap *soap, const char *tag, struct delegationns__getTerminationTime *a, const char *type)
{
	size_t soap_flag__delegationID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegationns__getTerminationTime *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_delegationns__getTerminationTime, sizeof(struct delegationns__getTerminationTime), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegationns__getTerminationTime(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__delegationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_delegationID, "xsd:string"))
				{	soap_flag__delegationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegationns__getTerminationTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegationns__getTerminationTime, 0, sizeof(struct delegationns__getTerminationTime), 0, soap_copy_delegationns__getTerminationTime);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__delegationID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegationns__getTerminationTime(struct soap *soap, const struct delegationns__getTerminationTime *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegationns__getTerminationTime);
	if (soap_out_delegationns__getTerminationTime(soap, tag?tag:"delegationns:getTerminationTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegationns__getTerminationTime * SOAP_FMAC4 soap_get_delegationns__getTerminationTime(struct soap *soap, struct delegationns__getTerminationTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegationns__getTerminationTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegationns__getTerminationTime * SOAP_FMAC2 soap_instantiate_delegationns__getTerminationTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegationns__getTerminationTime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegationns__getTerminationTime, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__getTerminationTime);
		if (size)
			*size = sizeof(struct delegationns__getTerminationTime);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__getTerminationTime[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegationns__getTerminationTime);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegationns__getTerminationTime*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegationns__getTerminationTime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegationns__getTerminationTime %p -> %p\n", q, p));
	*(struct delegationns__getTerminationTime*)p = *(struct delegationns__getTerminationTime*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegationns__getTerminationTimeResponse(struct soap *soap, struct delegationns__getTerminationTimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->_getTerminationTimeReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegationns__getTerminationTimeResponse(struct soap *soap, const struct delegationns__getTerminationTimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegationns__getTerminationTimeResponse(struct soap *soap, const char *tag, int id, const struct delegationns__getTerminationTimeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegationns__getTerminationTimeResponse), type))
		return soap->error;
	if (soap_out_time(soap, "getTerminationTimeReturn", -1, &a->_getTerminationTimeReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegationns__getTerminationTimeResponse * SOAP_FMAC4 soap_in_delegationns__getTerminationTimeResponse(struct soap *soap, const char *tag, struct delegationns__getTerminationTimeResponse *a, const char *type)
{
	size_t soap_flag__getTerminationTimeReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegationns__getTerminationTimeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_delegationns__getTerminationTimeResponse, sizeof(struct delegationns__getTerminationTimeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_delegationns__getTerminationTimeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getTerminationTimeReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, NULL, &a->_getTerminationTimeReturn, "xsd:dateTime"))
				{	soap_flag__getTerminationTimeReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegationns__getTerminationTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegationns__getTerminationTimeResponse, 0, sizeof(struct delegationns__getTerminationTimeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getTerminationTimeReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegationns__getTerminationTimeResponse(struct soap *soap, const struct delegationns__getTerminationTimeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegationns__getTerminationTimeResponse);
	if (soap_out_delegationns__getTerminationTimeResponse(soap, tag?tag:"delegationns:getTerminationTimeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegationns__getTerminationTimeResponse * SOAP_FMAC4 soap_get_delegationns__getTerminationTimeResponse(struct soap *soap, struct delegationns__getTerminationTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegationns__getTerminationTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegationns__getTerminationTimeResponse * SOAP_FMAC2 soap_instantiate_delegationns__getTerminationTimeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegationns__getTerminationTimeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegationns__getTerminationTimeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__getTerminationTimeResponse);
		if (size)
			*size = sizeof(struct delegationns__getTerminationTimeResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__getTerminationTimeResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegationns__getTerminationTimeResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegationns__getTerminationTimeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegationns__getTerminationTimeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegationns__getTerminationTimeResponse %p -> %p\n", q, p));
	*(struct delegationns__getTerminationTimeResponse*)p = *(struct delegationns__getTerminationTimeResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegationns__putProxy(struct soap *soap, struct delegationns__putProxy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_delegationID);
	soap_default_std__string(soap, &a->_proxy);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegationns__putProxy(struct soap *soap, const struct delegationns__putProxy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_delegationID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_delegationID);
	soap_embedded(soap, &a->_proxy, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_proxy);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegationns__putProxy(struct soap *soap, const char *tag, int id, const struct delegationns__putProxy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegationns__putProxy), type))
		return soap->error;
	if (soap_out_std__string(soap, "delegationID", -1, &a->_delegationID, ""))
		return soap->error;
	if (soap_out_std__string(soap, "proxy", -1, &a->_proxy, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegationns__putProxy * SOAP_FMAC4 soap_in_delegationns__putProxy(struct soap *soap, const char *tag, struct delegationns__putProxy *a, const char *type)
{
	size_t soap_flag__delegationID = 1;
	size_t soap_flag__proxy = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegationns__putProxy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_delegationns__putProxy, sizeof(struct delegationns__putProxy), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegationns__putProxy(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__delegationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_delegationID, "xsd:string"))
				{	soap_flag__delegationID--;
					continue;
				}
			if (soap_flag__proxy && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_proxy, "xsd:string"))
				{	soap_flag__proxy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegationns__putProxy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegationns__putProxy, 0, sizeof(struct delegationns__putProxy), 0, soap_copy_delegationns__putProxy);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__delegationID > 0 || soap_flag__proxy > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegationns__putProxy(struct soap *soap, const struct delegationns__putProxy *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegationns__putProxy);
	if (soap_out_delegationns__putProxy(soap, tag?tag:"delegationns:putProxy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegationns__putProxy * SOAP_FMAC4 soap_get_delegationns__putProxy(struct soap *soap, struct delegationns__putProxy *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegationns__putProxy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegationns__putProxy * SOAP_FMAC2 soap_instantiate_delegationns__putProxy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegationns__putProxy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegationns__putProxy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__putProxy);
		if (size)
			*size = sizeof(struct delegationns__putProxy);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__putProxy[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegationns__putProxy);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegationns__putProxy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegationns__putProxy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegationns__putProxy %p -> %p\n", q, p));
	*(struct delegationns__putProxy*)p = *(struct delegationns__putProxy*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegationns__putProxyResponse(struct soap *soap, struct delegationns__putProxyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegationns__putProxyResponse(struct soap *soap, const struct delegationns__putProxyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegationns__putProxyResponse(struct soap *soap, const char *tag, int id, const struct delegationns__putProxyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegationns__putProxyResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegationns__putProxyResponse * SOAP_FMAC4 soap_in_delegationns__putProxyResponse(struct soap *soap, const char *tag, struct delegationns__putProxyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegationns__putProxyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_delegationns__putProxyResponse, sizeof(struct delegationns__putProxyResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_delegationns__putProxyResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegationns__putProxyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegationns__putProxyResponse, 0, sizeof(struct delegationns__putProxyResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegationns__putProxyResponse(struct soap *soap, const struct delegationns__putProxyResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegationns__putProxyResponse);
	if (soap_out_delegationns__putProxyResponse(soap, tag?tag:"delegationns:putProxyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegationns__putProxyResponse * SOAP_FMAC4 soap_get_delegationns__putProxyResponse(struct soap *soap, struct delegationns__putProxyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegationns__putProxyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegationns__putProxyResponse * SOAP_FMAC2 soap_instantiate_delegationns__putProxyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegationns__putProxyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegationns__putProxyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__putProxyResponse);
		if (size)
			*size = sizeof(struct delegationns__putProxyResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__putProxyResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegationns__putProxyResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegationns__putProxyResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegationns__putProxyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegationns__putProxyResponse %p -> %p\n", q, p));
	*(struct delegationns__putProxyResponse*)p = *(struct delegationns__putProxyResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegationns__renewProxyReq(struct soap *soap, struct delegationns__renewProxyReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_delegationID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegationns__renewProxyReq(struct soap *soap, const struct delegationns__renewProxyReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_delegationID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_delegationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegationns__renewProxyReq(struct soap *soap, const char *tag, int id, const struct delegationns__renewProxyReq *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegationns__renewProxyReq), type))
		return soap->error;
	if (soap_out_std__string(soap, "delegationID", -1, &a->_delegationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegationns__renewProxyReq * SOAP_FMAC4 soap_in_delegationns__renewProxyReq(struct soap *soap, const char *tag, struct delegationns__renewProxyReq *a, const char *type)
{
	size_t soap_flag__delegationID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegationns__renewProxyReq *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_delegationns__renewProxyReq, sizeof(struct delegationns__renewProxyReq), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegationns__renewProxyReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__delegationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_delegationID, "xsd:string"))
				{	soap_flag__delegationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegationns__renewProxyReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegationns__renewProxyReq, 0, sizeof(struct delegationns__renewProxyReq), 0, soap_copy_delegationns__renewProxyReq);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__delegationID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegationns__renewProxyReq(struct soap *soap, const struct delegationns__renewProxyReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegationns__renewProxyReq);
	if (soap_out_delegationns__renewProxyReq(soap, tag?tag:"delegationns:renewProxyReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegationns__renewProxyReq * SOAP_FMAC4 soap_get_delegationns__renewProxyReq(struct soap *soap, struct delegationns__renewProxyReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegationns__renewProxyReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegationns__renewProxyReq * SOAP_FMAC2 soap_instantiate_delegationns__renewProxyReq(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegationns__renewProxyReq(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegationns__renewProxyReq, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__renewProxyReq);
		if (size)
			*size = sizeof(struct delegationns__renewProxyReq);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__renewProxyReq[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegationns__renewProxyReq);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegationns__renewProxyReq*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegationns__renewProxyReq(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegationns__renewProxyReq %p -> %p\n", q, p));
	*(struct delegationns__renewProxyReq*)p = *(struct delegationns__renewProxyReq*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegationns__renewProxyReqResponse(struct soap *soap, struct delegationns__renewProxyReqResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_renewProxyReqReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegationns__renewProxyReqResponse(struct soap *soap, const struct delegationns__renewProxyReqResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_renewProxyReqReturn, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_renewProxyReqReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegationns__renewProxyReqResponse(struct soap *soap, const char *tag, int id, const struct delegationns__renewProxyReqResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegationns__renewProxyReqResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "renewProxyReqReturn", -1, &a->_renewProxyReqReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegationns__renewProxyReqResponse * SOAP_FMAC4 soap_in_delegationns__renewProxyReqResponse(struct soap *soap, const char *tag, struct delegationns__renewProxyReqResponse *a, const char *type)
{
	size_t soap_flag__renewProxyReqReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegationns__renewProxyReqResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_delegationns__renewProxyReqResponse, sizeof(struct delegationns__renewProxyReqResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegationns__renewProxyReqResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__renewProxyReqReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_renewProxyReqReturn, "xsd:string"))
				{	soap_flag__renewProxyReqReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegationns__renewProxyReqResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegationns__renewProxyReqResponse, 0, sizeof(struct delegationns__renewProxyReqResponse), 0, soap_copy_delegationns__renewProxyReqResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__renewProxyReqReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegationns__renewProxyReqResponse(struct soap *soap, const struct delegationns__renewProxyReqResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegationns__renewProxyReqResponse);
	if (soap_out_delegationns__renewProxyReqResponse(soap, tag?tag:"delegationns:renewProxyReqResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegationns__renewProxyReqResponse * SOAP_FMAC4 soap_get_delegationns__renewProxyReqResponse(struct soap *soap, struct delegationns__renewProxyReqResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegationns__renewProxyReqResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegationns__renewProxyReqResponse * SOAP_FMAC2 soap_instantiate_delegationns__renewProxyReqResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegationns__renewProxyReqResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegationns__renewProxyReqResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__renewProxyReqResponse);
		if (size)
			*size = sizeof(struct delegationns__renewProxyReqResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__renewProxyReqResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegationns__renewProxyReqResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegationns__renewProxyReqResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegationns__renewProxyReqResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegationns__renewProxyReqResponse %p -> %p\n", q, p));
	*(struct delegationns__renewProxyReqResponse*)p = *(struct delegationns__renewProxyReqResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegationns__getNewProxyReq(struct soap *soap, struct delegationns__getNewProxyReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegationns__getNewProxyReq(struct soap *soap, const struct delegationns__getNewProxyReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegationns__getNewProxyReq(struct soap *soap, const char *tag, int id, const struct delegationns__getNewProxyReq *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegationns__getNewProxyReq), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegationns__getNewProxyReq * SOAP_FMAC4 soap_in_delegationns__getNewProxyReq(struct soap *soap, const char *tag, struct delegationns__getNewProxyReq *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegationns__getNewProxyReq *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_delegationns__getNewProxyReq, sizeof(struct delegationns__getNewProxyReq), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_delegationns__getNewProxyReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegationns__getNewProxyReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegationns__getNewProxyReq, 0, sizeof(struct delegationns__getNewProxyReq), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegationns__getNewProxyReq(struct soap *soap, const struct delegationns__getNewProxyReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegationns__getNewProxyReq);
	if (soap_out_delegationns__getNewProxyReq(soap, tag?tag:"delegationns:getNewProxyReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegationns__getNewProxyReq * SOAP_FMAC4 soap_get_delegationns__getNewProxyReq(struct soap *soap, struct delegationns__getNewProxyReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegationns__getNewProxyReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegationns__getNewProxyReq * SOAP_FMAC2 soap_instantiate_delegationns__getNewProxyReq(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegationns__getNewProxyReq(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegationns__getNewProxyReq, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__getNewProxyReq);
		if (size)
			*size = sizeof(struct delegationns__getNewProxyReq);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__getNewProxyReq[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegationns__getNewProxyReq);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegationns__getNewProxyReq*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegationns__getNewProxyReq(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegationns__getNewProxyReq %p -> %p\n", q, p));
	*(struct delegationns__getNewProxyReq*)p = *(struct delegationns__getNewProxyReq*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegationns__getNewProxyReqResponse(struct soap *soap, struct delegationns__getNewProxyReqResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->getNewProxyReqReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegationns__getNewProxyReqResponse(struct soap *soap, const struct delegationns__getNewProxyReqResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTodelegationns__NewProxyReq(soap, &a->getNewProxyReqReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegationns__getNewProxyReqResponse(struct soap *soap, const char *tag, int id, const struct delegationns__getNewProxyReqResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegationns__getNewProxyReqResponse), type))
		return soap->error;
	if (soap_out_PointerTodelegationns__NewProxyReq(soap, "getNewProxyReqReturn", -1, &a->getNewProxyReqReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegationns__getNewProxyReqResponse * SOAP_FMAC4 soap_in_delegationns__getNewProxyReqResponse(struct soap *soap, const char *tag, struct delegationns__getNewProxyReqResponse *a, const char *type)
{
	size_t soap_flag_getNewProxyReqReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegationns__getNewProxyReqResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_delegationns__getNewProxyReqResponse, sizeof(struct delegationns__getNewProxyReqResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_delegationns__getNewProxyReqResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getNewProxyReqReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodelegationns__NewProxyReq(soap, "getNewProxyReqReturn", &a->getNewProxyReqReturn, "delegationns:NewProxyReq"))
				{	soap_flag_getNewProxyReqReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegationns__getNewProxyReqResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegationns__getNewProxyReqResponse, 0, sizeof(struct delegationns__getNewProxyReqResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegationns__getNewProxyReqResponse(struct soap *soap, const struct delegationns__getNewProxyReqResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegationns__getNewProxyReqResponse);
	if (soap_out_delegationns__getNewProxyReqResponse(soap, tag?tag:"delegationns:getNewProxyReqResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegationns__getNewProxyReqResponse * SOAP_FMAC4 soap_get_delegationns__getNewProxyReqResponse(struct soap *soap, struct delegationns__getNewProxyReqResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegationns__getNewProxyReqResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegationns__getNewProxyReqResponse * SOAP_FMAC2 soap_instantiate_delegationns__getNewProxyReqResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegationns__getNewProxyReqResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegationns__getNewProxyReqResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__getNewProxyReqResponse);
		if (size)
			*size = sizeof(struct delegationns__getNewProxyReqResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__getNewProxyReqResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegationns__getNewProxyReqResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegationns__getNewProxyReqResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegationns__getNewProxyReqResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegationns__getNewProxyReqResponse %p -> %p\n", q, p));
	*(struct delegationns__getNewProxyReqResponse*)p = *(struct delegationns__getNewProxyReqResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegationns__getProxyReq(struct soap *soap, struct delegationns__getProxyReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_delegationID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegationns__getProxyReq(struct soap *soap, const struct delegationns__getProxyReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_delegationID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_delegationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegationns__getProxyReq(struct soap *soap, const char *tag, int id, const struct delegationns__getProxyReq *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegationns__getProxyReq), type))
		return soap->error;
	if (soap_out_std__string(soap, "delegationID", -1, &a->_delegationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegationns__getProxyReq * SOAP_FMAC4 soap_in_delegationns__getProxyReq(struct soap *soap, const char *tag, struct delegationns__getProxyReq *a, const char *type)
{
	size_t soap_flag__delegationID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegationns__getProxyReq *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_delegationns__getProxyReq, sizeof(struct delegationns__getProxyReq), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegationns__getProxyReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__delegationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_delegationID, "xsd:string"))
				{	soap_flag__delegationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegationns__getProxyReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegationns__getProxyReq, 0, sizeof(struct delegationns__getProxyReq), 0, soap_copy_delegationns__getProxyReq);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__delegationID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegationns__getProxyReq(struct soap *soap, const struct delegationns__getProxyReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegationns__getProxyReq);
	if (soap_out_delegationns__getProxyReq(soap, tag?tag:"delegationns:getProxyReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegationns__getProxyReq * SOAP_FMAC4 soap_get_delegationns__getProxyReq(struct soap *soap, struct delegationns__getProxyReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegationns__getProxyReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegationns__getProxyReq * SOAP_FMAC2 soap_instantiate_delegationns__getProxyReq(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegationns__getProxyReq(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegationns__getProxyReq, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__getProxyReq);
		if (size)
			*size = sizeof(struct delegationns__getProxyReq);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__getProxyReq[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegationns__getProxyReq);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegationns__getProxyReq*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegationns__getProxyReq(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegationns__getProxyReq %p -> %p\n", q, p));
	*(struct delegationns__getProxyReq*)p = *(struct delegationns__getProxyReq*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegationns__getProxyReqResponse(struct soap *soap, struct delegationns__getProxyReqResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_getProxyReqReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegationns__getProxyReqResponse(struct soap *soap, const struct delegationns__getProxyReqResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_getProxyReqReturn, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_getProxyReqReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegationns__getProxyReqResponse(struct soap *soap, const char *tag, int id, const struct delegationns__getProxyReqResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegationns__getProxyReqResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "getProxyReqReturn", -1, &a->_getProxyReqReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegationns__getProxyReqResponse * SOAP_FMAC4 soap_in_delegationns__getProxyReqResponse(struct soap *soap, const char *tag, struct delegationns__getProxyReqResponse *a, const char *type)
{
	size_t soap_flag__getProxyReqReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegationns__getProxyReqResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_delegationns__getProxyReqResponse, sizeof(struct delegationns__getProxyReqResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegationns__getProxyReqResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getProxyReqReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_getProxyReqReturn, "xsd:string"))
				{	soap_flag__getProxyReqReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegationns__getProxyReqResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegationns__getProxyReqResponse, 0, sizeof(struct delegationns__getProxyReqResponse), 0, soap_copy_delegationns__getProxyReqResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getProxyReqReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegationns__getProxyReqResponse(struct soap *soap, const struct delegationns__getProxyReqResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegationns__getProxyReqResponse);
	if (soap_out_delegationns__getProxyReqResponse(soap, tag?tag:"delegationns:getProxyReqResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegationns__getProxyReqResponse * SOAP_FMAC4 soap_get_delegationns__getProxyReqResponse(struct soap *soap, struct delegationns__getProxyReqResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegationns__getProxyReqResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegationns__getProxyReqResponse * SOAP_FMAC2 soap_instantiate_delegationns__getProxyReqResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegationns__getProxyReqResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegationns__getProxyReqResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__getProxyReqResponse);
		if (size)
			*size = sizeof(struct delegationns__getProxyReqResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__getProxyReqResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegationns__getProxyReqResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegationns__getProxyReqResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegationns__getProxyReqResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegationns__getProxyReqResponse %p -> %p\n", q, p));
	*(struct delegationns__getProxyReqResponse*)p = *(struct delegationns__getProxyReqResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegationns__getServiceMetadata(struct soap *soap, struct delegationns__getServiceMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_key);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegationns__getServiceMetadata(struct soap *soap, const struct delegationns__getServiceMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_key, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_key);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegationns__getServiceMetadata(struct soap *soap, const char *tag, int id, const struct delegationns__getServiceMetadata *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegationns__getServiceMetadata), type))
		return soap->error;
	if (soap_out_std__string(soap, "key", -1, &a->_key, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegationns__getServiceMetadata * SOAP_FMAC4 soap_in_delegationns__getServiceMetadata(struct soap *soap, const char *tag, struct delegationns__getServiceMetadata *a, const char *type)
{
	size_t soap_flag__key = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegationns__getServiceMetadata *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_delegationns__getServiceMetadata, sizeof(struct delegationns__getServiceMetadata), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegationns__getServiceMetadata(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__key && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_key, "xsd:string"))
				{	soap_flag__key--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegationns__getServiceMetadata *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegationns__getServiceMetadata, 0, sizeof(struct delegationns__getServiceMetadata), 0, soap_copy_delegationns__getServiceMetadata);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__key > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegationns__getServiceMetadata(struct soap *soap, const struct delegationns__getServiceMetadata *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegationns__getServiceMetadata);
	if (soap_out_delegationns__getServiceMetadata(soap, tag?tag:"delegationns:getServiceMetadata", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegationns__getServiceMetadata * SOAP_FMAC4 soap_get_delegationns__getServiceMetadata(struct soap *soap, struct delegationns__getServiceMetadata *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegationns__getServiceMetadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegationns__getServiceMetadata * SOAP_FMAC2 soap_instantiate_delegationns__getServiceMetadata(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegationns__getServiceMetadata(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegationns__getServiceMetadata, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__getServiceMetadata);
		if (size)
			*size = sizeof(struct delegationns__getServiceMetadata);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__getServiceMetadata[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegationns__getServiceMetadata);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegationns__getServiceMetadata*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegationns__getServiceMetadata(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegationns__getServiceMetadata %p -> %p\n", q, p));
	*(struct delegationns__getServiceMetadata*)p = *(struct delegationns__getServiceMetadata*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegationns__getServiceMetadataResponse(struct soap *soap, struct delegationns__getServiceMetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_getServiceMetadataReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegationns__getServiceMetadataResponse(struct soap *soap, const struct delegationns__getServiceMetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_getServiceMetadataReturn, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_getServiceMetadataReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegationns__getServiceMetadataResponse(struct soap *soap, const char *tag, int id, const struct delegationns__getServiceMetadataResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegationns__getServiceMetadataResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "getServiceMetadataReturn", -1, &a->_getServiceMetadataReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegationns__getServiceMetadataResponse * SOAP_FMAC4 soap_in_delegationns__getServiceMetadataResponse(struct soap *soap, const char *tag, struct delegationns__getServiceMetadataResponse *a, const char *type)
{
	size_t soap_flag__getServiceMetadataReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegationns__getServiceMetadataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_delegationns__getServiceMetadataResponse, sizeof(struct delegationns__getServiceMetadataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegationns__getServiceMetadataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getServiceMetadataReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_getServiceMetadataReturn, "xsd:string"))
				{	soap_flag__getServiceMetadataReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegationns__getServiceMetadataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegationns__getServiceMetadataResponse, 0, sizeof(struct delegationns__getServiceMetadataResponse), 0, soap_copy_delegationns__getServiceMetadataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getServiceMetadataReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegationns__getServiceMetadataResponse(struct soap *soap, const struct delegationns__getServiceMetadataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegationns__getServiceMetadataResponse);
	if (soap_out_delegationns__getServiceMetadataResponse(soap, tag?tag:"delegationns:getServiceMetadataResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegationns__getServiceMetadataResponse * SOAP_FMAC4 soap_get_delegationns__getServiceMetadataResponse(struct soap *soap, struct delegationns__getServiceMetadataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegationns__getServiceMetadataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegationns__getServiceMetadataResponse * SOAP_FMAC2 soap_instantiate_delegationns__getServiceMetadataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegationns__getServiceMetadataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegationns__getServiceMetadataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__getServiceMetadataResponse);
		if (size)
			*size = sizeof(struct delegationns__getServiceMetadataResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__getServiceMetadataResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegationns__getServiceMetadataResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegationns__getServiceMetadataResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegationns__getServiceMetadataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegationns__getServiceMetadataResponse %p -> %p\n", q, p));
	*(struct delegationns__getServiceMetadataResponse*)p = *(struct delegationns__getServiceMetadataResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegationns__getInterfaceVersion(struct soap *soap, struct delegationns__getInterfaceVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegationns__getInterfaceVersion(struct soap *soap, const struct delegationns__getInterfaceVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegationns__getInterfaceVersion(struct soap *soap, const char *tag, int id, const struct delegationns__getInterfaceVersion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegationns__getInterfaceVersion), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegationns__getInterfaceVersion * SOAP_FMAC4 soap_in_delegationns__getInterfaceVersion(struct soap *soap, const char *tag, struct delegationns__getInterfaceVersion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegationns__getInterfaceVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_delegationns__getInterfaceVersion, sizeof(struct delegationns__getInterfaceVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_delegationns__getInterfaceVersion(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegationns__getInterfaceVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegationns__getInterfaceVersion, 0, sizeof(struct delegationns__getInterfaceVersion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegationns__getInterfaceVersion(struct soap *soap, const struct delegationns__getInterfaceVersion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegationns__getInterfaceVersion);
	if (soap_out_delegationns__getInterfaceVersion(soap, tag?tag:"delegationns:getInterfaceVersion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegationns__getInterfaceVersion * SOAP_FMAC4 soap_get_delegationns__getInterfaceVersion(struct soap *soap, struct delegationns__getInterfaceVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegationns__getInterfaceVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegationns__getInterfaceVersion * SOAP_FMAC2 soap_instantiate_delegationns__getInterfaceVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegationns__getInterfaceVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegationns__getInterfaceVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__getInterfaceVersion);
		if (size)
			*size = sizeof(struct delegationns__getInterfaceVersion);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__getInterfaceVersion[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegationns__getInterfaceVersion);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegationns__getInterfaceVersion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegationns__getInterfaceVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegationns__getInterfaceVersion %p -> %p\n", q, p));
	*(struct delegationns__getInterfaceVersion*)p = *(struct delegationns__getInterfaceVersion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegationns__getInterfaceVersionResponse(struct soap *soap, struct delegationns__getInterfaceVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->getInterfaceVersionReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegationns__getInterfaceVersionResponse(struct soap *soap, const struct delegationns__getInterfaceVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->getInterfaceVersionReturn, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->getInterfaceVersionReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegationns__getInterfaceVersionResponse(struct soap *soap, const char *tag, int id, const struct delegationns__getInterfaceVersionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegationns__getInterfaceVersionResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "getInterfaceVersionReturn", -1, &a->getInterfaceVersionReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegationns__getInterfaceVersionResponse * SOAP_FMAC4 soap_in_delegationns__getInterfaceVersionResponse(struct soap *soap, const char *tag, struct delegationns__getInterfaceVersionResponse *a, const char *type)
{
	size_t soap_flag_getInterfaceVersionReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegationns__getInterfaceVersionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_delegationns__getInterfaceVersionResponse, sizeof(struct delegationns__getInterfaceVersionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegationns__getInterfaceVersionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getInterfaceVersionReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "getInterfaceVersionReturn", &a->getInterfaceVersionReturn, "xsd:string"))
				{	soap_flag_getInterfaceVersionReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegationns__getInterfaceVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegationns__getInterfaceVersionResponse, 0, sizeof(struct delegationns__getInterfaceVersionResponse), 0, soap_copy_delegationns__getInterfaceVersionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getInterfaceVersionReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegationns__getInterfaceVersionResponse(struct soap *soap, const struct delegationns__getInterfaceVersionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegationns__getInterfaceVersionResponse);
	if (soap_out_delegationns__getInterfaceVersionResponse(soap, tag?tag:"delegationns:getInterfaceVersionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegationns__getInterfaceVersionResponse * SOAP_FMAC4 soap_get_delegationns__getInterfaceVersionResponse(struct soap *soap, struct delegationns__getInterfaceVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegationns__getInterfaceVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegationns__getInterfaceVersionResponse * SOAP_FMAC2 soap_instantiate_delegationns__getInterfaceVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegationns__getInterfaceVersionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegationns__getInterfaceVersionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__getInterfaceVersionResponse);
		if (size)
			*size = sizeof(struct delegationns__getInterfaceVersionResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__getInterfaceVersionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegationns__getInterfaceVersionResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegationns__getInterfaceVersionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegationns__getInterfaceVersionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegationns__getInterfaceVersionResponse %p -> %p\n", q, p));
	*(struct delegationns__getInterfaceVersionResponse*)p = *(struct delegationns__getInterfaceVersionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegationns__getVersion(struct soap *soap, struct delegationns__getVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegationns__getVersion(struct soap *soap, const struct delegationns__getVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegationns__getVersion(struct soap *soap, const char *tag, int id, const struct delegationns__getVersion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegationns__getVersion), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegationns__getVersion * SOAP_FMAC4 soap_in_delegationns__getVersion(struct soap *soap, const char *tag, struct delegationns__getVersion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegationns__getVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_delegationns__getVersion, sizeof(struct delegationns__getVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_delegationns__getVersion(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegationns__getVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegationns__getVersion, 0, sizeof(struct delegationns__getVersion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegationns__getVersion(struct soap *soap, const struct delegationns__getVersion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegationns__getVersion);
	if (soap_out_delegationns__getVersion(soap, tag?tag:"delegationns:getVersion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegationns__getVersion * SOAP_FMAC4 soap_get_delegationns__getVersion(struct soap *soap, struct delegationns__getVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegationns__getVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegationns__getVersion * SOAP_FMAC2 soap_instantiate_delegationns__getVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegationns__getVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegationns__getVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__getVersion);
		if (size)
			*size = sizeof(struct delegationns__getVersion);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__getVersion[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegationns__getVersion);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegationns__getVersion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegationns__getVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegationns__getVersion %p -> %p\n", q, p));
	*(struct delegationns__getVersion*)p = *(struct delegationns__getVersion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegationns__getVersionResponse(struct soap *soap, struct delegationns__getVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->getVersionReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegationns__getVersionResponse(struct soap *soap, const struct delegationns__getVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->getVersionReturn, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->getVersionReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegationns__getVersionResponse(struct soap *soap, const char *tag, int id, const struct delegationns__getVersionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegationns__getVersionResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "getVersionReturn", -1, &a->getVersionReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegationns__getVersionResponse * SOAP_FMAC4 soap_in_delegationns__getVersionResponse(struct soap *soap, const char *tag, struct delegationns__getVersionResponse *a, const char *type)
{
	size_t soap_flag_getVersionReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegationns__getVersionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_delegationns__getVersionResponse, sizeof(struct delegationns__getVersionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegationns__getVersionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getVersionReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "getVersionReturn", &a->getVersionReturn, "xsd:string"))
				{	soap_flag_getVersionReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegationns__getVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegationns__getVersionResponse, 0, sizeof(struct delegationns__getVersionResponse), 0, soap_copy_delegationns__getVersionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getVersionReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegationns__getVersionResponse(struct soap *soap, const struct delegationns__getVersionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegationns__getVersionResponse);
	if (soap_out_delegationns__getVersionResponse(soap, tag?tag:"delegationns:getVersionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegationns__getVersionResponse * SOAP_FMAC4 soap_get_delegationns__getVersionResponse(struct soap *soap, struct delegationns__getVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegationns__getVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegationns__getVersionResponse * SOAP_FMAC2 soap_instantiate_delegationns__getVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegationns__getVersionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegationns__getVersionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__getVersionResponse);
		if (size)
			*size = sizeof(struct delegationns__getVersionResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegationns__getVersionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegationns__getVersionResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegationns__getVersionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegationns__getVersionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegationns__getVersionResponse %p -> %p\n", q, p));
	*(struct delegationns__getVersionResponse*)p = *(struct delegationns__getVersionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation1__putProxy(struct soap *soap, struct delegation1__putProxy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_delegationID);
	soap_default_std__string(soap, &a->_proxy);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation1__putProxy(struct soap *soap, const struct delegation1__putProxy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_delegationID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_delegationID);
	soap_embedded(soap, &a->_proxy, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_proxy);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation1__putProxy(struct soap *soap, const char *tag, int id, const struct delegation1__putProxy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegation1__putProxy), type))
		return soap->error;
	if (soap_out_std__string(soap, "delegationID", -1, &a->_delegationID, ""))
		return soap->error;
	if (soap_out_std__string(soap, "proxy", -1, &a->_proxy, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation1__putProxy * SOAP_FMAC4 soap_in_delegation1__putProxy(struct soap *soap, const char *tag, struct delegation1__putProxy *a, const char *type)
{
	size_t soap_flag__delegationID = 1;
	size_t soap_flag__proxy = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation1__putProxy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_delegation1__putProxy, sizeof(struct delegation1__putProxy), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegation1__putProxy(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__delegationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_delegationID, "xsd:string"))
				{	soap_flag__delegationID--;
					continue;
				}
			if (soap_flag__proxy && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_proxy, "xsd:string"))
				{	soap_flag__proxy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation1__putProxy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegation1__putProxy, 0, sizeof(struct delegation1__putProxy), 0, soap_copy_delegation1__putProxy);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__delegationID > 0 || soap_flag__proxy > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation1__putProxy(struct soap *soap, const struct delegation1__putProxy *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegation1__putProxy);
	if (soap_out_delegation1__putProxy(soap, tag?tag:"delegation1:putProxy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation1__putProxy * SOAP_FMAC4 soap_get_delegation1__putProxy(struct soap *soap, struct delegation1__putProxy *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation1__putProxy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation1__putProxy * SOAP_FMAC2 soap_instantiate_delegation1__putProxy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation1__putProxy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegation1__putProxy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation1__putProxy);
		if (size)
			*size = sizeof(struct delegation1__putProxy);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation1__putProxy[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation1__putProxy);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation1__putProxy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation1__putProxy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation1__putProxy %p -> %p\n", q, p));
	*(struct delegation1__putProxy*)p = *(struct delegation1__putProxy*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation1__putProxyResponse(struct soap *soap, struct delegation1__putProxyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation1__putProxyResponse(struct soap *soap, const struct delegation1__putProxyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation1__putProxyResponse(struct soap *soap, const char *tag, int id, const struct delegation1__putProxyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegation1__putProxyResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation1__putProxyResponse * SOAP_FMAC4 soap_in_delegation1__putProxyResponse(struct soap *soap, const char *tag, struct delegation1__putProxyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation1__putProxyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_delegation1__putProxyResponse, sizeof(struct delegation1__putProxyResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_delegation1__putProxyResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation1__putProxyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegation1__putProxyResponse, 0, sizeof(struct delegation1__putProxyResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation1__putProxyResponse(struct soap *soap, const struct delegation1__putProxyResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegation1__putProxyResponse);
	if (soap_out_delegation1__putProxyResponse(soap, tag?tag:"delegation1:putProxyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation1__putProxyResponse * SOAP_FMAC4 soap_get_delegation1__putProxyResponse(struct soap *soap, struct delegation1__putProxyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation1__putProxyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation1__putProxyResponse * SOAP_FMAC2 soap_instantiate_delegation1__putProxyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation1__putProxyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegation1__putProxyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation1__putProxyResponse);
		if (size)
			*size = sizeof(struct delegation1__putProxyResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation1__putProxyResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation1__putProxyResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation1__putProxyResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation1__putProxyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation1__putProxyResponse %p -> %p\n", q, p));
	*(struct delegation1__putProxyResponse*)p = *(struct delegation1__putProxyResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation1__getProxyReq(struct soap *soap, struct delegation1__getProxyReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_delegationID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation1__getProxyReq(struct soap *soap, const struct delegation1__getProxyReq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_delegationID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_delegationID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation1__getProxyReq(struct soap *soap, const char *tag, int id, const struct delegation1__getProxyReq *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegation1__getProxyReq), type))
		return soap->error;
	if (soap_out_std__string(soap, "delegationID", -1, &a->_delegationID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation1__getProxyReq * SOAP_FMAC4 soap_in_delegation1__getProxyReq(struct soap *soap, const char *tag, struct delegation1__getProxyReq *a, const char *type)
{
	size_t soap_flag__delegationID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation1__getProxyReq *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_delegation1__getProxyReq, sizeof(struct delegation1__getProxyReq), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegation1__getProxyReq(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__delegationID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_delegationID, "xsd:string"))
				{	soap_flag__delegationID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation1__getProxyReq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegation1__getProxyReq, 0, sizeof(struct delegation1__getProxyReq), 0, soap_copy_delegation1__getProxyReq);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__delegationID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation1__getProxyReq(struct soap *soap, const struct delegation1__getProxyReq *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegation1__getProxyReq);
	if (soap_out_delegation1__getProxyReq(soap, tag?tag:"delegation1:getProxyReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation1__getProxyReq * SOAP_FMAC4 soap_get_delegation1__getProxyReq(struct soap *soap, struct delegation1__getProxyReq *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation1__getProxyReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation1__getProxyReq * SOAP_FMAC2 soap_instantiate_delegation1__getProxyReq(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation1__getProxyReq(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegation1__getProxyReq, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation1__getProxyReq);
		if (size)
			*size = sizeof(struct delegation1__getProxyReq);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation1__getProxyReq[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation1__getProxyReq);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation1__getProxyReq*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation1__getProxyReq(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation1__getProxyReq %p -> %p\n", q, p));
	*(struct delegation1__getProxyReq*)p = *(struct delegation1__getProxyReq*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_delegation1__getProxyReqResponse(struct soap *soap, struct delegation1__getProxyReqResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->_getProxyReqReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_delegation1__getProxyReqResponse(struct soap *soap, const struct delegation1__getProxyReqResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->_getProxyReqReturn, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->_getProxyReqReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_delegation1__getProxyReqResponse(struct soap *soap, const char *tag, int id, const struct delegation1__getProxyReqResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_delegation1__getProxyReqResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "getProxyReqReturn", -1, &a->_getProxyReqReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct delegation1__getProxyReqResponse * SOAP_FMAC4 soap_in_delegation1__getProxyReqResponse(struct soap *soap, const char *tag, struct delegation1__getProxyReqResponse *a, const char *type)
{
	size_t soap_flag__getProxyReqReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct delegation1__getProxyReqResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_delegation1__getProxyReqResponse, sizeof(struct delegation1__getProxyReqResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_delegation1__getProxyReqResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getProxyReqReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, NULL, &a->_getProxyReqReturn, "xsd:string"))
				{	soap_flag__getProxyReqReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct delegation1__getProxyReqResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_delegation1__getProxyReqResponse, 0, sizeof(struct delegation1__getProxyReqResponse), 0, soap_copy_delegation1__getProxyReqResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getProxyReqReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_delegation1__getProxyReqResponse(struct soap *soap, const struct delegation1__getProxyReqResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_delegation1__getProxyReqResponse);
	if (soap_out_delegation1__getProxyReqResponse(soap, tag?tag:"delegation1:getProxyReqResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct delegation1__getProxyReqResponse * SOAP_FMAC4 soap_get_delegation1__getProxyReqResponse(struct soap *soap, struct delegation1__getProxyReqResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_delegation1__getProxyReqResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct delegation1__getProxyReqResponse * SOAP_FMAC2 soap_instantiate_delegation1__getProxyReqResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_delegation1__getProxyReqResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_delegation1__getProxyReqResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct delegation1__getProxyReqResponse);
		if (size)
			*size = sizeof(struct delegation1__getProxyReqResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct delegation1__getProxyReqResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct delegation1__getProxyReqResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct delegation1__getProxyReqResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_delegation1__getProxyReqResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct delegation1__getProxyReqResponse %p -> %p\n", q, p));
	*(struct delegation1__getProxyReqResponse*)p = *(struct delegation1__getProxyReqResponse*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->delegation1__DelegationException = NULL;
	a->delegationns__DelegationException = NULL;
	a->ns1__AuthenticationFault = NULL;
	a->ns1__AuthorizationFault = NULL;
	a->ns1__GenericFault = NULL;
	a->ns1__GetQuotaManagementFault = NULL;
	a->ns1__InvalidArgumentFault = NULL;
	a->ns1__JobUnknownFault = NULL;
	a->ns1__NoSuitableResourcesFault = NULL;
	a->ns1__OperationNotAllowedFault = NULL;
	a->ns1__ServerOverloadedFault = NULL;
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTodelegation1__DelegationExceptionType(soap, &a->delegation1__DelegationException);
	soap_serialize_PointerTo_delegationns__DelegationException(soap, &a->delegationns__DelegationException);
	soap_serialize_PointerTons1__AuthenticationFaultType(soap, &a->ns1__AuthenticationFault);
	soap_serialize_PointerTons1__AuthorizationFaultType(soap, &a->ns1__AuthorizationFault);
	soap_serialize_PointerTons1__GenericFaultType(soap, &a->ns1__GenericFault);
	soap_serialize_PointerTons1__GetQuotaManagementFaultType(soap, &a->ns1__GetQuotaManagementFault);
	soap_serialize_PointerTons1__InvalidArgumentFaultType(soap, &a->ns1__InvalidArgumentFault);
	soap_serialize_PointerTons1__JobUnknownFaultType(soap, &a->ns1__JobUnknownFault);
	soap_serialize_PointerTons1__NoSuitableResourcesFaultType(soap, &a->ns1__NoSuitableResourcesFault);
	soap_serialize_PointerTons1__OperationNotAllowedFaultType(soap, &a->ns1__OperationNotAllowedFault);
	soap_serialize_PointerTons1__ServerOverloadedFaultType(soap, &a->ns1__ServerOverloadedFault);
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_out_PointerTodelegation1__DelegationExceptionType(soap, "delegation1:DelegationException", -1, &a->delegation1__DelegationException, ""))
		return soap->error;
	if (soap_out_PointerTo_delegationns__DelegationException(soap, "delegationns:DelegationException", -1, &a->delegationns__DelegationException, ""))
		return soap->error;
	if (soap_out_PointerTons1__AuthenticationFaultType(soap, "ns1:AuthenticationFault", -1, &a->ns1__AuthenticationFault, ""))
		return soap->error;
	if (soap_out_PointerTons1__AuthorizationFaultType(soap, "ns1:AuthorizationFault", -1, &a->ns1__AuthorizationFault, ""))
		return soap->error;
	if (soap_out_PointerTons1__GenericFaultType(soap, "ns1:GenericFault", -1, &a->ns1__GenericFault, ""))
		return soap->error;
	if (soap_out_PointerTons1__GetQuotaManagementFaultType(soap, "ns1:GetQuotaManagementFault", -1, &a->ns1__GetQuotaManagementFault, ""))
		return soap->error;
	if (soap_out_PointerTons1__InvalidArgumentFaultType(soap, "ns1:InvalidArgumentFault", -1, &a->ns1__InvalidArgumentFault, ""))
		return soap->error;
	if (soap_out_PointerTons1__JobUnknownFaultType(soap, "ns1:JobUnknownFault", -1, &a->ns1__JobUnknownFault, ""))
		return soap->error;
	if (soap_out_PointerTons1__NoSuitableResourcesFaultType(soap, "ns1:NoSuitableResourcesFault", -1, &a->ns1__NoSuitableResourcesFault, ""))
		return soap->error;
	if (soap_out_PointerTons1__OperationNotAllowedFaultType(soap, "ns1:OperationNotAllowedFault", -1, &a->ns1__OperationNotAllowedFault, ""))
		return soap->error;
	if (soap_out_PointerTons1__ServerOverloadedFaultType(soap, "ns1:ServerOverloadedFault", -1, &a->ns1__ServerOverloadedFault, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_delegation1__DelegationException = 1;
	size_t soap_flag_delegationns__DelegationException = 1;
	size_t soap_flag_ns1__AuthenticationFault = 1;
	size_t soap_flag_ns1__AuthorizationFault = 1;
	size_t soap_flag_ns1__GenericFault = 1;
	size_t soap_flag_ns1__GetQuotaManagementFault = 1;
	size_t soap_flag_ns1__InvalidArgumentFault = 1;
	size_t soap_flag_ns1__JobUnknownFault = 1;
	size_t soap_flag_ns1__NoSuitableResourcesFault = 1;
	size_t soap_flag_ns1__OperationNotAllowedFault = 1;
	size_t soap_flag_ns1__ServerOverloadedFault = 1;
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_delegation1__DelegationException && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodelegation1__DelegationExceptionType(soap, "delegation1:DelegationException", &a->delegation1__DelegationException, "delegation1:DelegationExceptionType"))
				{	soap_flag_delegation1__DelegationException--;
					continue;
				}
			if (soap_flag_delegationns__DelegationException && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_delegationns__DelegationException(soap, "delegationns:DelegationException", &a->delegationns__DelegationException, ""))
				{	soap_flag_delegationns__DelegationException--;
					continue;
				}
			if (soap_flag_ns1__AuthenticationFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AuthenticationFaultType(soap, "ns1:AuthenticationFault", &a->ns1__AuthenticationFault, "ns1:AuthenticationFaultType"))
				{	soap_flag_ns1__AuthenticationFault--;
					continue;
				}
			if (soap_flag_ns1__AuthorizationFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AuthorizationFaultType(soap, "ns1:AuthorizationFault", &a->ns1__AuthorizationFault, "ns1:AuthorizationFaultType"))
				{	soap_flag_ns1__AuthorizationFault--;
					continue;
				}
			if (soap_flag_ns1__GenericFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__GenericFaultType(soap, "ns1:GenericFault", &a->ns1__GenericFault, "ns1:GenericFaultType"))
				{	soap_flag_ns1__GenericFault--;
					continue;
				}
			if (soap_flag_ns1__GetQuotaManagementFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__GetQuotaManagementFaultType(soap, "ns1:GetQuotaManagementFault", &a->ns1__GetQuotaManagementFault, "ns1:GetQuotaManagementFaultType"))
				{	soap_flag_ns1__GetQuotaManagementFault--;
					continue;
				}
			if (soap_flag_ns1__InvalidArgumentFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__InvalidArgumentFaultType(soap, "ns1:InvalidArgumentFault", &a->ns1__InvalidArgumentFault, "ns1:InvalidArgumentFaultType"))
				{	soap_flag_ns1__InvalidArgumentFault--;
					continue;
				}
			if (soap_flag_ns1__JobUnknownFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__JobUnknownFaultType(soap, "ns1:JobUnknownFault", &a->ns1__JobUnknownFault, "ns1:JobUnknownFaultType"))
				{	soap_flag_ns1__JobUnknownFault--;
					continue;
				}
			if (soap_flag_ns1__NoSuitableResourcesFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__NoSuitableResourcesFaultType(soap, "ns1:NoSuitableResourcesFault", &a->ns1__NoSuitableResourcesFault, "ns1:NoSuitableResourcesFaultType"))
				{	soap_flag_ns1__NoSuitableResourcesFault--;
					continue;
				}
			if (soap_flag_ns1__OperationNotAllowedFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__OperationNotAllowedFaultType(soap, "ns1:OperationNotAllowedFault", &a->ns1__OperationNotAllowedFault, "ns1:OperationNotAllowedFaultType"))
				{	soap_flag_ns1__OperationNotAllowedFault--;
					continue;
				}
			if (soap_flag_ns1__ServerOverloadedFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ServerOverloadedFaultType(soap, "ns1:ServerOverloadedFault", &a->ns1__ServerOverloadedFault, "ns1:ServerOverloadedFaultType"))
				{	soap_flag_ns1__ServerOverloadedFault--;
					continue;
				}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fault > 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ProxyInfoStructType(struct soap *soap, ns1__ProxyInfoStructType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ProxyInfoStructType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ProxyInfoStructType(struct soap *soap, const char *tag, int id, ns1__ProxyInfoStructType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ProxyInfoStructType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ProxyInfoStructType ** SOAP_FMAC4 soap_in_PointerTons1__ProxyInfoStructType(struct soap *soap, const char *tag, ns1__ProxyInfoStructType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ProxyInfoStructType **)soap_malloc(soap, sizeof(ns1__ProxyInfoStructType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ProxyInfoStructType *)soap_instantiate_ns1__ProxyInfoStructType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ProxyInfoStructType ** p = (ns1__ProxyInfoStructType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ProxyInfoStructType, sizeof(ns1__ProxyInfoStructType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ProxyInfoStructType(struct soap *soap, ns1__ProxyInfoStructType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ProxyInfoStructType);
	if (soap_out_PointerTons1__ProxyInfoStructType(soap, tag?tag:"ns1:ProxyInfoStructType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ProxyInfoStructType ** SOAP_FMAC4 soap_get_PointerTons1__ProxyInfoStructType(struct soap *soap, ns1__ProxyInfoStructType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ProxyInfoStructType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__JobTypeList(struct soap *soap, ns1__JobTypeList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__JobTypeList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__JobTypeList(struct soap *soap, const char *tag, int id, ns1__JobTypeList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__JobTypeList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__JobTypeList ** SOAP_FMAC4 soap_in_PointerTons1__JobTypeList(struct soap *soap, const char *tag, ns1__JobTypeList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__JobTypeList **)soap_malloc(soap, sizeof(ns1__JobTypeList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__JobTypeList *)soap_instantiate_ns1__JobTypeList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__JobTypeList ** p = (ns1__JobTypeList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__JobTypeList, sizeof(ns1__JobTypeList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__JobTypeList(struct soap *soap, ns1__JobTypeList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__JobTypeList);
	if (soap_out_PointerTons1__JobTypeList(soap, tag?tag:"ns1:JobTypeList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__JobTypeList ** SOAP_FMAC4 soap_get_PointerTons1__JobTypeList(struct soap *soap, ns1__JobTypeList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__JobTypeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__StringAndLongList(struct soap *soap, ns1__StringAndLongList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__StringAndLongList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__StringAndLongList(struct soap *soap, const char *tag, int id, ns1__StringAndLongList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__StringAndLongList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__StringAndLongList ** SOAP_FMAC4 soap_in_PointerTons1__StringAndLongList(struct soap *soap, const char *tag, ns1__StringAndLongList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__StringAndLongList **)soap_malloc(soap, sizeof(ns1__StringAndLongList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__StringAndLongList *)soap_instantiate_ns1__StringAndLongList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__StringAndLongList ** p = (ns1__StringAndLongList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__StringAndLongList, sizeof(ns1__StringAndLongList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__StringAndLongList(struct soap *soap, ns1__StringAndLongList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__StringAndLongList);
	if (soap_out_PointerTons1__StringAndLongList(soap, tag?tag:"ns1:StringAndLongList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__StringAndLongList ** SOAP_FMAC4 soap_get_PointerTons1__StringAndLongList(struct soap *soap, ns1__StringAndLongList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__StringAndLongList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DestURIsStructType(struct soap *soap, ns1__DestURIsStructType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DestURIsStructType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DestURIsStructType(struct soap *soap, const char *tag, int id, ns1__DestURIsStructType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DestURIsStructType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__DestURIsStructType ** SOAP_FMAC4 soap_in_PointerTons1__DestURIsStructType(struct soap *soap, const char *tag, ns1__DestURIsStructType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DestURIsStructType **)soap_malloc(soap, sizeof(ns1__DestURIsStructType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DestURIsStructType *)soap_instantiate_ns1__DestURIsStructType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__DestURIsStructType ** p = (ns1__DestURIsStructType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DestURIsStructType, sizeof(ns1__DestURIsStructType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DestURIsStructType(struct soap *soap, ns1__DestURIsStructType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__DestURIsStructType);
	if (soap_out_PointerTons1__DestURIsStructType(soap, tag?tag:"ns1:DestURIsStructType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DestURIsStructType ** SOAP_FMAC4 soap_get_PointerTons1__DestURIsStructType(struct soap *soap, ns1__DestURIsStructType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DestURIsStructType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__StringList(struct soap *soap, ns1__StringList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__StringList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__StringList(struct soap *soap, const char *tag, int id, ns1__StringList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__StringList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__StringList ** SOAP_FMAC4 soap_in_PointerTons1__StringList(struct soap *soap, const char *tag, ns1__StringList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__StringList **)soap_malloc(soap, sizeof(ns1__StringList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__StringList *)soap_instantiate_ns1__StringList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__StringList ** p = (ns1__StringList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__StringList, sizeof(ns1__StringList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__StringList(struct soap *soap, ns1__StringList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__StringList);
	if (soap_out_PointerTons1__StringList(soap, tag?tag:"ns1:StringList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__StringList ** SOAP_FMAC4 soap_get_PointerTons1__StringList(struct soap *soap, ns1__StringList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__StringList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__JobDefinition_USCOREType(struct soap *soap, jsdl__JobDefinition_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__JobDefinition_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__JobDefinition_USCOREType(struct soap *soap, const char *tag, int id, jsdl__JobDefinition_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__JobDefinition_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__JobDefinition_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__JobDefinition_USCOREType(struct soap *soap, const char *tag, jsdl__JobDefinition_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__JobDefinition_USCOREType **)soap_malloc(soap, sizeof(jsdl__JobDefinition_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__JobDefinition_USCOREType *)soap_instantiate_jsdl__JobDefinition_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__JobDefinition_USCOREType ** p = (jsdl__JobDefinition_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__JobDefinition_USCOREType, sizeof(jsdl__JobDefinition_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__JobDefinition_USCOREType(struct soap *soap, jsdl__JobDefinition_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__JobDefinition_USCOREType);
	if (soap_out_PointerTojsdl__JobDefinition_USCOREType(soap, tag?tag:"jsdl:JobDefinition_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 jsdl__JobDefinition_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__JobDefinition_USCOREType(struct soap *soap, jsdl__JobDefinition_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__JobDefinition_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodelegationns__NewProxyReq(struct soap *soap, delegationns__NewProxyReq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_delegationns__NewProxyReq))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodelegationns__NewProxyReq(struct soap *soap, const char *tag, int id, delegationns__NewProxyReq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_delegationns__NewProxyReq);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 delegationns__NewProxyReq ** SOAP_FMAC4 soap_in_PointerTodelegationns__NewProxyReq(struct soap *soap, const char *tag, delegationns__NewProxyReq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (delegationns__NewProxyReq **)soap_malloc(soap, sizeof(delegationns__NewProxyReq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (delegationns__NewProxyReq *)soap_instantiate_delegationns__NewProxyReq(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	delegationns__NewProxyReq ** p = (delegationns__NewProxyReq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_delegationns__NewProxyReq, sizeof(delegationns__NewProxyReq), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodelegationns__NewProxyReq(struct soap *soap, delegationns__NewProxyReq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodelegationns__NewProxyReq);
	if (soap_out_PointerTodelegationns__NewProxyReq(soap, tag?tag:"delegationns:NewProxyReq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 delegationns__NewProxyReq ** SOAP_FMAC4 soap_get_PointerTodelegationns__NewProxyReq(struct soap *soap, delegationns__NewProxyReq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodelegationns__NewProxyReq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ServerOverloadedFaultType(struct soap *soap, ns1__ServerOverloadedFaultType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ServerOverloadedFaultType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ServerOverloadedFaultType(struct soap *soap, const char *tag, int id, ns1__ServerOverloadedFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ServerOverloadedFaultType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ServerOverloadedFaultType ** SOAP_FMAC4 soap_in_PointerTons1__ServerOverloadedFaultType(struct soap *soap, const char *tag, ns1__ServerOverloadedFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ServerOverloadedFaultType **)soap_malloc(soap, sizeof(ns1__ServerOverloadedFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ServerOverloadedFaultType *)soap_instantiate_ns1__ServerOverloadedFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ServerOverloadedFaultType ** p = (ns1__ServerOverloadedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ServerOverloadedFaultType, sizeof(ns1__ServerOverloadedFaultType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ServerOverloadedFaultType(struct soap *soap, ns1__ServerOverloadedFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ServerOverloadedFaultType);
	if (soap_out_PointerTons1__ServerOverloadedFaultType(soap, tag?tag:"ns1:ServerOverloadedFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ServerOverloadedFaultType ** SOAP_FMAC4 soap_get_PointerTons1__ServerOverloadedFaultType(struct soap *soap, ns1__ServerOverloadedFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ServerOverloadedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__OperationNotAllowedFaultType(struct soap *soap, ns1__OperationNotAllowedFaultType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__OperationNotAllowedFaultType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__OperationNotAllowedFaultType(struct soap *soap, const char *tag, int id, ns1__OperationNotAllowedFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__OperationNotAllowedFaultType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__OperationNotAllowedFaultType ** SOAP_FMAC4 soap_in_PointerTons1__OperationNotAllowedFaultType(struct soap *soap, const char *tag, ns1__OperationNotAllowedFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__OperationNotAllowedFaultType **)soap_malloc(soap, sizeof(ns1__OperationNotAllowedFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__OperationNotAllowedFaultType *)soap_instantiate_ns1__OperationNotAllowedFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__OperationNotAllowedFaultType ** p = (ns1__OperationNotAllowedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__OperationNotAllowedFaultType, sizeof(ns1__OperationNotAllowedFaultType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__OperationNotAllowedFaultType(struct soap *soap, ns1__OperationNotAllowedFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__OperationNotAllowedFaultType);
	if (soap_out_PointerTons1__OperationNotAllowedFaultType(soap, tag?tag:"ns1:OperationNotAllowedFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__OperationNotAllowedFaultType ** SOAP_FMAC4 soap_get_PointerTons1__OperationNotAllowedFaultType(struct soap *soap, ns1__OperationNotAllowedFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__OperationNotAllowedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__NoSuitableResourcesFaultType(struct soap *soap, ns1__NoSuitableResourcesFaultType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__NoSuitableResourcesFaultType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__NoSuitableResourcesFaultType(struct soap *soap, const char *tag, int id, ns1__NoSuitableResourcesFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__NoSuitableResourcesFaultType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__NoSuitableResourcesFaultType ** SOAP_FMAC4 soap_in_PointerTons1__NoSuitableResourcesFaultType(struct soap *soap, const char *tag, ns1__NoSuitableResourcesFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__NoSuitableResourcesFaultType **)soap_malloc(soap, sizeof(ns1__NoSuitableResourcesFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__NoSuitableResourcesFaultType *)soap_instantiate_ns1__NoSuitableResourcesFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__NoSuitableResourcesFaultType ** p = (ns1__NoSuitableResourcesFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__NoSuitableResourcesFaultType, sizeof(ns1__NoSuitableResourcesFaultType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__NoSuitableResourcesFaultType(struct soap *soap, ns1__NoSuitableResourcesFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__NoSuitableResourcesFaultType);
	if (soap_out_PointerTons1__NoSuitableResourcesFaultType(soap, tag?tag:"ns1:NoSuitableResourcesFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__NoSuitableResourcesFaultType ** SOAP_FMAC4 soap_get_PointerTons1__NoSuitableResourcesFaultType(struct soap *soap, ns1__NoSuitableResourcesFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__NoSuitableResourcesFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__JobUnknownFaultType(struct soap *soap, ns1__JobUnknownFaultType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__JobUnknownFaultType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__JobUnknownFaultType(struct soap *soap, const char *tag, int id, ns1__JobUnknownFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__JobUnknownFaultType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__JobUnknownFaultType ** SOAP_FMAC4 soap_in_PointerTons1__JobUnknownFaultType(struct soap *soap, const char *tag, ns1__JobUnknownFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__JobUnknownFaultType **)soap_malloc(soap, sizeof(ns1__JobUnknownFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__JobUnknownFaultType *)soap_instantiate_ns1__JobUnknownFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__JobUnknownFaultType ** p = (ns1__JobUnknownFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__JobUnknownFaultType, sizeof(ns1__JobUnknownFaultType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__JobUnknownFaultType(struct soap *soap, ns1__JobUnknownFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__JobUnknownFaultType);
	if (soap_out_PointerTons1__JobUnknownFaultType(soap, tag?tag:"ns1:JobUnknownFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__JobUnknownFaultType ** SOAP_FMAC4 soap_get_PointerTons1__JobUnknownFaultType(struct soap *soap, ns1__JobUnknownFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__JobUnknownFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__InvalidArgumentFaultType(struct soap *soap, ns1__InvalidArgumentFaultType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__InvalidArgumentFaultType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__InvalidArgumentFaultType(struct soap *soap, const char *tag, int id, ns1__InvalidArgumentFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__InvalidArgumentFaultType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__InvalidArgumentFaultType ** SOAP_FMAC4 soap_in_PointerTons1__InvalidArgumentFaultType(struct soap *soap, const char *tag, ns1__InvalidArgumentFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__InvalidArgumentFaultType **)soap_malloc(soap, sizeof(ns1__InvalidArgumentFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__InvalidArgumentFaultType *)soap_instantiate_ns1__InvalidArgumentFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__InvalidArgumentFaultType ** p = (ns1__InvalidArgumentFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__InvalidArgumentFaultType, sizeof(ns1__InvalidArgumentFaultType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__InvalidArgumentFaultType(struct soap *soap, ns1__InvalidArgumentFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__InvalidArgumentFaultType);
	if (soap_out_PointerTons1__InvalidArgumentFaultType(soap, tag?tag:"ns1:InvalidArgumentFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__InvalidArgumentFaultType ** SOAP_FMAC4 soap_get_PointerTons1__InvalidArgumentFaultType(struct soap *soap, ns1__InvalidArgumentFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__InvalidArgumentFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GetQuotaManagementFaultType(struct soap *soap, ns1__GetQuotaManagementFaultType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GetQuotaManagementFaultType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GetQuotaManagementFaultType(struct soap *soap, const char *tag, int id, ns1__GetQuotaManagementFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GetQuotaManagementFaultType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__GetQuotaManagementFaultType ** SOAP_FMAC4 soap_in_PointerTons1__GetQuotaManagementFaultType(struct soap *soap, const char *tag, ns1__GetQuotaManagementFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GetQuotaManagementFaultType **)soap_malloc(soap, sizeof(ns1__GetQuotaManagementFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GetQuotaManagementFaultType *)soap_instantiate_ns1__GetQuotaManagementFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__GetQuotaManagementFaultType ** p = (ns1__GetQuotaManagementFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GetQuotaManagementFaultType, sizeof(ns1__GetQuotaManagementFaultType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GetQuotaManagementFaultType(struct soap *soap, ns1__GetQuotaManagementFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__GetQuotaManagementFaultType);
	if (soap_out_PointerTons1__GetQuotaManagementFaultType(soap, tag?tag:"ns1:GetQuotaManagementFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__GetQuotaManagementFaultType ** SOAP_FMAC4 soap_get_PointerTons1__GetQuotaManagementFaultType(struct soap *soap, ns1__GetQuotaManagementFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GetQuotaManagementFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GenericFaultType(struct soap *soap, ns1__GenericFaultType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GenericFaultType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GenericFaultType(struct soap *soap, const char *tag, int id, ns1__GenericFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GenericFaultType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__GenericFaultType ** SOAP_FMAC4 soap_in_PointerTons1__GenericFaultType(struct soap *soap, const char *tag, ns1__GenericFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GenericFaultType **)soap_malloc(soap, sizeof(ns1__GenericFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GenericFaultType *)soap_instantiate_ns1__GenericFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__GenericFaultType ** p = (ns1__GenericFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GenericFaultType, sizeof(ns1__GenericFaultType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GenericFaultType(struct soap *soap, ns1__GenericFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__GenericFaultType);
	if (soap_out_PointerTons1__GenericFaultType(soap, tag?tag:"ns1:GenericFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__GenericFaultType ** SOAP_FMAC4 soap_get_PointerTons1__GenericFaultType(struct soap *soap, ns1__GenericFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GenericFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AuthorizationFaultType(struct soap *soap, ns1__AuthorizationFaultType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AuthorizationFaultType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AuthorizationFaultType(struct soap *soap, const char *tag, int id, ns1__AuthorizationFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AuthorizationFaultType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__AuthorizationFaultType ** SOAP_FMAC4 soap_in_PointerTons1__AuthorizationFaultType(struct soap *soap, const char *tag, ns1__AuthorizationFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AuthorizationFaultType **)soap_malloc(soap, sizeof(ns1__AuthorizationFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AuthorizationFaultType *)soap_instantiate_ns1__AuthorizationFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__AuthorizationFaultType ** p = (ns1__AuthorizationFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AuthorizationFaultType, sizeof(ns1__AuthorizationFaultType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AuthorizationFaultType(struct soap *soap, ns1__AuthorizationFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AuthorizationFaultType);
	if (soap_out_PointerTons1__AuthorizationFaultType(soap, tag?tag:"ns1:AuthorizationFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__AuthorizationFaultType ** SOAP_FMAC4 soap_get_PointerTons1__AuthorizationFaultType(struct soap *soap, ns1__AuthorizationFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AuthorizationFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AuthenticationFaultType(struct soap *soap, ns1__AuthenticationFaultType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AuthenticationFaultType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AuthenticationFaultType(struct soap *soap, const char *tag, int id, ns1__AuthenticationFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AuthenticationFaultType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__AuthenticationFaultType ** SOAP_FMAC4 soap_in_PointerTons1__AuthenticationFaultType(struct soap *soap, const char *tag, ns1__AuthenticationFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AuthenticationFaultType **)soap_malloc(soap, sizeof(ns1__AuthenticationFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AuthenticationFaultType *)soap_instantiate_ns1__AuthenticationFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__AuthenticationFaultType ** p = (ns1__AuthenticationFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AuthenticationFaultType, sizeof(ns1__AuthenticationFaultType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AuthenticationFaultType(struct soap *soap, ns1__AuthenticationFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AuthenticationFaultType);
	if (soap_out_PointerTons1__AuthenticationFaultType(soap, tag?tag:"ns1:AuthenticationFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__AuthenticationFaultType ** SOAP_FMAC4 soap_get_PointerTons1__AuthenticationFaultType(struct soap *soap, ns1__AuthenticationFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AuthenticationFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_delegationns__DelegationException(struct soap *soap, _delegationns__DelegationException *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__delegationns__DelegationException))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_delegationns__DelegationException(struct soap *soap, const char *tag, int id, _delegationns__DelegationException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__delegationns__DelegationException);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _delegationns__DelegationException ** SOAP_FMAC4 soap_in_PointerTo_delegationns__DelegationException(struct soap *soap, const char *tag, _delegationns__DelegationException **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_delegationns__DelegationException **)soap_malloc(soap, sizeof(_delegationns__DelegationException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_delegationns__DelegationException *)soap_instantiate__delegationns__DelegationException(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_delegationns__DelegationException ** p = (_delegationns__DelegationException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__delegationns__DelegationException, sizeof(_delegationns__DelegationException), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_delegationns__DelegationException(struct soap *soap, _delegationns__DelegationException *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_delegationns__DelegationException);
	if (soap_out_PointerTo_delegationns__DelegationException(soap, tag?tag:"delegationns:DelegationException", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _delegationns__DelegationException ** SOAP_FMAC4 soap_get_PointerTo_delegationns__DelegationException(struct soap *soap, _delegationns__DelegationException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_delegationns__DelegationException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodelegation1__DelegationExceptionType(struct soap *soap, delegation1__DelegationExceptionType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_delegation1__DelegationExceptionType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodelegation1__DelegationExceptionType(struct soap *soap, const char *tag, int id, delegation1__DelegationExceptionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_delegation1__DelegationExceptionType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 delegation1__DelegationExceptionType ** SOAP_FMAC4 soap_in_PointerTodelegation1__DelegationExceptionType(struct soap *soap, const char *tag, delegation1__DelegationExceptionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (delegation1__DelegationExceptionType **)soap_malloc(soap, sizeof(delegation1__DelegationExceptionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (delegation1__DelegationExceptionType *)soap_instantiate_delegation1__DelegationExceptionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	delegation1__DelegationExceptionType ** p = (delegation1__DelegationExceptionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_delegation1__DelegationExceptionType, sizeof(delegation1__DelegationExceptionType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodelegation1__DelegationExceptionType(struct soap *soap, delegation1__DelegationExceptionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodelegation1__DelegationExceptionType);
	if (soap_out_PointerTodelegation1__DelegationExceptionType(soap, tag?tag:"delegation1:DelegationExceptionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 delegation1__DelegationExceptionType ** SOAP_FMAC4 soap_get_PointerTodelegation1__DelegationExceptionType(struct soap *soap, delegation1__DelegationExceptionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodelegation1__DelegationExceptionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodouble(struct soap *soap, double *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_double);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodouble(struct soap *soap, const char *tag, int id, double *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_double);
	if (id < 0)
		return soap->error;
	return soap_out_double(soap, tag, id, *a, type);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_in_PointerTodouble(struct soap *soap, const char *tag, double **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (double **)soap_malloc(soap, sizeof(double *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_double(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (double **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_double, sizeof(double), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodouble(struct soap *soap, double *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodouble);
	if (soap_out_PointerTodouble(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_get_PointerTodouble(struct soap *soap, double **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodouble(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdlposix__GroupName_USCOREType(struct soap *soap, jsdlposix__GroupName_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdlposix__GroupName_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdlposix__GroupName_USCOREType(struct soap *soap, const char *tag, int id, jsdlposix__GroupName_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdlposix__GroupName_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdlposix__GroupName_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdlposix__GroupName_USCOREType(struct soap *soap, const char *tag, jsdlposix__GroupName_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdlposix__GroupName_USCOREType **)soap_malloc(soap, sizeof(jsdlposix__GroupName_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdlposix__GroupName_USCOREType *)soap_instantiate_jsdlposix__GroupName_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdlposix__GroupName_USCOREType ** p = (jsdlposix__GroupName_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdlposix__GroupName_USCOREType, sizeof(jsdlposix__GroupName_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdlposix__GroupName_USCOREType(struct soap *soap, jsdlposix__GroupName_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdlposix__GroupName_USCOREType);
	if (soap_out_PointerTojsdlposix__GroupName_USCOREType(soap, tag?tag:"jsdlposix:GroupName_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 jsdlposix__GroupName_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdlposix__GroupName_USCOREType(struct soap *soap, jsdlposix__GroupName_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdlposix__GroupName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdlposix__UserName_USCOREType(struct soap *soap, jsdlposix__UserName_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdlposix__UserName_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdlposix__UserName_USCOREType(struct soap *soap, const char *tag, int id, jsdlposix__UserName_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdlposix__UserName_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdlposix__UserName_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdlposix__UserName_USCOREType(struct soap *soap, const char *tag, jsdlposix__UserName_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdlposix__UserName_USCOREType **)soap_malloc(soap, sizeof(jsdlposix__UserName_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdlposix__UserName_USCOREType *)soap_instantiate_jsdlposix__UserName_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdlposix__UserName_USCOREType ** p = (jsdlposix__UserName_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdlposix__UserName_USCOREType, sizeof(jsdlposix__UserName_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdlposix__UserName_USCOREType(struct soap *soap, jsdlposix__UserName_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdlposix__UserName_USCOREType);
	if (soap_out_PointerTojsdlposix__UserName_USCOREType(soap, tag?tag:"jsdlposix:UserName_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 jsdlposix__UserName_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdlposix__UserName_USCOREType(struct soap *soap, jsdlposix__UserName_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdlposix__UserName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdlposix__Limits_USCOREType(struct soap *soap, jsdlposix__Limits_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdlposix__Limits_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdlposix__Limits_USCOREType(struct soap *soap, const char *tag, int id, jsdlposix__Limits_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdlposix__Limits_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdlposix__Limits_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdlposix__Limits_USCOREType(struct soap *soap, const char *tag, jsdlposix__Limits_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdlposix__Limits_USCOREType **)soap_malloc(soap, sizeof(jsdlposix__Limits_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdlposix__Limits_USCOREType *)soap_instantiate_jsdlposix__Limits_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdlposix__Limits_USCOREType ** p = (jsdlposix__Limits_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdlposix__Limits_USCOREType, sizeof(jsdlposix__Limits_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdlposix__Limits_USCOREType(struct soap *soap, jsdlposix__Limits_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdlposix__Limits_USCOREType);
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, tag?tag:"jsdlposix:Limits_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 jsdlposix__Limits_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdlposix__Limits_USCOREType(struct soap *soap, jsdlposix__Limits_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdlposix__Limits_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdlposix__Environment_USCOREType(struct soap *soap, jsdlposix__Environment_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdlposix__Environment_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdlposix__Environment_USCOREType(struct soap *soap, const char *tag, int id, jsdlposix__Environment_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdlposix__Environment_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdlposix__Environment_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdlposix__Environment_USCOREType(struct soap *soap, const char *tag, jsdlposix__Environment_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdlposix__Environment_USCOREType **)soap_malloc(soap, sizeof(jsdlposix__Environment_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdlposix__Environment_USCOREType *)soap_instantiate_jsdlposix__Environment_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdlposix__Environment_USCOREType ** p = (jsdlposix__Environment_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdlposix__Environment_USCOREType, sizeof(jsdlposix__Environment_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdlposix__Environment_USCOREType(struct soap *soap, jsdlposix__Environment_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdlposix__Environment_USCOREType);
	if (soap_out_PointerTojsdlposix__Environment_USCOREType(soap, tag?tag:"jsdlposix:Environment_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 jsdlposix__Environment_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdlposix__Environment_USCOREType(struct soap *soap, jsdlposix__Environment_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdlposix__Environment_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdlposix__DirectoryName_USCOREType(struct soap *soap, jsdlposix__DirectoryName_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdlposix__DirectoryName_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdlposix__DirectoryName_USCOREType(struct soap *soap, const char *tag, int id, jsdlposix__DirectoryName_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdlposix__DirectoryName_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdlposix__DirectoryName_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdlposix__DirectoryName_USCOREType(struct soap *soap, const char *tag, jsdlposix__DirectoryName_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdlposix__DirectoryName_USCOREType **)soap_malloc(soap, sizeof(jsdlposix__DirectoryName_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdlposix__DirectoryName_USCOREType *)soap_instantiate_jsdlposix__DirectoryName_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdlposix__DirectoryName_USCOREType ** p = (jsdlposix__DirectoryName_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdlposix__DirectoryName_USCOREType, sizeof(jsdlposix__DirectoryName_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdlposix__DirectoryName_USCOREType(struct soap *soap, jsdlposix__DirectoryName_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdlposix__DirectoryName_USCOREType);
	if (soap_out_PointerTojsdlposix__DirectoryName_USCOREType(soap, tag?tag:"jsdlposix:DirectoryName_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 jsdlposix__DirectoryName_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdlposix__DirectoryName_USCOREType(struct soap *soap, jsdlposix__DirectoryName_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdlposix__DirectoryName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdlposix__Argument_USCOREType(struct soap *soap, jsdlposix__Argument_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdlposix__Argument_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdlposix__Argument_USCOREType(struct soap *soap, const char *tag, int id, jsdlposix__Argument_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdlposix__Argument_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdlposix__Argument_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdlposix__Argument_USCOREType(struct soap *soap, const char *tag, jsdlposix__Argument_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdlposix__Argument_USCOREType **)soap_malloc(soap, sizeof(jsdlposix__Argument_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdlposix__Argument_USCOREType *)soap_instantiate_jsdlposix__Argument_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdlposix__Argument_USCOREType ** p = (jsdlposix__Argument_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdlposix__Argument_USCOREType, sizeof(jsdlposix__Argument_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdlposix__Argument_USCOREType(struct soap *soap, jsdlposix__Argument_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdlposix__Argument_USCOREType);
	if (soap_out_PointerTojsdlposix__Argument_USCOREType(soap, tag?tag:"jsdlposix:Argument_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 jsdlposix__Argument_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdlposix__Argument_USCOREType(struct soap *soap, jsdlposix__Argument_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdlposix__Argument_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdlposix__FileName_USCOREType(struct soap *soap, jsdlposix__FileName_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdlposix__FileName_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdlposix__FileName_USCOREType(struct soap *soap, const char *tag, int id, jsdlposix__FileName_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdlposix__FileName_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdlposix__FileName_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdlposix__FileName_USCOREType(struct soap *soap, const char *tag, jsdlposix__FileName_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdlposix__FileName_USCOREType **)soap_malloc(soap, sizeof(jsdlposix__FileName_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdlposix__FileName_USCOREType *)soap_instantiate_jsdlposix__FileName_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdlposix__FileName_USCOREType ** p = (jsdlposix__FileName_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdlposix__FileName_USCOREType, sizeof(jsdlposix__FileName_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdlposix__FileName_USCOREType(struct soap *soap, jsdlposix__FileName_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdlposix__FileName_USCOREType);
	if (soap_out_PointerTojsdlposix__FileName_USCOREType(soap, tag?tag:"jsdlposix:FileName_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 jsdlposix__FileName_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdlposix__FileName_USCOREType(struct soap *soap, jsdlposix__FileName_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdlposix__FileName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyURI(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI))
		soap_serialize_xsd__anyURI(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyURI(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyURI);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__anyURI(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__anyURI(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyURI, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyURI(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__anyURI);
	if (soap_out_PointerToxsd__anyURI(soap, tag?tag:"xsd:anyURI", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__anyURI(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__SourceTarget_USCOREType(struct soap *soap, jsdl__SourceTarget_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__SourceTarget_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__SourceTarget_USCOREType(struct soap *soap, const char *tag, int id, jsdl__SourceTarget_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__SourceTarget_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__SourceTarget_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__SourceTarget_USCOREType(struct soap *soap, const char *tag, jsdl__SourceTarget_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__SourceTarget_USCOREType **)soap_malloc(soap, sizeof(jsdl__SourceTarget_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__SourceTarget_USCOREType *)soap_instantiate_jsdl__SourceTarget_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__SourceTarget_USCOREType ** p = (jsdl__SourceTarget_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__SourceTarget_USCOREType, sizeof(jsdl__SourceTarget_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__SourceTarget_USCOREType(struct soap *soap, jsdl__SourceTarget_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__SourceTarget_USCOREType);
	if (soap_out_PointerTojsdl__SourceTarget_USCOREType(soap, tag?tag:"jsdl:SourceTarget_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 jsdl__SourceTarget_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__SourceTarget_USCOREType(struct soap *soap, jsdl__SourceTarget_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__SourceTarget_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__NCName(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__NCName))
		soap_serialize_xsd__NCName(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__NCName(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__NCName);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__NCName(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__NCName(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__NCName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__NCName, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__NCName(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__NCName);
	if (soap_out_PointerToxsd__NCName(soap, tag?tag:"xsd:NCName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__NCName(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__NCName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__OperatingSystemType_USCOREType(struct soap *soap, jsdl__OperatingSystemType_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__OperatingSystemType_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__OperatingSystemType_USCOREType(struct soap *soap, const char *tag, int id, jsdl__OperatingSystemType_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__OperatingSystemType_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__OperatingSystemType_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__OperatingSystemType_USCOREType(struct soap *soap, const char *tag, jsdl__OperatingSystemType_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__OperatingSystemType_USCOREType **)soap_malloc(soap, sizeof(jsdl__OperatingSystemType_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__OperatingSystemType_USCOREType *)soap_instantiate_jsdl__OperatingSystemType_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__OperatingSystemType_USCOREType ** p = (jsdl__OperatingSystemType_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__OperatingSystemType_USCOREType, sizeof(jsdl__OperatingSystemType_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__OperatingSystemType_USCOREType(struct soap *soap, jsdl__OperatingSystemType_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__OperatingSystemType_USCOREType);
	if (soap_out_PointerTojsdl__OperatingSystemType_USCOREType(soap, tag?tag:"jsdl:OperatingSystemType_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 jsdl__OperatingSystemType_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__OperatingSystemType_USCOREType(struct soap *soap, jsdl__OperatingSystemType_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__OperatingSystemType_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__FileSystemTypeEnumeration(struct soap *soap, enum jsdl__FileSystemTypeEnumeration *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_jsdl__FileSystemTypeEnumeration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__FileSystemTypeEnumeration(struct soap *soap, const char *tag, int id, enum jsdl__FileSystemTypeEnumeration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__FileSystemTypeEnumeration);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__FileSystemTypeEnumeration(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum jsdl__FileSystemTypeEnumeration ** SOAP_FMAC4 soap_in_PointerTojsdl__FileSystemTypeEnumeration(struct soap *soap, const char *tag, enum jsdl__FileSystemTypeEnumeration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum jsdl__FileSystemTypeEnumeration **)soap_malloc(soap, sizeof(enum jsdl__FileSystemTypeEnumeration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_jsdl__FileSystemTypeEnumeration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum jsdl__FileSystemTypeEnumeration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__FileSystemTypeEnumeration, sizeof(enum jsdl__FileSystemTypeEnumeration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__FileSystemTypeEnumeration(struct soap *soap, enum jsdl__FileSystemTypeEnumeration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__FileSystemTypeEnumeration);
	if (soap_out_PointerTojsdl__FileSystemTypeEnumeration(soap, tag?tag:"jsdl:FileSystemTypeEnumeration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum jsdl__FileSystemTypeEnumeration ** SOAP_FMAC4 soap_get_PointerTojsdl__FileSystemTypeEnumeration(struct soap *soap, enum jsdl__FileSystemTypeEnumeration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__FileSystemTypeEnumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__RangeValue_USCOREType(struct soap *soap, jsdl__RangeValue_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__RangeValue_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__RangeValue_USCOREType(struct soap *soap, const char *tag, int id, jsdl__RangeValue_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__RangeValue_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__RangeValue_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__RangeValue_USCOREType(struct soap *soap, const char *tag, jsdl__RangeValue_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__RangeValue_USCOREType **)soap_malloc(soap, sizeof(jsdl__RangeValue_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__RangeValue_USCOREType *)soap_instantiate_jsdl__RangeValue_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__RangeValue_USCOREType ** p = (jsdl__RangeValue_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__RangeValue_USCOREType, sizeof(jsdl__RangeValue_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__RangeValue_USCOREType(struct soap *soap, jsdl__RangeValue_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__RangeValue_USCOREType);
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, tag?tag:"jsdl:RangeValue_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 jsdl__RangeValue_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__RangeValue_USCOREType(struct soap *soap, jsdl__RangeValue_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__RangeValue_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__CPUArchitecture_USCOREType(struct soap *soap, jsdl__CPUArchitecture_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__CPUArchitecture_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__CPUArchitecture_USCOREType(struct soap *soap, const char *tag, int id, jsdl__CPUArchitecture_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__CPUArchitecture_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__CPUArchitecture_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__CPUArchitecture_USCOREType(struct soap *soap, const char *tag, jsdl__CPUArchitecture_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__CPUArchitecture_USCOREType **)soap_malloc(soap, sizeof(jsdl__CPUArchitecture_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__CPUArchitecture_USCOREType *)soap_instantiate_jsdl__CPUArchitecture_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__CPUArchitecture_USCOREType ** p = (jsdl__CPUArchitecture_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__CPUArchitecture_USCOREType, sizeof(jsdl__CPUArchitecture_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__CPUArchitecture_USCOREType(struct soap *soap, jsdl__CPUArchitecture_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__CPUArchitecture_USCOREType);
	if (soap_out_PointerTojsdl__CPUArchitecture_USCOREType(soap, tag?tag:"jsdl:CPUArchitecture_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 jsdl__CPUArchitecture_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__CPUArchitecture_USCOREType(struct soap *soap, jsdl__CPUArchitecture_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__CPUArchitecture_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__OperatingSystem_USCOREType(struct soap *soap, jsdl__OperatingSystem_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__OperatingSystem_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__OperatingSystem_USCOREType(struct soap *soap, const char *tag, int id, jsdl__OperatingSystem_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__OperatingSystem_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__OperatingSystem_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__OperatingSystem_USCOREType(struct soap *soap, const char *tag, jsdl__OperatingSystem_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__OperatingSystem_USCOREType **)soap_malloc(soap, sizeof(jsdl__OperatingSystem_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__OperatingSystem_USCOREType *)soap_instantiate_jsdl__OperatingSystem_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__OperatingSystem_USCOREType ** p = (jsdl__OperatingSystem_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__OperatingSystem_USCOREType, sizeof(jsdl__OperatingSystem_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__OperatingSystem_USCOREType(struct soap *soap, jsdl__OperatingSystem_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__OperatingSystem_USCOREType);
	if (soap_out_PointerTojsdl__OperatingSystem_USCOREType(soap, tag?tag:"jsdl:OperatingSystem_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 jsdl__OperatingSystem_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__OperatingSystem_USCOREType(struct soap *soap, jsdl__OperatingSystem_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__OperatingSystem_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobool);
	if (soap_out_PointerTobool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__FileSystem_USCOREType(struct soap *soap, jsdl__FileSystem_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__FileSystem_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__FileSystem_USCOREType(struct soap *soap, const char *tag, int id, jsdl__FileSystem_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__FileSystem_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__FileSystem_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__FileSystem_USCOREType(struct soap *soap, const char *tag, jsdl__FileSystem_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__FileSystem_USCOREType **)soap_malloc(soap, sizeof(jsdl__FileSystem_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__FileSystem_USCOREType *)soap_instantiate_jsdl__FileSystem_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__FileSystem_USCOREType ** p = (jsdl__FileSystem_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__FileSystem_USCOREType, sizeof(jsdl__FileSystem_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__FileSystem_USCOREType(struct soap *soap, jsdl__FileSystem_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__FileSystem_USCOREType);
	if (soap_out_PointerTojsdl__FileSystem_USCOREType(soap, tag?tag:"jsdl:FileSystem_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 jsdl__FileSystem_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__FileSystem_USCOREType(struct soap *soap, jsdl__FileSystem_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__FileSystem_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__CandidateHosts_USCOREType(struct soap *soap, jsdl__CandidateHosts_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__CandidateHosts_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__CandidateHosts_USCOREType(struct soap *soap, const char *tag, int id, jsdl__CandidateHosts_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__CandidateHosts_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__CandidateHosts_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__CandidateHosts_USCOREType(struct soap *soap, const char *tag, jsdl__CandidateHosts_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__CandidateHosts_USCOREType **)soap_malloc(soap, sizeof(jsdl__CandidateHosts_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__CandidateHosts_USCOREType *)soap_instantiate_jsdl__CandidateHosts_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__CandidateHosts_USCOREType ** p = (jsdl__CandidateHosts_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__CandidateHosts_USCOREType, sizeof(jsdl__CandidateHosts_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__CandidateHosts_USCOREType(struct soap *soap, jsdl__CandidateHosts_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__CandidateHosts_USCOREType);
	if (soap_out_PointerTojsdl__CandidateHosts_USCOREType(soap, tag?tag:"jsdl:CandidateHosts_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 jsdl__CandidateHosts_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__CandidateHosts_USCOREType(struct soap *soap, jsdl__CandidateHosts_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__CandidateHosts_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__Description_USCOREType(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__Description_USCOREType))
		soap_serialize_jsdl__Description_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__Description_USCOREType(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__Description_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__Description_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTojsdl__Description_USCOREType(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_jsdl__Description_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__Description_USCOREType, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__Description_USCOREType(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__Description_USCOREType);
	if (soap_out_PointerTojsdl__Description_USCOREType(soap, tag?tag:"jsdl:Description_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTojsdl__Description_USCOREType(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Description_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__DataStaging_USCOREType(struct soap *soap, jsdl__DataStaging_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__DataStaging_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__DataStaging_USCOREType(struct soap *soap, const char *tag, int id, jsdl__DataStaging_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__DataStaging_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__DataStaging_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__DataStaging_USCOREType(struct soap *soap, const char *tag, jsdl__DataStaging_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__DataStaging_USCOREType **)soap_malloc(soap, sizeof(jsdl__DataStaging_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__DataStaging_USCOREType *)soap_instantiate_jsdl__DataStaging_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__DataStaging_USCOREType ** p = (jsdl__DataStaging_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__DataStaging_USCOREType, sizeof(jsdl__DataStaging_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__DataStaging_USCOREType(struct soap *soap, jsdl__DataStaging_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__DataStaging_USCOREType);
	if (soap_out_PointerTojsdl__DataStaging_USCOREType(soap, tag?tag:"jsdl:DataStaging_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 jsdl__DataStaging_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__DataStaging_USCOREType(struct soap *soap, jsdl__DataStaging_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__DataStaging_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__Resources_USCOREType(struct soap *soap, jsdl__Resources_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__Resources_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__Resources_USCOREType(struct soap *soap, const char *tag, int id, jsdl__Resources_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__Resources_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__Resources_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__Resources_USCOREType(struct soap *soap, const char *tag, jsdl__Resources_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__Resources_USCOREType **)soap_malloc(soap, sizeof(jsdl__Resources_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__Resources_USCOREType *)soap_instantiate_jsdl__Resources_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__Resources_USCOREType ** p = (jsdl__Resources_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__Resources_USCOREType, sizeof(jsdl__Resources_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__Resources_USCOREType(struct soap *soap, jsdl__Resources_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__Resources_USCOREType);
	if (soap_out_PointerTojsdl__Resources_USCOREType(soap, tag?tag:"jsdl:Resources_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 jsdl__Resources_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__Resources_USCOREType(struct soap *soap, jsdl__Resources_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Resources_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__Application_USCOREType(struct soap *soap, jsdl__Application_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__Application_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__Application_USCOREType(struct soap *soap, const char *tag, int id, jsdl__Application_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__Application_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__Application_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__Application_USCOREType(struct soap *soap, const char *tag, jsdl__Application_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__Application_USCOREType **)soap_malloc(soap, sizeof(jsdl__Application_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__Application_USCOREType *)soap_instantiate_jsdl__Application_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__Application_USCOREType ** p = (jsdl__Application_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__Application_USCOREType, sizeof(jsdl__Application_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__Application_USCOREType(struct soap *soap, jsdl__Application_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__Application_USCOREType);
	if (soap_out_PointerTojsdl__Application_USCOREType(soap, tag?tag:"jsdl:Application_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 jsdl__Application_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__Application_USCOREType(struct soap *soap, jsdl__Application_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Application_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__JobIdentification_USCOREType(struct soap *soap, jsdl__JobIdentification_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__JobIdentification_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__JobIdentification_USCOREType(struct soap *soap, const char *tag, int id, jsdl__JobIdentification_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__JobIdentification_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__JobIdentification_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__JobIdentification_USCOREType(struct soap *soap, const char *tag, jsdl__JobIdentification_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__JobIdentification_USCOREType **)soap_malloc(soap, sizeof(jsdl__JobIdentification_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__JobIdentification_USCOREType *)soap_instantiate_jsdl__JobIdentification_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__JobIdentification_USCOREType ** p = (jsdl__JobIdentification_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__JobIdentification_USCOREType, sizeof(jsdl__JobIdentification_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__JobIdentification_USCOREType(struct soap *soap, jsdl__JobIdentification_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__JobIdentification_USCOREType);
	if (soap_out_PointerTojsdl__JobIdentification_USCOREType(soap, tag?tag:"jsdl:JobIdentification_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 jsdl__JobIdentification_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__JobIdentification_USCOREType(struct soap *soap, jsdl__JobIdentification_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__JobIdentification_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__ID(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__ID))
		soap_serialize_xsd__ID(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__ID(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__ID);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__ID(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__ID(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__ID(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__ID, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__ID(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__ID);
	if (soap_out_PointerToxsd__ID(soap, tag?tag:"xsd:ID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__ID(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__ID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__JobDescription_USCOREType(struct soap *soap, jsdl__JobDescription_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__JobDescription_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__JobDescription_USCOREType(struct soap *soap, const char *tag, int id, jsdl__JobDescription_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__JobDescription_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__JobDescription_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__JobDescription_USCOREType(struct soap *soap, const char *tag, jsdl__JobDescription_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__JobDescription_USCOREType **)soap_malloc(soap, sizeof(jsdl__JobDescription_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__JobDescription_USCOREType *)soap_instantiate_jsdl__JobDescription_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__JobDescription_USCOREType ** p = (jsdl__JobDescription_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__JobDescription_USCOREType, sizeof(jsdl__JobDescription_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__JobDescription_USCOREType(struct soap *soap, jsdl__JobDescription_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__JobDescription_USCOREType);
	if (soap_out_PointerTojsdl__JobDescription_USCOREType(soap, tag?tag:"jsdl:JobDescription_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 jsdl__JobDescription_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__JobDescription_USCOREType(struct soap *soap, jsdl__JobDescription_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__JobDescription_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__Range_USCOREType(struct soap *soap, jsdl__Range_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__Range_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__Range_USCOREType(struct soap *soap, const char *tag, int id, jsdl__Range_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__Range_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__Range_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__Range_USCOREType(struct soap *soap, const char *tag, jsdl__Range_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__Range_USCOREType **)soap_malloc(soap, sizeof(jsdl__Range_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__Range_USCOREType *)soap_instantiate_jsdl__Range_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__Range_USCOREType ** p = (jsdl__Range_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__Range_USCOREType, sizeof(jsdl__Range_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__Range_USCOREType(struct soap *soap, jsdl__Range_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__Range_USCOREType);
	if (soap_out_PointerTojsdl__Range_USCOREType(soap, tag?tag:"jsdl:Range_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 jsdl__Range_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__Range_USCOREType(struct soap *soap, jsdl__Range_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Range_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__Exact_USCOREType(struct soap *soap, jsdl__Exact_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__Exact_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__Exact_USCOREType(struct soap *soap, const char *tag, int id, jsdl__Exact_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__Exact_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__Exact_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__Exact_USCOREType(struct soap *soap, const char *tag, jsdl__Exact_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__Exact_USCOREType **)soap_malloc(soap, sizeof(jsdl__Exact_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__Exact_USCOREType *)soap_instantiate_jsdl__Exact_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__Exact_USCOREType ** p = (jsdl__Exact_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__Exact_USCOREType, sizeof(jsdl__Exact_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__Exact_USCOREType(struct soap *soap, jsdl__Exact_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__Exact_USCOREType);
	if (soap_out_PointerTojsdl__Exact_USCOREType(soap, tag?tag:"jsdl:Exact_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 jsdl__Exact_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__Exact_USCOREType(struct soap *soap, jsdl__Exact_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Exact_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__Boundary_USCOREType(struct soap *soap, jsdl__Boundary_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__Boundary_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__Boundary_USCOREType(struct soap *soap, const char *tag, int id, jsdl__Boundary_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__Boundary_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__Boundary_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__Boundary_USCOREType(struct soap *soap, const char *tag, jsdl__Boundary_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__Boundary_USCOREType **)soap_malloc(soap, sizeof(jsdl__Boundary_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__Boundary_USCOREType *)soap_instantiate_jsdl__Boundary_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__Boundary_USCOREType ** p = (jsdl__Boundary_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__Boundary_USCOREType, sizeof(jsdl__Boundary_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__Boundary_USCOREType(struct soap *soap, jsdl__Boundary_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__Boundary_USCOREType);
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, tag?tag:"jsdl:Boundary_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 jsdl__Boundary_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__Boundary_USCOREType(struct soap *soap, jsdl__Boundary_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Boundary_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__VOProxyInfoStructType(struct soap *soap, ns1__VOProxyInfoStructType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__VOProxyInfoStructType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__VOProxyInfoStructType(struct soap *soap, const char *tag, int id, ns1__VOProxyInfoStructType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__VOProxyInfoStructType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__VOProxyInfoStructType ** SOAP_FMAC4 soap_in_PointerTons1__VOProxyInfoStructType(struct soap *soap, const char *tag, ns1__VOProxyInfoStructType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__VOProxyInfoStructType **)soap_malloc(soap, sizeof(ns1__VOProxyInfoStructType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__VOProxyInfoStructType *)soap_instantiate_ns1__VOProxyInfoStructType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__VOProxyInfoStructType ** p = (ns1__VOProxyInfoStructType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__VOProxyInfoStructType, sizeof(ns1__VOProxyInfoStructType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__VOProxyInfoStructType(struct soap *soap, ns1__VOProxyInfoStructType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__VOProxyInfoStructType);
	if (soap_out_PointerTons1__VOProxyInfoStructType(soap, tag?tag:"ns1:VOProxyInfoStructType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__VOProxyInfoStructType ** SOAP_FMAC4 soap_get_PointerTons1__VOProxyInfoStructType(struct soap *soap, ns1__VOProxyInfoStructType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__VOProxyInfoStructType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GraphStructType(struct soap *soap, ns1__GraphStructType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GraphStructType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GraphStructType(struct soap *soap, const char *tag, int id, ns1__GraphStructType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GraphStructType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__GraphStructType ** SOAP_FMAC4 soap_in_PointerTons1__GraphStructType(struct soap *soap, const char *tag, ns1__GraphStructType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GraphStructType **)soap_malloc(soap, sizeof(ns1__GraphStructType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GraphStructType *)soap_instantiate_ns1__GraphStructType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__GraphStructType ** p = (ns1__GraphStructType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GraphStructType, sizeof(ns1__GraphStructType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GraphStructType(struct soap *soap, ns1__GraphStructType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__GraphStructType);
	if (soap_out_PointerTons1__GraphStructType(soap, tag?tag:"ns1:GraphStructType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__GraphStructType ** SOAP_FMAC4 soap_get_PointerTons1__GraphStructType(struct soap *soap, ns1__GraphStructType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GraphStructType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__JobIdStructType(struct soap *soap, ns1__JobIdStructType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__JobIdStructType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__JobIdStructType(struct soap *soap, const char *tag, int id, ns1__JobIdStructType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__JobIdStructType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__JobIdStructType ** SOAP_FMAC4 soap_in_PointerTons1__JobIdStructType(struct soap *soap, const char *tag, ns1__JobIdStructType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__JobIdStructType **)soap_malloc(soap, sizeof(ns1__JobIdStructType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__JobIdStructType *)soap_instantiate_ns1__JobIdStructType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__JobIdStructType ** p = (ns1__JobIdStructType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__JobIdStructType, sizeof(ns1__JobIdStructType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__JobIdStructType(struct soap *soap, ns1__JobIdStructType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__JobIdStructType);
	if (soap_out_PointerTons1__JobIdStructType(soap, tag?tag:"ns1:JobIdStructType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__JobIdStructType ** SOAP_FMAC4 soap_get_PointerTons1__JobIdStructType(struct soap *soap, ns1__JobIdStructType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__JobIdStructType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__JobStatusStructType(struct soap *soap, ns1__JobStatusStructType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__JobStatusStructType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__JobStatusStructType(struct soap *soap, const char *tag, int id, ns1__JobStatusStructType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__JobStatusStructType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__JobStatusStructType ** SOAP_FMAC4 soap_in_PointerTons1__JobStatusStructType(struct soap *soap, const char *tag, ns1__JobStatusStructType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__JobStatusStructType **)soap_malloc(soap, sizeof(ns1__JobStatusStructType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__JobStatusStructType *)soap_instantiate_ns1__JobStatusStructType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__JobStatusStructType ** p = (ns1__JobStatusStructType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__JobStatusStructType, sizeof(ns1__JobStatusStructType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__JobStatusStructType(struct soap *soap, ns1__JobStatusStructType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__JobStatusStructType);
	if (soap_out_PointerTons1__JobStatusStructType(soap, tag?tag:"ns1:JobStatusStructType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__JobStatusStructType ** SOAP_FMAC4 soap_get_PointerTons1__JobStatusStructType(struct soap *soap, ns1__JobStatusStructType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__JobStatusStructType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__StringAndLongType(struct soap *soap, ns1__StringAndLongType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__StringAndLongType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__StringAndLongType(struct soap *soap, const char *tag, int id, ns1__StringAndLongType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__StringAndLongType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__StringAndLongType ** SOAP_FMAC4 soap_in_PointerTons1__StringAndLongType(struct soap *soap, const char *tag, ns1__StringAndLongType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__StringAndLongType **)soap_malloc(soap, sizeof(ns1__StringAndLongType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__StringAndLongType *)soap_instantiate_ns1__StringAndLongType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__StringAndLongType ** p = (ns1__StringAndLongType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__StringAndLongType, sizeof(ns1__StringAndLongType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__StringAndLongType(struct soap *soap, ns1__StringAndLongType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__StringAndLongType);
	if (soap_out_PointerTons1__StringAndLongType(soap, tag?tag:"ns1:StringAndLongType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__StringAndLongType ** SOAP_FMAC4 soap_get_PointerTons1__StringAndLongType(struct soap *soap, ns1__StringAndLongType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__StringAndLongType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DestURIStructType(struct soap *soap, ns1__DestURIStructType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DestURIStructType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DestURIStructType(struct soap *soap, const char *tag, int id, ns1__DestURIStructType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DestURIStructType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__DestURIStructType ** SOAP_FMAC4 soap_in_PointerTons1__DestURIStructType(struct soap *soap, const char *tag, ns1__DestURIStructType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DestURIStructType **)soap_malloc(soap, sizeof(ns1__DestURIStructType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DestURIStructType *)soap_instantiate_ns1__DestURIStructType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__DestURIStructType ** p = (ns1__DestURIStructType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DestURIStructType, sizeof(ns1__DestURIStructType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DestURIStructType(struct soap *soap, ns1__DestURIStructType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__DestURIStructType);
	if (soap_out_PointerTons1__DestURIStructType(soap, tag?tag:"ns1:DestURIStructType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__DestURIStructType ** SOAP_FMAC4 soap_get_PointerTons1__DestURIStructType(struct soap *soap, ns1__DestURIStructType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DestURIStructType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType(struct soap *soap, std::vector<jsdlposix__Environment_USCOREType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType(struct soap *soap, const std::vector<jsdlposix__Environment_USCOREType * >*a)
{
	for (std::vector<jsdlposix__Environment_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTojsdlposix__Environment_USCOREType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType(struct soap *soap, const char *tag, int id, const std::vector<jsdlposix__Environment_USCOREType * >*a, const char *type)
{
	for (std::vector<jsdlposix__Environment_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTojsdlposix__Environment_USCOREType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<jsdlposix__Environment_USCOREType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType(struct soap *soap, const char *tag, std::vector<jsdlposix__Environment_USCOREType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType(soap, -1)))
		return NULL;
	jsdlposix__Environment_USCOREType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_jsdlposix__Environment_USCOREType, SOAP_TYPE_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType, sizeof(jsdlposix__Environment_USCOREType), 1))
				break;
			if (!soap_in_PointerTojsdlposix__Environment_USCOREType(soap, tag, NULL, "jsdlposix:Environment_Type"))
				break;
		}
		else
		{
			if (!soap_in_PointerTojsdlposix__Environment_USCOREType(soap, tag, &n, "jsdlposix:Environment_Type"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<jsdlposix__Environment_USCOREType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<jsdlposix__Environment_USCOREType * >);
		if (size)
			*size = sizeof(std::vector<jsdlposix__Environment_USCOREType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<jsdlposix__Environment_USCOREType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<jsdlposix__Environment_USCOREType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<jsdlposix__Environment_USCOREType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<jsdlposix__Environment_USCOREType * > %p -> %p\n", q, p));
	*(std::vector<jsdlposix__Environment_USCOREType * >*)p = *(std::vector<jsdlposix__Environment_USCOREType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType(struct soap *soap, std::vector<jsdlposix__Argument_USCOREType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType(struct soap *soap, const std::vector<jsdlposix__Argument_USCOREType * >*a)
{
	for (std::vector<jsdlposix__Argument_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTojsdlposix__Argument_USCOREType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType(struct soap *soap, const char *tag, int id, const std::vector<jsdlposix__Argument_USCOREType * >*a, const char *type)
{
	for (std::vector<jsdlposix__Argument_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTojsdlposix__Argument_USCOREType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<jsdlposix__Argument_USCOREType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType(struct soap *soap, const char *tag, std::vector<jsdlposix__Argument_USCOREType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType(soap, -1)))
		return NULL;
	jsdlposix__Argument_USCOREType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_jsdlposix__Argument_USCOREType, SOAP_TYPE_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType, sizeof(jsdlposix__Argument_USCOREType), 1))
				break;
			if (!soap_in_PointerTojsdlposix__Argument_USCOREType(soap, tag, NULL, "jsdlposix:Argument_Type"))
				break;
		}
		else
		{
			if (!soap_in_PointerTojsdlposix__Argument_USCOREType(soap, tag, &n, "jsdlposix:Argument_Type"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<jsdlposix__Argument_USCOREType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<jsdlposix__Argument_USCOREType * >);
		if (size)
			*size = sizeof(std::vector<jsdlposix__Argument_USCOREType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<jsdlposix__Argument_USCOREType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<jsdlposix__Argument_USCOREType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<jsdlposix__Argument_USCOREType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<jsdlposix__Argument_USCOREType * > %p -> %p\n", q, p));
	*(std::vector<jsdlposix__Argument_USCOREType * >*)p = *(std::vector<jsdlposix__Argument_USCOREType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(struct soap *soap, std::vector<jsdl__FileSystem_USCOREType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(struct soap *soap, const std::vector<jsdl__FileSystem_USCOREType * >*a)
{
	for (std::vector<jsdl__FileSystem_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTojsdl__FileSystem_USCOREType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(struct soap *soap, const char *tag, int id, const std::vector<jsdl__FileSystem_USCOREType * >*a, const char *type)
{
	for (std::vector<jsdl__FileSystem_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTojsdl__FileSystem_USCOREType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<jsdl__FileSystem_USCOREType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(struct soap *soap, const char *tag, std::vector<jsdl__FileSystem_USCOREType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(soap, -1)))
		return NULL;
	jsdl__FileSystem_USCOREType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_jsdl__FileSystem_USCOREType, SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType, sizeof(jsdl__FileSystem_USCOREType), 1))
				break;
			if (!soap_in_PointerTojsdl__FileSystem_USCOREType(soap, tag, NULL, "jsdl:FileSystem_Type"))
				break;
		}
		else
		{
			if (!soap_in_PointerTojsdl__FileSystem_USCOREType(soap, tag, &n, "jsdl:FileSystem_Type"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<jsdl__FileSystem_USCOREType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<jsdl__FileSystem_USCOREType * >);
		if (size)
			*size = sizeof(std::vector<jsdl__FileSystem_USCOREType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<jsdl__FileSystem_USCOREType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<jsdl__FileSystem_USCOREType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<jsdl__FileSystem_USCOREType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<jsdl__FileSystem_USCOREType * > %p -> %p\n", q, p));
	*(std::vector<jsdl__FileSystem_USCOREType * >*)p = *(std::vector<jsdl__FileSystem_USCOREType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(struct soap *soap, std::vector<jsdl__DataStaging_USCOREType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(struct soap *soap, const std::vector<jsdl__DataStaging_USCOREType * >*a)
{
	for (std::vector<jsdl__DataStaging_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTojsdl__DataStaging_USCOREType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(struct soap *soap, const char *tag, int id, const std::vector<jsdl__DataStaging_USCOREType * >*a, const char *type)
{
	for (std::vector<jsdl__DataStaging_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTojsdl__DataStaging_USCOREType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<jsdl__DataStaging_USCOREType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(struct soap *soap, const char *tag, std::vector<jsdl__DataStaging_USCOREType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(soap, -1)))
		return NULL;
	jsdl__DataStaging_USCOREType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_jsdl__DataStaging_USCOREType, SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType, sizeof(jsdl__DataStaging_USCOREType), 1))
				break;
			if (!soap_in_PointerTojsdl__DataStaging_USCOREType(soap, tag, NULL, "jsdl:DataStaging_Type"))
				break;
		}
		else
		{
			if (!soap_in_PointerTojsdl__DataStaging_USCOREType(soap, tag, &n, "jsdl:DataStaging_Type"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<jsdl__DataStaging_USCOREType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<jsdl__DataStaging_USCOREType * >);
		if (size)
			*size = sizeof(std::vector<jsdl__DataStaging_USCOREType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<jsdl__DataStaging_USCOREType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<jsdl__DataStaging_USCOREType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<jsdl__DataStaging_USCOREType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<jsdl__DataStaging_USCOREType * > %p -> %p\n", q, p));
	*(std::vector<jsdl__DataStaging_USCOREType * >*)p = *(std::vector<jsdl__DataStaging_USCOREType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_XML(struct soap *soap, std::vector<char * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_XML(struct soap *soap, const std::vector<char * >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, int id, const std::vector<char * >*a, const char *type)
{
	for (std::vector<char * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_outliteral(soap, tag, &(*i), NULL))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<char * >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, std::vector<char * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOf_XML(soap, -1)))
		return NULL;
	char *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__XML, SOAP_TYPE_std__vectorTemplateOf_XML, sizeof(char *), 1))
				break;
			if (!soap_inliteral(soap, tag, NULL))
				break;
		}
		else
		{
			if (!soap_inliteral(soap, tag, &n))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<char * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_XML(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_XML(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf_XML, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<char * >);
		if (size)
			*size = sizeof(std::vector<char * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<char * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<char * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<char * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_XML(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<char * > %p -> %p\n", q, p));
	*(std::vector<char * >*)p = *(std::vector<char * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(struct soap *soap, std::vector<jsdl__Range_USCOREType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(struct soap *soap, const std::vector<jsdl__Range_USCOREType * >*a)
{
	for (std::vector<jsdl__Range_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTojsdl__Range_USCOREType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(struct soap *soap, const char *tag, int id, const std::vector<jsdl__Range_USCOREType * >*a, const char *type)
{
	for (std::vector<jsdl__Range_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTojsdl__Range_USCOREType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<jsdl__Range_USCOREType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(struct soap *soap, const char *tag, std::vector<jsdl__Range_USCOREType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(soap, -1)))
		return NULL;
	jsdl__Range_USCOREType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_jsdl__Range_USCOREType, SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__Range_USCOREType, sizeof(jsdl__Range_USCOREType), 1))
				break;
			if (!soap_in_PointerTojsdl__Range_USCOREType(soap, tag, NULL, "jsdl:Range_Type"))
				break;
		}
		else
		{
			if (!soap_in_PointerTojsdl__Range_USCOREType(soap, tag, &n, "jsdl:Range_Type"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<jsdl__Range_USCOREType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__Range_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<jsdl__Range_USCOREType * >);
		if (size)
			*size = sizeof(std::vector<jsdl__Range_USCOREType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<jsdl__Range_USCOREType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<jsdl__Range_USCOREType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<jsdl__Range_USCOREType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<jsdl__Range_USCOREType * > %p -> %p\n", q, p));
	*(std::vector<jsdl__Range_USCOREType * >*)p = *(std::vector<jsdl__Range_USCOREType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(struct soap *soap, std::vector<jsdl__Exact_USCOREType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(struct soap *soap, const std::vector<jsdl__Exact_USCOREType * >*a)
{
	for (std::vector<jsdl__Exact_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTojsdl__Exact_USCOREType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(struct soap *soap, const char *tag, int id, const std::vector<jsdl__Exact_USCOREType * >*a, const char *type)
{
	for (std::vector<jsdl__Exact_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTojsdl__Exact_USCOREType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<jsdl__Exact_USCOREType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(struct soap *soap, const char *tag, std::vector<jsdl__Exact_USCOREType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(soap, -1)))
		return NULL;
	jsdl__Exact_USCOREType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_jsdl__Exact_USCOREType, SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType, sizeof(jsdl__Exact_USCOREType), 1))
				break;
			if (!soap_in_PointerTojsdl__Exact_USCOREType(soap, tag, NULL, "jsdl:Exact_Type"))
				break;
		}
		else
		{
			if (!soap_in_PointerTojsdl__Exact_USCOREType(soap, tag, &n, "jsdl:Exact_Type"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<jsdl__Exact_USCOREType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<jsdl__Exact_USCOREType * >);
		if (size)
			*size = sizeof(std::vector<jsdl__Exact_USCOREType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<jsdl__Exact_USCOREType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<jsdl__Exact_USCOREType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<jsdl__Exact_USCOREType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<jsdl__Exact_USCOREType * > %p -> %p\n", q, p));
	*(std::vector<jsdl__Exact_USCOREType * >*)p = *(std::vector<jsdl__Exact_USCOREType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__VOProxyInfoStructType(struct soap *soap, std::vector<ns1__VOProxyInfoStructType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__VOProxyInfoStructType(struct soap *soap, const std::vector<ns1__VOProxyInfoStructType * >*a)
{
	for (std::vector<ns1__VOProxyInfoStructType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__VOProxyInfoStructType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__VOProxyInfoStructType(struct soap *soap, const char *tag, int id, const std::vector<ns1__VOProxyInfoStructType * >*a, const char *type)
{
	for (std::vector<ns1__VOProxyInfoStructType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__VOProxyInfoStructType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__VOProxyInfoStructType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__VOProxyInfoStructType(struct soap *soap, const char *tag, std::vector<ns1__VOProxyInfoStructType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__VOProxyInfoStructType(soap, -1)))
		return NULL;
	ns1__VOProxyInfoStructType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__VOProxyInfoStructType, SOAP_TYPE_std__vectorTemplateOfPointerTons1__VOProxyInfoStructType, sizeof(ns1__VOProxyInfoStructType), 1))
				break;
			if (!soap_in_PointerTons1__VOProxyInfoStructType(soap, tag, NULL, "ns1:VOProxyInfoStructType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__VOProxyInfoStructType(soap, tag, &n, "ns1:VOProxyInfoStructType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__VOProxyInfoStructType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__VOProxyInfoStructType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__VOProxyInfoStructType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__VOProxyInfoStructType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__VOProxyInfoStructType * >);
		if (size)
			*size = sizeof(std::vector<ns1__VOProxyInfoStructType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__VOProxyInfoStructType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__VOProxyInfoStructType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__VOProxyInfoStructType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__VOProxyInfoStructType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__VOProxyInfoStructType * > %p -> %p\n", q, p));
	*(std::vector<ns1__VOProxyInfoStructType * >*)p = *(std::vector<ns1__VOProxyInfoStructType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__GraphStructType(struct soap *soap, std::vector<ns1__GraphStructType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__GraphStructType(struct soap *soap, const std::vector<ns1__GraphStructType * >*a)
{
	for (std::vector<ns1__GraphStructType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__GraphStructType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__GraphStructType(struct soap *soap, const char *tag, int id, const std::vector<ns1__GraphStructType * >*a, const char *type)
{
	for (std::vector<ns1__GraphStructType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__GraphStructType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__GraphStructType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__GraphStructType(struct soap *soap, const char *tag, std::vector<ns1__GraphStructType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__GraphStructType(soap, -1)))
		return NULL;
	ns1__GraphStructType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__GraphStructType, SOAP_TYPE_std__vectorTemplateOfPointerTons1__GraphStructType, sizeof(ns1__GraphStructType), 1))
				break;
			if (!soap_in_PointerTons1__GraphStructType(soap, tag, NULL, "ns1:GraphStructType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__GraphStructType(soap, tag, &n, "ns1:GraphStructType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__GraphStructType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__GraphStructType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__GraphStructType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__GraphStructType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__GraphStructType * >);
		if (size)
			*size = sizeof(std::vector<ns1__GraphStructType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__GraphStructType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__GraphStructType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__GraphStructType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__GraphStructType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__GraphStructType * > %p -> %p\n", q, p));
	*(std::vector<ns1__GraphStructType * >*)p = *(std::vector<ns1__GraphStructType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__JobIdStructType(struct soap *soap, std::vector<ns1__JobIdStructType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__JobIdStructType(struct soap *soap, const std::vector<ns1__JobIdStructType * >*a)
{
	for (std::vector<ns1__JobIdStructType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__JobIdStructType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__JobIdStructType(struct soap *soap, const char *tag, int id, const std::vector<ns1__JobIdStructType * >*a, const char *type)
{
	for (std::vector<ns1__JobIdStructType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__JobIdStructType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__JobIdStructType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__JobIdStructType(struct soap *soap, const char *tag, std::vector<ns1__JobIdStructType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__JobIdStructType(soap, -1)))
		return NULL;
	ns1__JobIdStructType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__JobIdStructType, SOAP_TYPE_std__vectorTemplateOfPointerTons1__JobIdStructType, sizeof(ns1__JobIdStructType), 1))
				break;
			if (!soap_in_PointerTons1__JobIdStructType(soap, tag, NULL, "ns1:JobIdStructType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__JobIdStructType(soap, tag, &n, "ns1:JobIdStructType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__JobIdStructType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__JobIdStructType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__JobIdStructType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__JobIdStructType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__JobIdStructType * >);
		if (size)
			*size = sizeof(std::vector<ns1__JobIdStructType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__JobIdStructType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__JobIdStructType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__JobIdStructType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__JobIdStructType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__JobIdStructType * > %p -> %p\n", q, p));
	*(std::vector<ns1__JobIdStructType * >*)p = *(std::vector<ns1__JobIdStructType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__JobStatusStructType(struct soap *soap, std::vector<ns1__JobStatusStructType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__JobStatusStructType(struct soap *soap, const std::vector<ns1__JobStatusStructType * >*a)
{
	for (std::vector<ns1__JobStatusStructType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__JobStatusStructType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__JobStatusStructType(struct soap *soap, const char *tag, int id, const std::vector<ns1__JobStatusStructType * >*a, const char *type)
{
	for (std::vector<ns1__JobStatusStructType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__JobStatusStructType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__JobStatusStructType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__JobStatusStructType(struct soap *soap, const char *tag, std::vector<ns1__JobStatusStructType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__JobStatusStructType(soap, -1)))
		return NULL;
	ns1__JobStatusStructType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__JobStatusStructType, SOAP_TYPE_std__vectorTemplateOfPointerTons1__JobStatusStructType, sizeof(ns1__JobStatusStructType), 1))
				break;
			if (!soap_in_PointerTons1__JobStatusStructType(soap, tag, NULL, "ns1:JobStatusStructType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__JobStatusStructType(soap, tag, &n, "ns1:JobStatusStructType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__JobStatusStructType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__JobStatusStructType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__JobStatusStructType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__JobStatusStructType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__JobStatusStructType * >);
		if (size)
			*size = sizeof(std::vector<ns1__JobStatusStructType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__JobStatusStructType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__JobStatusStructType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__JobStatusStructType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__JobStatusStructType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__JobStatusStructType * > %p -> %p\n", q, p));
	*(std::vector<ns1__JobStatusStructType * >*)p = *(std::vector<ns1__JobStatusStructType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__StringAndLongType(struct soap *soap, std::vector<ns1__StringAndLongType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__StringAndLongType(struct soap *soap, const std::vector<ns1__StringAndLongType * >*a)
{
	for (std::vector<ns1__StringAndLongType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__StringAndLongType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__StringAndLongType(struct soap *soap, const char *tag, int id, const std::vector<ns1__StringAndLongType * >*a, const char *type)
{
	for (std::vector<ns1__StringAndLongType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__StringAndLongType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__StringAndLongType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__StringAndLongType(struct soap *soap, const char *tag, std::vector<ns1__StringAndLongType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__StringAndLongType(soap, -1)))
		return NULL;
	ns1__StringAndLongType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__StringAndLongType, SOAP_TYPE_std__vectorTemplateOfPointerTons1__StringAndLongType, sizeof(ns1__StringAndLongType), 1))
				break;
			if (!soap_in_PointerTons1__StringAndLongType(soap, tag, NULL, "ns1:StringAndLongType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__StringAndLongType(soap, tag, &n, "ns1:StringAndLongType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__StringAndLongType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__StringAndLongType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__StringAndLongType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__StringAndLongType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__StringAndLongType * >);
		if (size)
			*size = sizeof(std::vector<ns1__StringAndLongType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__StringAndLongType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__StringAndLongType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__StringAndLongType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__StringAndLongType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__StringAndLongType * > %p -> %p\n", q, p));
	*(std::vector<ns1__StringAndLongType * >*)p = *(std::vector<ns1__StringAndLongType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__DestURIStructType(struct soap *soap, std::vector<ns1__DestURIStructType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__DestURIStructType(struct soap *soap, const std::vector<ns1__DestURIStructType * >*a)
{
	for (std::vector<ns1__DestURIStructType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__DestURIStructType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__DestURIStructType(struct soap *soap, const char *tag, int id, const std::vector<ns1__DestURIStructType * >*a, const char *type)
{
	for (std::vector<ns1__DestURIStructType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__DestURIStructType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__DestURIStructType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__DestURIStructType(struct soap *soap, const char *tag, std::vector<ns1__DestURIStructType * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__DestURIStructType(soap, -1)))
		return NULL;
	ns1__DestURIStructType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__DestURIStructType, SOAP_TYPE_std__vectorTemplateOfPointerTons1__DestURIStructType, sizeof(ns1__DestURIStructType), 1))
				break;
			if (!soap_in_PointerTons1__DestURIStructType(soap, tag, NULL, "ns1:DestURIStructType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__DestURIStructType(soap, tag, &n, "ns1:DestURIStructType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__DestURIStructType * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__DestURIStructType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__DestURIStructType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__DestURIStructType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__DestURIStructType * >);
		if (size)
			*size = sizeof(std::vector<ns1__DestURIStructType * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__DestURIStructType * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__DestURIStructType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__DestURIStructType * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__DestURIStructType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__DestURIStructType * > %p -> %p\n", q, p));
	*(std::vector<ns1__DestURIStructType * >*)p = *(std::vector<ns1__DestURIStructType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
		return NULL;
	std::string n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_std__string(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{
			if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >);
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<std::string >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns1__JobType(struct soap *soap, std::vector<enum ns1__JobType >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns1__JobType(struct soap *soap, const std::vector<enum ns1__JobType >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns1__JobType(struct soap *soap, const char *tag, int id, const std::vector<enum ns1__JobType >*a, const char *type)
{
	for (std::vector<enum ns1__JobType >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_ns1__JobType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum ns1__JobType >* SOAP_FMAC4 soap_in_std__vectorTemplateOfns1__JobType(struct soap *soap, const char *tag, std::vector<enum ns1__JobType >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfns1__JobType(soap, -1)))
		return NULL;
	enum ns1__JobType n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_ns1__JobType(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__JobType, SOAP_TYPE_std__vectorTemplateOfns1__JobType, sizeof(enum ns1__JobType), 0))
				break;
			if (!soap_in_ns1__JobType(soap, tag, NULL, "ns1:JobType"))
				break;
		}
		else
		{
			if (!soap_in_ns1__JobType(soap, tag, &n, "ns1:JobType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum ns1__JobType > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfns1__JobType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns1__JobType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfns1__JobType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum ns1__JobType >);
		if (size)
			*size = sizeof(std::vector<enum ns1__JobType >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<enum ns1__JobType >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<enum ns1__JobType >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<enum ns1__JobType >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfns1__JobType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<enum ns1__JobType > %p -> %p\n", q, p));
	*(std::vector<enum ns1__JobType >*)p = *(std::vector<enum ns1__JobType >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
