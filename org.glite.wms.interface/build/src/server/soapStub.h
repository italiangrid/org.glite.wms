/* soapStub.h
   Generated by gSOAP 2.7.16 from wm.h
   Copyright(C) 2000-2010, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#ifndef soapStub_H
#define soapStub_H
#include <vector>
#define SOAP_NAMESPACE_OF_ns1	"http://glite.org/wms/wmproxy"
#define SOAP_NAMESPACE_OF_jsdl	"http://schemas.ggf.org/jsdl/2005/11/jsdl"
#define SOAP_NAMESPACE_OF_jsdlposix	"http://schemas.ggf.org/jsdl/2005/11/jsdl-posix"
#define SOAP_NAMESPACE_OF_jsdlposix	"http://schemas.ggf.org/jsdl/2005/11/jsdl-posix"
#define SOAP_NAMESPACE_OF_delegationns	"http://www.gridsite.org/namespaces/delegation-2"
#define SOAP_NAMESPACE_OF_delegation1	"http://www.gridsite.org/namespaces/delegation-1"
#include "stdsoap2.h"

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_ns1__ObjectType
#define SOAP_TYPE_ns1__ObjectType (62)
/* ns1:ObjectType */
enum ns1__ObjectType {ns1__ObjectType__JOB = 0, ns1__ObjectType__DAG = 1, ns1__ObjectType__COLLECTION = 2};
#endif

#ifndef SOAP_TYPE_ns1__JobType
#define SOAP_TYPE_ns1__JobType (63)
/* ns1:JobType */
enum ns1__JobType {ns1__JobType__NORMAL = 0, ns1__JobType__PARAMETRIC = 1, ns1__JobType__INTERACTIVE = 2, ns1__JobType__MPI = 3, ns1__JobType__PARTITIONABLE = 4, ns1__JobType__CHECKPOINTABLE = 5};
#endif

#ifndef SOAP_TYPE_ns1__JdlType
#define SOAP_TYPE_ns1__JdlType (64)
/* ns1:JdlType */
enum ns1__JdlType {ns1__JdlType__ORIGINAL = 0, ns1__JdlType__REGISTERED = 1};
#endif

#ifndef SOAP_TYPE_jsdl__ProcessorArchitectureEnumeration
#define SOAP_TYPE_jsdl__ProcessorArchitectureEnumeration (65)
/* jsdl:ProcessorArchitectureEnumeration */
enum jsdl__ProcessorArchitectureEnumeration {jsdl__ProcessorArchitectureEnumeration__sparc = 0, jsdl__ProcessorArchitectureEnumeration__powerpc = 1, jsdl__ProcessorArchitectureEnumeration__x86 = 2, jsdl__ProcessorArchitectureEnumeration__x86_USCORE32 = 3, jsdl__ProcessorArchitectureEnumeration__x86_USCORE64 = 4, jsdl__ProcessorArchitectureEnumeration__parisc = 5, jsdl__ProcessorArchitectureEnumeration__mips = 6, jsdl__ProcessorArchitectureEnumeration__ia64 = 7, jsdl__ProcessorArchitectureEnumeration__arm = 8, jsdl__ProcessorArchitectureEnumeration__other = 9};
#endif

#ifndef SOAP_TYPE_jsdl__OperatingSystemTypeEnumeration
#define SOAP_TYPE_jsdl__OperatingSystemTypeEnumeration (66)
/* jsdl:OperatingSystemTypeEnumeration */
enum jsdl__OperatingSystemTypeEnumeration {jsdl__OperatingSystemTypeEnumeration__Unknown = 0, jsdl__OperatingSystemTypeEnumeration__MACOS = 1, jsdl__OperatingSystemTypeEnumeration__ATTUNIX = 2, jsdl__OperatingSystemTypeEnumeration__DGUX = 3, jsdl__OperatingSystemTypeEnumeration__DECNT = 4, jsdl__OperatingSystemTypeEnumeration__Tru64_USCOREUNIX = 5, jsdl__OperatingSystemTypeEnumeration__OpenVMS = 6, jsdl__OperatingSystemTypeEnumeration__HPUX = 7, jsdl__OperatingSystemTypeEnumeration__AIX = 8, jsdl__OperatingSystemTypeEnumeration__MVS = 9, jsdl__OperatingSystemTypeEnumeration__OS400 = 10, jsdl__OperatingSystemTypeEnumeration__OS_USCORE2 = 11, jsdl__OperatingSystemTypeEnumeration__JavaVM = 12, jsdl__OperatingSystemTypeEnumeration__MSDOS = 13, jsdl__OperatingSystemTypeEnumeration__WIN3x = 14, jsdl__OperatingSystemTypeEnumeration__WIN95 = 15, jsdl__OperatingSystemTypeEnumeration__WIN98 = 16, jsdl__OperatingSystemTypeEnumeration__WINNT = 17, jsdl__OperatingSystemTypeEnumeration__WINCE = 18, jsdl__OperatingSystemTypeEnumeration__NCR3000 = 19, jsdl__OperatingSystemTypeEnumeration__NetWare = 20, jsdl__OperatingSystemTypeEnumeration__OSF = 21, jsdl__OperatingSystemTypeEnumeration__DC_USCOREOS = 22, jsdl__OperatingSystemTypeEnumeration__Reliant_USCOREUNIX = 23, jsdl__OperatingSystemTypeEnumeration__SCO_USCOREUnixWare = 24, jsdl__OperatingSystemTypeEnumeration__SCO_USCOREOpenServer = 25, jsdl__OperatingSystemTypeEnumeration__Sequent = 26, jsdl__OperatingSystemTypeEnumeration__IRIX = 27, jsdl__OperatingSystemTypeEnumeration__Solaris = 28, jsdl__OperatingSystemTypeEnumeration__SunOS = 29, jsdl__OperatingSystemTypeEnumeration__U6000 = 30, jsdl__OperatingSystemTypeEnumeration__ASERIES = 31, jsdl__OperatingSystemTypeEnumeration__TandemNSK = 32, jsdl__OperatingSystemTypeEnumeration__TandemNT = 33, jsdl__OperatingSystemTypeEnumeration__BS2000 = 34, jsdl__OperatingSystemTypeEnumeration__LINUX = 35, jsdl__OperatingSystemTypeEnumeration__Lynx = 36, jsdl__OperatingSystemTypeEnumeration__XENIX = 37, jsdl__OperatingSystemTypeEnumeration__VM = 38, jsdl__OperatingSystemTypeEnumeration__Interactive_USCOREUNIX = 39, jsdl__OperatingSystemTypeEnumeration__BSDUNIX = 40, jsdl__OperatingSystemTypeEnumeration__FreeBSD = 41, jsdl__OperatingSystemTypeEnumeration__NetBSD = 42, jsdl__OperatingSystemTypeEnumeration__GNU_USCOREHurd = 43, jsdl__OperatingSystemTypeEnumeration__OS9 = 44, jsdl__OperatingSystemTypeEnumeration__MACH_USCOREKernel = 45, jsdl__OperatingSystemTypeEnumeration__Inferno = 46, jsdl__OperatingSystemTypeEnumeration__QNX = 47, jsdl__OperatingSystemTypeEnumeration__EPOC = 48, jsdl__OperatingSystemTypeEnumeration__IxWorks = 49, jsdl__OperatingSystemTypeEnumeration__VxWorks = 50, jsdl__OperatingSystemTypeEnumeration__MiNT = 51, jsdl__OperatingSystemTypeEnumeration__BeOS = 52, jsdl__OperatingSystemTypeEnumeration__HP_USCOREMPE = 53, jsdl__OperatingSystemTypeEnumeration__NextStep = 54, jsdl__OperatingSystemTypeEnumeration__PalmPilot = 55, jsdl__OperatingSystemTypeEnumeration__Rhapsody = 56, jsdl__OperatingSystemTypeEnumeration__Windows_USCORE2000 = 57, jsdl__OperatingSystemTypeEnumeration__Dedicated = 58, jsdl__OperatingSystemTypeEnumeration__OS_USCORE390 = 59, jsdl__OperatingSystemTypeEnumeration__VSE = 60, jsdl__OperatingSystemTypeEnumeration__TPF = 61, jsdl__OperatingSystemTypeEnumeration__Windows_USCORER_USCOREMe = 62, jsdl__OperatingSystemTypeEnumeration__Caldera_USCOREOpen_USCOREUNIX = 63, jsdl__OperatingSystemTypeEnumeration__OpenBSD = 64, jsdl__OperatingSystemTypeEnumeration__Not_USCOREApplicable = 65, jsdl__OperatingSystemTypeEnumeration__Windows_USCOREXP = 66, jsdl__OperatingSystemTypeEnumeration__z_USCOREOS = 67, jsdl__OperatingSystemTypeEnumeration__other = 68};
#endif

#ifndef SOAP_TYPE_jsdl__FileSystemTypeEnumeration
#define SOAP_TYPE_jsdl__FileSystemTypeEnumeration (67)
/* jsdl:FileSystemTypeEnumeration */
enum jsdl__FileSystemTypeEnumeration {jsdl__FileSystemTypeEnumeration__swap = 0, jsdl__FileSystemTypeEnumeration__temporary = 1, jsdl__FileSystemTypeEnumeration__spool = 2, jsdl__FileSystemTypeEnumeration__normal = 3};
#endif

#ifndef SOAP_TYPE_jsdl__CreationFlagEnumeration
#define SOAP_TYPE_jsdl__CreationFlagEnumeration (68)
/* jsdl:CreationFlagEnumeration */
enum jsdl__CreationFlagEnumeration {jsdl__CreationFlagEnumeration__overwrite = 0, jsdl__CreationFlagEnumeration__append = 1, jsdl__CreationFlagEnumeration__dontOverwrite = 2};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not redeclare here */

#endif

#if 0 /* volatile type: do not redeclare here */

#endif

#ifndef SOAP_TYPE_ns1__JobTypeList
#define SOAP_TYPE_ns1__JobTypeList (14)
/* ns1:JobTypeList */
class SOAP_CMAC ns1__JobTypeList
{
public:
	std::vector<enum ns1__JobType >jobType;	/* optional element of type ns1:JobType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 14; } /* = unique id SOAP_TYPE_ns1__JobTypeList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__JobTypeList(): soap(NULL) { ns1__JobTypeList::soap_default(NULL); }
	virtual ~ns1__JobTypeList() { }
};
#endif

#ifndef SOAP_TYPE_ns1__StringList
#define SOAP_TYPE_ns1__StringList (15)
/* ns1:StringList */
class SOAP_CMAC ns1__StringList
{
public:
	std::vector<std::string >Item;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 15; } /* = unique id SOAP_TYPE_ns1__StringList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__StringList(): soap(NULL) { ns1__StringList::soap_default(NULL); }
	virtual ~ns1__StringList() { }
};
#endif

#ifndef SOAP_TYPE_ns1__DestURIStructType
#define SOAP_TYPE_ns1__DestURIStructType (16)
/* ns1:DestURIStructType */
class SOAP_CMAC ns1__DestURIStructType
{
public:
	std::string id;	/* required element of type xsd:string */
	std::vector<std::string >Item;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE_ns1__DestURIStructType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__DestURIStructType(): soap(NULL) { ns1__DestURIStructType::soap_default(NULL); }
	virtual ~ns1__DestURIStructType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__DestURIsStructType
#define SOAP_TYPE_ns1__DestURIsStructType (17)
/* ns1:DestURIsStructType */
class SOAP_CMAC ns1__DestURIsStructType
{
public:
	std::vector<ns1__DestURIStructType * >Item;	/* required element of type ns1:DestURIStructType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE_ns1__DestURIsStructType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__DestURIsStructType(): soap(NULL) { ns1__DestURIsStructType::soap_default(NULL); }
	virtual ~ns1__DestURIsStructType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__StringAndLongType
#define SOAP_TYPE_ns1__StringAndLongType (18)
/* ns1:StringAndLongType */
class SOAP_CMAC ns1__StringAndLongType
{
public:
	std::string name;	/* required element of type xsd:string */
	LONG64 size;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE_ns1__StringAndLongType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__StringAndLongType(): soap(NULL) { ns1__StringAndLongType::soap_default(NULL); }
	virtual ~ns1__StringAndLongType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__StringAndLongList
#define SOAP_TYPE_ns1__StringAndLongList (19)
/* ns1:StringAndLongList */
class SOAP_CMAC ns1__StringAndLongList
{
public:
	std::vector<ns1__StringAndLongType * >file;	/* optional element of type ns1:StringAndLongType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE_ns1__StringAndLongList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__StringAndLongList(): soap(NULL) { ns1__StringAndLongList::soap_default(NULL); }
	virtual ~ns1__StringAndLongList() { }
};
#endif

#ifndef SOAP_TYPE_ns1__JobStatusStructType
#define SOAP_TYPE_ns1__JobStatusStructType (20)
/* ns1:JobStatusStructType */
class SOAP_CMAC ns1__JobStatusStructType
{
public:
	std::string jobid;	/* required element of type xsd:string */
	std::string status;	/* required element of type xsd:string */
	std::vector<ns1__JobStatusStructType * >childrenJob;	/* optional element of type ns1:JobStatusStructType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE_ns1__JobStatusStructType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__JobStatusStructType(): soap(NULL) { ns1__JobStatusStructType::soap_default(NULL); }
	virtual ~ns1__JobStatusStructType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__JobIdStructType
#define SOAP_TYPE_ns1__JobIdStructType (21)
/* ns1:JobIdStructType */
class SOAP_CMAC ns1__JobIdStructType
{
public:
	std::string id;	/* required element of type xsd:string */
	std::string *name;	/* required element of type xsd:string */
	std::string *path;	/* required element of type xsd:string */
	std::vector<ns1__JobIdStructType * >childrenJob;	/* optional element of type ns1:JobIdStructType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE_ns1__JobIdStructType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__JobIdStructType(): name(NULL), path(NULL), soap(NULL) { ns1__JobIdStructType::soap_default(NULL); }
	virtual ~ns1__JobIdStructType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__GraphStructType
#define SOAP_TYPE_ns1__GraphStructType (22)
/* ns1:GraphStructType */
class SOAP_CMAC ns1__GraphStructType
{
public:
	std::string *name;	/* required element of type xsd:string */
	std::vector<ns1__GraphStructType * >childrenJob;	/* optional element of type ns1:GraphStructType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE_ns1__GraphStructType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__GraphStructType(): name(NULL), soap(NULL) { ns1__GraphStructType::soap_default(NULL); }
	virtual ~ns1__GraphStructType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__VOProxyInfoStructType
#define SOAP_TYPE_ns1__VOProxyInfoStructType (23)
/* ns1:VOProxyInfoStructType */
class SOAP_CMAC ns1__VOProxyInfoStructType
{
public:
	std::string User;	/* required element of type xsd:string */
	std::string UserCA;	/* required element of type xsd:string */
	std::string Server;	/* required element of type xsd:string */
	std::string ServerCA;	/* required element of type xsd:string */
	std::string VOName;	/* required element of type xsd:string */
	std::string URI;	/* required element of type xsd:string */
	std::string StartTime;	/* required element of type xsd:string */
	std::string EndTime;	/* required element of type xsd:string */
	std::vector<std::string >Attribute;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE_ns1__VOProxyInfoStructType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__VOProxyInfoStructType(): soap(NULL) { ns1__VOProxyInfoStructType::soap_default(NULL); }
	virtual ~ns1__VOProxyInfoStructType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ProxyInfoStructType
#define SOAP_TYPE_ns1__ProxyInfoStructType (24)
/* ns1:ProxyInfoStructType */
class SOAP_CMAC ns1__ProxyInfoStructType
{
public:
	std::string Subject;	/* required element of type xsd:string */
	std::string Issuer;	/* required element of type xsd:string */
	std::string Identity;	/* required element of type xsd:string */
	std::string Type;	/* required element of type xsd:string */
	std::string Strength;	/* required element of type xsd:string */
	std::string StartTime;	/* required element of type xsd:string */
	std::string EndTime;	/* required element of type xsd:string */
	std::vector<ns1__VOProxyInfoStructType * >VOsInfo;	/* optional element of type ns1:VOProxyInfoStructType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE_ns1__ProxyInfoStructType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ProxyInfoStructType(): soap(NULL) { ns1__ProxyInfoStructType::soap_default(NULL); }
	virtual ~ns1__ProxyInfoStructType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__BaseFaultType
#define SOAP_TYPE_ns1__BaseFaultType (25)
/* ns1:BaseFaultType */
class SOAP_CMAC ns1__BaseFaultType
{
public:
	std::string methodName;	/* required element of type xsd:string */
	time_t Timestamp;	/* required element of type xsd:dateTime */
	std::string *ErrorCode;	/* optional element of type xsd:string */
	std::string *Description;	/* optional element of type xsd:string */
	std::vector<std::string >FaultCause;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE_ns1__BaseFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__BaseFaultType(): ErrorCode(NULL), Description(NULL), soap(NULL) { ns1__BaseFaultType::soap_default(NULL); }
	virtual ~ns1__BaseFaultType() { }
};
#endif

#ifndef SOAP_TYPE_jsdl__Range_USCOREType
#define SOAP_TYPE_jsdl__Range_USCOREType (37)
/* jsdl:Range_Type */
class SOAP_CMAC jsdl__Range_USCOREType
{
public:
	class jsdl__Boundary_USCOREType *LowerBound;	/* required element of type jsdl:Boundary_Type */
	jsdl__Boundary_USCOREType *UpperBound;	/* required element of type jsdl:Boundary_Type */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique id SOAP_TYPE_jsdl__Range_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__Range_USCOREType(): LowerBound(NULL), UpperBound(NULL), __anyAttribute(NULL), soap(NULL) { jsdl__Range_USCOREType::soap_default(NULL); }
	virtual ~jsdl__Range_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdl__RangeValue_USCOREType
#define SOAP_TYPE_jsdl__RangeValue_USCOREType (38)
/* jsdl:RangeValue_Type */
class SOAP_CMAC jsdl__RangeValue_USCOREType
{
public:
	jsdl__Boundary_USCOREType *UpperBoundedRange;	/* optional element of type jsdl:Boundary_Type */
	jsdl__Boundary_USCOREType *LowerBoundedRange;	/* optional element of type jsdl:Boundary_Type */
	std::vector<class jsdl__Exact_USCOREType * >Exact;	/* optional element of type jsdl:Exact_Type */
	std::vector<jsdl__Range_USCOREType * >Range;	/* optional element of type jsdl:Range_Type */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique id SOAP_TYPE_jsdl__RangeValue_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__RangeValue_USCOREType(): UpperBoundedRange(NULL), LowerBoundedRange(NULL), __anyAttribute(NULL), soap(NULL) { jsdl__RangeValue_USCOREType::soap_default(NULL); }
	virtual ~jsdl__RangeValue_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdl__JobDefinition_USCOREType
#define SOAP_TYPE_jsdl__JobDefinition_USCOREType (39)
/* jsdl:JobDefinition_Type */
class SOAP_CMAC jsdl__JobDefinition_USCOREType
{
public:
	class jsdl__JobDescription_USCOREType *JobDescription;	/* required element of type jsdl:JobDescription_Type */
	std::vector<char * >__any;
	std::string *id;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique id SOAP_TYPE_jsdl__JobDefinition_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__JobDefinition_USCOREType(): JobDescription(NULL), id(NULL), __anyAttribute(NULL), soap(NULL) { jsdl__JobDefinition_USCOREType::soap_default(NULL); }
	virtual ~jsdl__JobDefinition_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdl__JobDescription_USCOREType
#define SOAP_TYPE_jsdl__JobDescription_USCOREType (40)
/* jsdl:JobDescription_Type */
class SOAP_CMAC jsdl__JobDescription_USCOREType
{
public:
	class jsdl__JobIdentification_USCOREType *JobIdentification;	/* optional element of type jsdl:JobIdentification_Type */
	class jsdl__Application_USCOREType *Application;	/* optional element of type jsdl:Application_Type */
	class jsdl__Resources_USCOREType *Resources;	/* optional element of type jsdl:Resources_Type */
	std::vector<class jsdl__DataStaging_USCOREType * >DataStaging;	/* optional element of type jsdl:DataStaging_Type */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique id SOAP_TYPE_jsdl__JobDescription_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__JobDescription_USCOREType(): JobIdentification(NULL), Application(NULL), Resources(NULL), __anyAttribute(NULL), soap(NULL) { jsdl__JobDescription_USCOREType::soap_default(NULL); }
	virtual ~jsdl__JobDescription_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdl__JobIdentification_USCOREType
#define SOAP_TYPE_jsdl__JobIdentification_USCOREType (41)
/* jsdl:JobIdentification_Type */
class SOAP_CMAC jsdl__JobIdentification_USCOREType
{
public:
	std::string *JobName;	/* optional element of type xsd:string */
	std::string *Description;	/* optional element of type jsdl:Description_Type */
	std::vector<std::string >JobAnnotation;	/* optional element of type xsd:string */
	std::vector<std::string >JobProject;	/* optional element of type xsd:string */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE_jsdl__JobIdentification_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__JobIdentification_USCOREType(): JobName(NULL), Description(NULL), __anyAttribute(NULL), soap(NULL) { jsdl__JobIdentification_USCOREType::soap_default(NULL); }
	virtual ~jsdl__JobIdentification_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdl__Application_USCOREType
#define SOAP_TYPE_jsdl__Application_USCOREType (42)
/* jsdl:Application_Type */
class SOAP_CMAC jsdl__Application_USCOREType
{
public:
	std::string *ApplicationName;	/* optional element of type xsd:string */
	std::string *ApplicationVersion;	/* optional element of type xsd:string */
	std::string *Description;	/* optional element of type jsdl:Description_Type */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique id SOAP_TYPE_jsdl__Application_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__Application_USCOREType(): ApplicationName(NULL), ApplicationVersion(NULL), Description(NULL), __anyAttribute(NULL), soap(NULL) { jsdl__Application_USCOREType::soap_default(NULL); }
	virtual ~jsdl__Application_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdl__Resources_USCOREType
#define SOAP_TYPE_jsdl__Resources_USCOREType (43)
/* jsdl:Resources_Type */
class SOAP_CMAC jsdl__Resources_USCOREType
{
public:
	class jsdl__CandidateHosts_USCOREType *CandidateHosts;	/* optional element of type jsdl:CandidateHosts_Type */
	std::vector<class jsdl__FileSystem_USCOREType * >FileSystem;	/* optional element of type jsdl:FileSystem_Type */
	bool *ExclusiveExecution;	/* optional element of type xsd:boolean */
	class jsdl__OperatingSystem_USCOREType *OperatingSystem;	/* optional element of type jsdl:OperatingSystem_Type */
	class jsdl__CPUArchitecture_USCOREType *CPUArchitecture;	/* optional element of type jsdl:CPUArchitecture_Type */
	jsdl__RangeValue_USCOREType *IndividualCPUSpeed;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *IndividualCPUTime;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *IndividualCPUCount;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *IndividualNetworkBandwidth;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *IndividualPhysicalMemory;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *IndividualVirtualMemory;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *IndividualDiskSpace;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *TotalCPUTime;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *TotalCPUCount;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *TotalPhysicalMemory;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *TotalVirtualMemory;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *TotalDiskSpace;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *TotalResourceCount;	/* optional element of type jsdl:RangeValue_Type */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique id SOAP_TYPE_jsdl__Resources_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__Resources_USCOREType(): CandidateHosts(NULL), ExclusiveExecution(NULL), OperatingSystem(NULL), CPUArchitecture(NULL), IndividualCPUSpeed(NULL), IndividualCPUTime(NULL), IndividualCPUCount(NULL), IndividualNetworkBandwidth(NULL), IndividualPhysicalMemory(NULL), IndividualVirtualMemory(NULL), IndividualDiskSpace(NULL), TotalCPUTime(NULL), TotalCPUCount(NULL), TotalPhysicalMemory(NULL), TotalVirtualMemory(NULL), TotalDiskSpace(NULL), TotalResourceCount(NULL), __anyAttribute(NULL), soap(NULL) { jsdl__Resources_USCOREType::soap_default(NULL); }
	virtual ~jsdl__Resources_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdl__CandidateHosts_USCOREType
#define SOAP_TYPE_jsdl__CandidateHosts_USCOREType (44)
/* jsdl:CandidateHosts_Type */
class SOAP_CMAC jsdl__CandidateHosts_USCOREType
{
public:
	std::vector<std::string >HostName;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique id SOAP_TYPE_jsdl__CandidateHosts_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__CandidateHosts_USCOREType(): soap(NULL) { jsdl__CandidateHosts_USCOREType::soap_default(NULL); }
	virtual ~jsdl__CandidateHosts_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdl__CPUArchitecture_USCOREType
#define SOAP_TYPE_jsdl__CPUArchitecture_USCOREType (45)
/* jsdl:CPUArchitecture_Type */
class SOAP_CMAC jsdl__CPUArchitecture_USCOREType
{
public:
	enum jsdl__ProcessorArchitectureEnumeration CPUArchitectureName;	/* required element of type jsdl:ProcessorArchitectureEnumeration */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique id SOAP_TYPE_jsdl__CPUArchitecture_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__CPUArchitecture_USCOREType(): __anyAttribute(NULL), soap(NULL) { jsdl__CPUArchitecture_USCOREType::soap_default(NULL); }
	virtual ~jsdl__CPUArchitecture_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdl__FileSystem_USCOREType
#define SOAP_TYPE_jsdl__FileSystem_USCOREType (46)
/* jsdl:FileSystem_Type */
class SOAP_CMAC jsdl__FileSystem_USCOREType
{
public:
	enum jsdl__FileSystemTypeEnumeration *FileSystemType;	/* optional element of type jsdl:FileSystemTypeEnumeration */
	std::string *Description;	/* optional element of type jsdl:Description_Type */
	std::string *MountPoint;	/* optional element of type xsd:string */
	jsdl__RangeValue_USCOREType *DiskSpace;	/* optional element of type jsdl:RangeValue_Type */
	std::vector<char * >__any;
	std::string name;	/* required attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique id SOAP_TYPE_jsdl__FileSystem_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__FileSystem_USCOREType(): FileSystemType(NULL), Description(NULL), MountPoint(NULL), DiskSpace(NULL), __anyAttribute(NULL), soap(NULL) { jsdl__FileSystem_USCOREType::soap_default(NULL); }
	virtual ~jsdl__FileSystem_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdl__OperatingSystem_USCOREType
#define SOAP_TYPE_jsdl__OperatingSystem_USCOREType (47)
/* jsdl:OperatingSystem_Type */
class SOAP_CMAC jsdl__OperatingSystem_USCOREType
{
public:
	class jsdl__OperatingSystemType_USCOREType *OperatingSystemType;	/* optional element of type jsdl:OperatingSystemType_Type */
	std::string *OperatingSystemVersion;	/* optional element of type xsd:string */
	std::string *Description;	/* optional element of type jsdl:Description_Type */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 47; } /* = unique id SOAP_TYPE_jsdl__OperatingSystem_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__OperatingSystem_USCOREType(): OperatingSystemType(NULL), OperatingSystemVersion(NULL), Description(NULL), __anyAttribute(NULL), soap(NULL) { jsdl__OperatingSystem_USCOREType::soap_default(NULL); }
	virtual ~jsdl__OperatingSystem_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdl__OperatingSystemType_USCOREType
#define SOAP_TYPE_jsdl__OperatingSystemType_USCOREType (48)
/* jsdl:OperatingSystemType_Type */
class SOAP_CMAC jsdl__OperatingSystemType_USCOREType
{
public:
	enum jsdl__OperatingSystemTypeEnumeration OperatingSystemName;	/* required element of type jsdl:OperatingSystemTypeEnumeration */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 48; } /* = unique id SOAP_TYPE_jsdl__OperatingSystemType_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__OperatingSystemType_USCOREType(): __anyAttribute(NULL), soap(NULL) { jsdl__OperatingSystemType_USCOREType::soap_default(NULL); }
	virtual ~jsdl__OperatingSystemType_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdl__DataStaging_USCOREType
#define SOAP_TYPE_jsdl__DataStaging_USCOREType (49)
/* jsdl:DataStaging_Type */
class SOAP_CMAC jsdl__DataStaging_USCOREType
{
public:
	std::string FileName;	/* required element of type xsd:string */
	std::string *FilesystemName;	/* optional element of type xsd:NCName */
	enum jsdl__CreationFlagEnumeration CreationFlag;	/* required element of type jsdl:CreationFlagEnumeration */
	bool *DeleteOnTermination;	/* optional element of type xsd:boolean */
	class jsdl__SourceTarget_USCOREType *Source;	/* optional element of type jsdl:SourceTarget_Type */
	jsdl__SourceTarget_USCOREType *Target;	/* optional element of type jsdl:SourceTarget_Type */
	std::vector<char * >__any;
	std::string *name;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 49; } /* = unique id SOAP_TYPE_jsdl__DataStaging_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__DataStaging_USCOREType(): FilesystemName(NULL), DeleteOnTermination(NULL), Source(NULL), Target(NULL), name(NULL), __anyAttribute(NULL), soap(NULL) { jsdl__DataStaging_USCOREType::soap_default(NULL); }
	virtual ~jsdl__DataStaging_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdl__SourceTarget_USCOREType
#define SOAP_TYPE_jsdl__SourceTarget_USCOREType (50)
/* jsdl:SourceTarget_Type */
class SOAP_CMAC jsdl__SourceTarget_USCOREType
{
public:
	std::string *URI;	/* optional element of type xsd:anyURI */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 50; } /* = unique id SOAP_TYPE_jsdl__SourceTarget_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__SourceTarget_USCOREType(): URI(NULL), __anyAttribute(NULL), soap(NULL) { jsdl__SourceTarget_USCOREType::soap_default(NULL); }
	virtual ~jsdl__SourceTarget_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdlposix__POSIXApplication_USCOREType
#define SOAP_TYPE_jsdlposix__POSIXApplication_USCOREType (58)
/* jsdlposix:POSIXApplication_Type */
class SOAP_CMAC jsdlposix__POSIXApplication_USCOREType
{
public:
	class jsdlposix__FileName_USCOREType *Executable;	/* optional element of type jsdlposix:FileName_Type */
	std::vector<class jsdlposix__Argument_USCOREType * >Argument;	/* optional element of type jsdlposix:Argument_Type */
	jsdlposix__FileName_USCOREType *Input;	/* optional element of type jsdlposix:FileName_Type */
	jsdlposix__FileName_USCOREType *Output;	/* optional element of type jsdlposix:FileName_Type */
	jsdlposix__FileName_USCOREType *Error;	/* optional element of type jsdlposix:FileName_Type */
	class jsdlposix__DirectoryName_USCOREType *WorkingDirectory;	/* optional element of type jsdlposix:DirectoryName_Type */
	std::vector<class jsdlposix__Environment_USCOREType * >Environment;	/* optional element of type jsdlposix:Environment_Type */
	class jsdlposix__Limits_USCOREType *WallTimeLimit;	/* optional element of type jsdlposix:Limits_Type */
	jsdlposix__Limits_USCOREType *FileSizeLimit;	/* optional element of type jsdlposix:Limits_Type */
	jsdlposix__Limits_USCOREType *CoreDumpLimit;	/* optional element of type jsdlposix:Limits_Type */
	jsdlposix__Limits_USCOREType *DataSegmentLimit;	/* optional element of type jsdlposix:Limits_Type */
	jsdlposix__Limits_USCOREType *LockedMemoryLimit;	/* optional element of type jsdlposix:Limits_Type */
	jsdlposix__Limits_USCOREType *MemoryLimit;	/* optional element of type jsdlposix:Limits_Type */
	jsdlposix__Limits_USCOREType *OpenDescriptorsLimit;	/* optional element of type jsdlposix:Limits_Type */
	jsdlposix__Limits_USCOREType *PipeSizeLimit;	/* optional element of type jsdlposix:Limits_Type */
	jsdlposix__Limits_USCOREType *StackSizeLimit;	/* optional element of type jsdlposix:Limits_Type */
	jsdlposix__Limits_USCOREType *CPUTimeLimit;	/* optional element of type jsdlposix:Limits_Type */
	jsdlposix__Limits_USCOREType *ProcessCountLimit;	/* optional element of type jsdlposix:Limits_Type */
	jsdlposix__Limits_USCOREType *VirtualMemoryLimit;	/* optional element of type jsdlposix:Limits_Type */
	jsdlposix__Limits_USCOREType *ThreadCountLimit;	/* optional element of type jsdlposix:Limits_Type */
	class jsdlposix__UserName_USCOREType *UserName;	/* optional element of type jsdlposix:UserName_Type */
	class jsdlposix__GroupName_USCOREType *GroupName;	/* optional element of type jsdlposix:GroupName_Type */
	std::string *name;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 58; } /* = unique id SOAP_TYPE_jsdlposix__POSIXApplication_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdlposix__POSIXApplication_USCOREType(): Executable(NULL), Input(NULL), Output(NULL), Error(NULL), WorkingDirectory(NULL), WallTimeLimit(NULL), FileSizeLimit(NULL), CoreDumpLimit(NULL), DataSegmentLimit(NULL), LockedMemoryLimit(NULL), MemoryLimit(NULL), OpenDescriptorsLimit(NULL), PipeSizeLimit(NULL), StackSizeLimit(NULL), CPUTimeLimit(NULL), ProcessCountLimit(NULL), VirtualMemoryLimit(NULL), ThreadCountLimit(NULL), UserName(NULL), GroupName(NULL), name(NULL), __anyAttribute(NULL), soap(NULL) { jsdlposix__POSIXApplication_USCOREType::soap_default(NULL); }
	virtual ~jsdlposix__POSIXApplication_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_delegationns__NewProxyReq
#define SOAP_TYPE_delegationns__NewProxyReq (59)
/* delegationns:NewProxyReq */
class SOAP_CMAC delegationns__NewProxyReq
{
public:
	std::string *proxyRequest;	/* optional element of type xsd:string */
	std::string *delegationID;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 59; } /* = unique id SOAP_TYPE_delegationns__NewProxyReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         delegationns__NewProxyReq(): proxyRequest(NULL), delegationID(NULL), soap(NULL) { delegationns__NewProxyReq::soap_default(NULL); }
	virtual ~delegationns__NewProxyReq() { }
};
#endif

#ifndef SOAP_TYPE__delegationns__DelegationException
#define SOAP_TYPE__delegationns__DelegationException (60)
/* delegationns:DelegationException */
class SOAP_CMAC _delegationns__DelegationException
{
public:
	std::string *msg;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 60; } /* = unique id SOAP_TYPE__delegationns__DelegationException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _delegationns__DelegationException(): msg(NULL), soap(NULL) { _delegationns__DelegationException::soap_default(NULL); }
	virtual ~_delegationns__DelegationException() { }
};
#endif

#ifndef SOAP_TYPE_delegation1__DelegationExceptionType
#define SOAP_TYPE_delegation1__DelegationExceptionType (61)
/* delegation1:DelegationExceptionType */
class SOAP_CMAC delegation1__DelegationExceptionType
{
public:
	std::string *message;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 61; } /* = unique id SOAP_TYPE_delegation1__DelegationExceptionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         delegation1__DelegationExceptionType(): message(NULL), soap(NULL) { delegation1__DelegationExceptionType::soap_default(NULL); }
	virtual ~delegation1__DelegationExceptionType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__GenericFaultType
#define SOAP_TYPE_ns1__GenericFaultType (26)
/* ns1:GenericFaultType */
class SOAP_CMAC ns1__GenericFaultType : public ns1__BaseFaultType
{
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE_ns1__GenericFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__GenericFaultType() { ns1__GenericFaultType::soap_default(NULL); }
	virtual ~ns1__GenericFaultType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__AuthenticationFaultType
#define SOAP_TYPE_ns1__AuthenticationFaultType (27)
/* ns1:AuthenticationFaultType */
class SOAP_CMAC ns1__AuthenticationFaultType : public ns1__BaseFaultType
{
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE_ns1__AuthenticationFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__AuthenticationFaultType() { ns1__AuthenticationFaultType::soap_default(NULL); }
	virtual ~ns1__AuthenticationFaultType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__AuthorizationFaultType
#define SOAP_TYPE_ns1__AuthorizationFaultType (28)
/* ns1:AuthorizationFaultType */
class SOAP_CMAC ns1__AuthorizationFaultType : public ns1__BaseFaultType
{
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE_ns1__AuthorizationFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__AuthorizationFaultType() { ns1__AuthorizationFaultType::soap_default(NULL); }
	virtual ~ns1__AuthorizationFaultType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__InvalidArgumentFaultType
#define SOAP_TYPE_ns1__InvalidArgumentFaultType (29)
/* ns1:InvalidArgumentFaultType */
class SOAP_CMAC ns1__InvalidArgumentFaultType : public ns1__BaseFaultType
{
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE_ns1__InvalidArgumentFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__InvalidArgumentFaultType() { ns1__InvalidArgumentFaultType::soap_default(NULL); }
	virtual ~ns1__InvalidArgumentFaultType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__GetQuotaManagementFaultType
#define SOAP_TYPE_ns1__GetQuotaManagementFaultType (30)
/* ns1:GetQuotaManagementFaultType */
class SOAP_CMAC ns1__GetQuotaManagementFaultType : public ns1__BaseFaultType
{
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE_ns1__GetQuotaManagementFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__GetQuotaManagementFaultType() { ns1__GetQuotaManagementFaultType::soap_default(NULL); }
	virtual ~ns1__GetQuotaManagementFaultType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__NoSuitableResourcesFaultType
#define SOAP_TYPE_ns1__NoSuitableResourcesFaultType (31)
/* ns1:NoSuitableResourcesFaultType */
class SOAP_CMAC ns1__NoSuitableResourcesFaultType : public ns1__BaseFaultType
{
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE_ns1__NoSuitableResourcesFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__NoSuitableResourcesFaultType() { ns1__NoSuitableResourcesFaultType::soap_default(NULL); }
	virtual ~ns1__NoSuitableResourcesFaultType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__JobUnknownFaultType
#define SOAP_TYPE_ns1__JobUnknownFaultType (32)
/* ns1:JobUnknownFaultType */
class SOAP_CMAC ns1__JobUnknownFaultType : public ns1__BaseFaultType
{
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE_ns1__JobUnknownFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__JobUnknownFaultType() { ns1__JobUnknownFaultType::soap_default(NULL); }
	virtual ~ns1__JobUnknownFaultType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__OperationNotAllowedFaultType
#define SOAP_TYPE_ns1__OperationNotAllowedFaultType (33)
/* ns1:OperationNotAllowedFaultType */
class SOAP_CMAC ns1__OperationNotAllowedFaultType : public ns1__BaseFaultType
{
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE_ns1__OperationNotAllowedFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__OperationNotAllowedFaultType() { ns1__OperationNotAllowedFaultType::soap_default(NULL); }
	virtual ~ns1__OperationNotAllowedFaultType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ServerOverloadedFaultType
#define SOAP_TYPE_ns1__ServerOverloadedFaultType (34)
/* ns1:ServerOverloadedFaultType */
class SOAP_CMAC ns1__ServerOverloadedFaultType : public ns1__BaseFaultType
{
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE_ns1__ServerOverloadedFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ServerOverloadedFaultType() { ns1__ServerOverloadedFaultType::soap_default(NULL); }
	virtual ~ns1__ServerOverloadedFaultType() { }
};
#endif

#ifndef SOAP_TYPE_jsdl__Boundary_USCOREType
#define SOAP_TYPE_jsdl__Boundary_USCOREType (35)
/* Primitive jsdl:Boundary_Type schema type: */
class SOAP_CMAC jsdl__Boundary_USCOREType
{
public:
	double __item;
	bool *exclusiveBound;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE_jsdl__Boundary_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__Boundary_USCOREType(): exclusiveBound(NULL), __anyAttribute(NULL), soap(NULL) { jsdl__Boundary_USCOREType::soap_default(NULL); }
	virtual ~jsdl__Boundary_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdl__Exact_USCOREType
#define SOAP_TYPE_jsdl__Exact_USCOREType (36)
/* Primitive jsdl:Exact_Type schema type: */
class SOAP_CMAC jsdl__Exact_USCOREType
{
public:
	double __item;
	double *epsilon;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 36; } /* = unique id SOAP_TYPE_jsdl__Exact_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__Exact_USCOREType(): epsilon(NULL), __anyAttribute(NULL), soap(NULL) { jsdl__Exact_USCOREType::soap_default(NULL); }
	virtual ~jsdl__Exact_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdlposix__Environment_USCOREType
#define SOAP_TYPE_jsdlposix__Environment_USCOREType (51)
/* Primitive jsdlposix:Environment_Type schema type: */
class SOAP_CMAC jsdlposix__Environment_USCOREType
{
public:
	std::string __item;
	std::string name;	/* required attribute */
	std::string *filesystemName;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 51; } /* = unique id SOAP_TYPE_jsdlposix__Environment_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdlposix__Environment_USCOREType(): filesystemName(NULL), __anyAttribute(NULL), soap(NULL) { jsdlposix__Environment_USCOREType::soap_default(NULL); }
	virtual ~jsdlposix__Environment_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdlposix__Argument_USCOREType
#define SOAP_TYPE_jsdlposix__Argument_USCOREType (52)
/* Primitive jsdlposix:Argument_Type schema type: */
class SOAP_CMAC jsdlposix__Argument_USCOREType
{
public:
	std::string __item;
	std::string *filesystemName;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 52; } /* = unique id SOAP_TYPE_jsdlposix__Argument_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdlposix__Argument_USCOREType(): filesystemName(NULL), __anyAttribute(NULL), soap(NULL) { jsdlposix__Argument_USCOREType::soap_default(NULL); }
	virtual ~jsdlposix__Argument_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdlposix__FileName_USCOREType
#define SOAP_TYPE_jsdlposix__FileName_USCOREType (53)
/* Primitive jsdlposix:FileName_Type schema type: */
class SOAP_CMAC jsdlposix__FileName_USCOREType
{
public:
	std::string __item;
	std::string *filesystemName;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 53; } /* = unique id SOAP_TYPE_jsdlposix__FileName_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdlposix__FileName_USCOREType(): filesystemName(NULL), __anyAttribute(NULL), soap(NULL) { jsdlposix__FileName_USCOREType::soap_default(NULL); }
	virtual ~jsdlposix__FileName_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdlposix__DirectoryName_USCOREType
#define SOAP_TYPE_jsdlposix__DirectoryName_USCOREType (54)
/* Primitive jsdlposix:DirectoryName_Type schema type: */
class SOAP_CMAC jsdlposix__DirectoryName_USCOREType
{
public:
	std::string __item;
	std::string *filesystemName;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 54; } /* = unique id SOAP_TYPE_jsdlposix__DirectoryName_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdlposix__DirectoryName_USCOREType(): filesystemName(NULL), __anyAttribute(NULL), soap(NULL) { jsdlposix__DirectoryName_USCOREType::soap_default(NULL); }
	virtual ~jsdlposix__DirectoryName_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdlposix__Limits_USCOREType
#define SOAP_TYPE_jsdlposix__Limits_USCOREType (55)
/* Primitive jsdlposix:Limits_Type schema type: */
class SOAP_CMAC jsdlposix__Limits_USCOREType
{
public:
	std::string __item;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 55; } /* = unique id SOAP_TYPE_jsdlposix__Limits_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdlposix__Limits_USCOREType(): __anyAttribute(NULL), soap(NULL) { jsdlposix__Limits_USCOREType::soap_default(NULL); }
	virtual ~jsdlposix__Limits_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdlposix__UserName_USCOREType
#define SOAP_TYPE_jsdlposix__UserName_USCOREType (56)
/* Primitive jsdlposix:UserName_Type schema type: */
class SOAP_CMAC jsdlposix__UserName_USCOREType
{
public:
	std::string __item;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 56; } /* = unique id SOAP_TYPE_jsdlposix__UserName_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdlposix__UserName_USCOREType(): __anyAttribute(NULL), soap(NULL) { jsdlposix__UserName_USCOREType::soap_default(NULL); }
	virtual ~jsdlposix__UserName_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdlposix__GroupName_USCOREType
#define SOAP_TYPE_jsdlposix__GroupName_USCOREType (57)
/* Primitive jsdlposix:GroupName_Type schema type: */
class SOAP_CMAC jsdlposix__GroupName_USCOREType
{
public:
	std::string __item;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 57; } /* = unique id SOAP_TYPE_jsdlposix__GroupName_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdlposix__GroupName_USCOREType(): __anyAttribute(NULL), soap(NULL) { jsdlposix__GroupName_USCOREType::soap_default(NULL); }
	virtual ~jsdlposix__GroupName_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (126)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	delegation1__DelegationExceptionType *delegation1__DelegationException;	/* optional element of type delegation1:DelegationExceptionType */
	_delegationns__DelegationException *delegationns__DelegationException;	/* optional element of type delegationns:DelegationException */
	ns1__AuthenticationFaultType *ns1__AuthenticationFault;	/* optional element of type ns1:AuthenticationFaultType */
	ns1__AuthorizationFaultType *ns1__AuthorizationFault;	/* optional element of type ns1:AuthorizationFaultType */
	ns1__GenericFaultType *ns1__GenericFault;	/* optional element of type ns1:GenericFaultType */
	ns1__GetQuotaManagementFaultType *ns1__GetQuotaManagementFault;	/* optional element of type ns1:GetQuotaManagementFaultType */
	ns1__InvalidArgumentFaultType *ns1__InvalidArgumentFault;	/* optional element of type ns1:InvalidArgumentFaultType */
	ns1__JobUnknownFaultType *ns1__JobUnknownFault;	/* optional element of type ns1:JobUnknownFaultType */
	ns1__NoSuitableResourcesFaultType *ns1__NoSuitableResourcesFault;	/* optional element of type ns1:NoSuitableResourcesFaultType */
	ns1__OperationNotAllowedFaultType *ns1__OperationNotAllowedFault;	/* optional element of type ns1:OperationNotAllowedFaultType */
	ns1__ServerOverloadedFaultType *ns1__ServerOverloadedFault;	/* optional element of type ns1:ServerOverloadedFaultType */
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
	char *__any;
};
#endif

#ifndef SOAP_TYPE_delegation1__getProxyReqResponse
#define SOAP_TYPE_delegation1__getProxyReqResponse (140)
/* delegation1:getProxyReqResponse */
struct delegation1__getProxyReqResponse
{
public:
	std::string _getProxyReqReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_delegation1__getProxyReq
#define SOAP_TYPE_delegation1__getProxyReq (143)
/* delegation1:getProxyReq */
struct delegation1__getProxyReq
{
public:
	std::string _delegationID;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_delegation1__putProxyResponse
#define SOAP_TYPE_delegation1__putProxyResponse (144)
/* delegation1:putProxyResponse */
struct delegation1__putProxyResponse
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_delegation1__putProxy
#define SOAP_TYPE_delegation1__putProxy (147)
/* delegation1:putProxy */
struct delegation1__putProxy
{
public:
	std::string _delegationID;	/* required element of type xsd:string */
	std::string _proxy;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_delegationns__getVersionResponse
#define SOAP_TYPE_delegationns__getVersionResponse (148)
/* delegationns:getVersionResponse */
struct delegationns__getVersionResponse
{
public:
	std::string getVersionReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_delegationns__getVersion
#define SOAP_TYPE_delegationns__getVersion (151)
/* delegationns:getVersion */
struct delegationns__getVersion
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_delegationns__getInterfaceVersionResponse
#define SOAP_TYPE_delegationns__getInterfaceVersionResponse (152)
/* delegationns:getInterfaceVersionResponse */
struct delegationns__getInterfaceVersionResponse
{
public:
	std::string getInterfaceVersionReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_delegationns__getInterfaceVersion
#define SOAP_TYPE_delegationns__getInterfaceVersion (155)
/* delegationns:getInterfaceVersion */
struct delegationns__getInterfaceVersion
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_delegationns__getServiceMetadataResponse
#define SOAP_TYPE_delegationns__getServiceMetadataResponse (156)
/* delegationns:getServiceMetadataResponse */
struct delegationns__getServiceMetadataResponse
{
public:
	std::string _getServiceMetadataReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_delegationns__getServiceMetadata
#define SOAP_TYPE_delegationns__getServiceMetadata (159)
/* delegationns:getServiceMetadata */
struct delegationns__getServiceMetadata
{
public:
	std::string _key;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_delegationns__getProxyReqResponse
#define SOAP_TYPE_delegationns__getProxyReqResponse (160)
/* delegationns:getProxyReqResponse */
struct delegationns__getProxyReqResponse
{
public:
	std::string _getProxyReqReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_delegationns__getProxyReq
#define SOAP_TYPE_delegationns__getProxyReq (163)
/* delegationns:getProxyReq */
struct delegationns__getProxyReq
{
public:
	std::string _delegationID;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_delegationns__getNewProxyReqResponse
#define SOAP_TYPE_delegationns__getNewProxyReqResponse (164)
/* delegationns:getNewProxyReqResponse */
struct delegationns__getNewProxyReqResponse
{
public:
	delegationns__NewProxyReq *getNewProxyReqReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type delegationns:NewProxyReq */
};
#endif

#ifndef SOAP_TYPE_delegationns__getNewProxyReq
#define SOAP_TYPE_delegationns__getNewProxyReq (168)
/* delegationns:getNewProxyReq */
struct delegationns__getNewProxyReq
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_delegationns__renewProxyReqResponse
#define SOAP_TYPE_delegationns__renewProxyReqResponse (169)
/* delegationns:renewProxyReqResponse */
struct delegationns__renewProxyReqResponse
{
public:
	std::string _renewProxyReqReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_delegationns__renewProxyReq
#define SOAP_TYPE_delegationns__renewProxyReq (172)
/* delegationns:renewProxyReq */
struct delegationns__renewProxyReq
{
public:
	std::string _delegationID;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_delegationns__putProxyResponse
#define SOAP_TYPE_delegationns__putProxyResponse (173)
/* delegationns:putProxyResponse */
struct delegationns__putProxyResponse
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_delegationns__putProxy
#define SOAP_TYPE_delegationns__putProxy (176)
/* delegationns:putProxy */
struct delegationns__putProxy
{
public:
	std::string _delegationID;	/* required element of type xsd:string */
	std::string _proxy;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_delegationns__getTerminationTimeResponse
#define SOAP_TYPE_delegationns__getTerminationTimeResponse (177)
/* delegationns:getTerminationTimeResponse */
struct delegationns__getTerminationTimeResponse
{
public:
	time_t _getTerminationTimeReturn;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:dateTime */
};
#endif

#ifndef SOAP_TYPE_delegationns__getTerminationTime
#define SOAP_TYPE_delegationns__getTerminationTime (180)
/* delegationns:getTerminationTime */
struct delegationns__getTerminationTime
{
public:
	std::string _delegationID;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_delegationns__destroyResponse
#define SOAP_TYPE_delegationns__destroyResponse (181)
/* delegationns:destroyResponse */
struct delegationns__destroyResponse
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_delegationns__destroy
#define SOAP_TYPE_delegationns__destroy (184)
/* delegationns:destroy */
struct delegationns__destroy
{
public:
	std::string _delegationID;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__getProxyReqResponse
#define SOAP_TYPE_ns1__getProxyReqResponse (185)
/* ns1:getProxyReqResponse */
struct ns1__getProxyReqResponse
{
public:
	std::string _request;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__getProxyReq
#define SOAP_TYPE_ns1__getProxyReq (188)
/* ns1:getProxyReq */
struct ns1__getProxyReq
{
public:
	std::string _delegationID;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__putProxyResponse
#define SOAP_TYPE_ns1__putProxyResponse (189)
/* ns1:putProxyResponse */
struct ns1__putProxyResponse
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns1__putProxy
#define SOAP_TYPE_ns1__putProxy (192)
/* ns1:putProxy */
struct ns1__putProxy
{
public:
	std::string _delegationID;	/* required element of type xsd:string */
	std::string _proxy;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__getVersionResponse
#define SOAP_TYPE_ns1__getVersionResponse (193)
/* ns1:getVersionResponse */
struct ns1__getVersionResponse
{
public:
	std::string version;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__getVersion
#define SOAP_TYPE_ns1__getVersion (196)
/* ns1:getVersion */
struct ns1__getVersion
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns1__getJDLResponse
#define SOAP_TYPE_ns1__getJDLResponse (197)
/* ns1:getJDLResponse */
struct ns1__getJDLResponse
{
public:
	std::string _jdl;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__getJDL
#define SOAP_TYPE_ns1__getJDL (200)
/* ns1:getJDL */
struct ns1__getJDL
{
public:
	std::string _jobId;	/* required element of type xsd:string */
	enum ns1__JdlType _type;	/* required element of type ns1:JdlType */
};
#endif

#ifndef SOAP_TYPE_ns1__jobRegisterResponse
#define SOAP_TYPE_ns1__jobRegisterResponse (201)
/* ns1:jobRegisterResponse */
struct ns1__jobRegisterResponse
{
public:
	ns1__JobIdStructType *_jobIdStruct;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:JobIdStructType */
};
#endif

#ifndef SOAP_TYPE_ns1__jobRegister
#define SOAP_TYPE_ns1__jobRegister (204)
/* ns1:jobRegister */
struct ns1__jobRegister
{
public:
	std::string _jdl;	/* required element of type xsd:string */
	std::string _delegationId;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__jobRegisterJSDLResponse
#define SOAP_TYPE_ns1__jobRegisterJSDLResponse (205)
/* ns1:jobRegisterJSDLResponse */
struct ns1__jobRegisterJSDLResponse
{
public:
	ns1__JobIdStructType *_jobIdStruct;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:JobIdStructType */
};
#endif

#ifndef SOAP_TYPE_ns1__jobRegisterJSDL
#define SOAP_TYPE_ns1__jobRegisterJSDL (209)
/* ns1:jobRegisterJSDL */
struct ns1__jobRegisterJSDL
{
public:
	jsdl__JobDefinition_USCOREType *_jsdl;	/* optional element of type jsdl:JobDefinition_Type */
	std::string _delegationId;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__jobStartResponse
#define SOAP_TYPE_ns1__jobStartResponse (210)
/* ns1:jobStartResponse */
struct ns1__jobStartResponse
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns1__jobStart
#define SOAP_TYPE_ns1__jobStart (213)
/* ns1:jobStart */
struct ns1__jobStart
{
public:
	std::string _jobId;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__jobSubmitResponse
#define SOAP_TYPE_ns1__jobSubmitResponse (214)
/* ns1:jobSubmitResponse */
struct ns1__jobSubmitResponse
{
public:
	ns1__JobIdStructType *_jobIdStruct;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:JobIdStructType */
};
#endif

#ifndef SOAP_TYPE_ns1__jobSubmit
#define SOAP_TYPE_ns1__jobSubmit (217)
/* ns1:jobSubmit */
struct ns1__jobSubmit
{
public:
	std::string _jdl;	/* required element of type xsd:string */
	std::string _delegationId;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__jobSubmitJSDLResponse
#define SOAP_TYPE_ns1__jobSubmitJSDLResponse (218)
/* ns1:jobSubmitJSDLResponse */
struct ns1__jobSubmitJSDLResponse
{
public:
	ns1__JobIdStructType *_jobIdStruct;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:JobIdStructType */
};
#endif

#ifndef SOAP_TYPE_ns1__jobSubmitJSDL
#define SOAP_TYPE_ns1__jobSubmitJSDL (221)
/* ns1:jobSubmitJSDL */
struct ns1__jobSubmitJSDL
{
public:
	std::string _delegationId;	/* required element of type xsd:string */
	jsdl__JobDefinition_USCOREType *_jsdl;	/* optional element of type jsdl:JobDefinition_Type */
};
#endif

#ifndef SOAP_TYPE_ns1__jobCancelResponse
#define SOAP_TYPE_ns1__jobCancelResponse (222)
/* ns1:jobCancelResponse */
struct ns1__jobCancelResponse
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns1__jobCancel
#define SOAP_TYPE_ns1__jobCancel (225)
/* ns1:jobCancel */
struct ns1__jobCancel
{
public:
	std::string _jobId;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__getMaxInputSandboxSizeResponse
#define SOAP_TYPE_ns1__getMaxInputSandboxSizeResponse (226)
/* ns1:getMaxInputSandboxSizeResponse */
struct ns1__getMaxInputSandboxSizeResponse
{
public:
	LONG64 size;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:long */
};
#endif

#ifndef SOAP_TYPE_ns1__getMaxInputSandboxSize
#define SOAP_TYPE_ns1__getMaxInputSandboxSize (229)
/* ns1:getMaxInputSandboxSize */
struct ns1__getMaxInputSandboxSize
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns1__getSandboxDestURIResponse
#define SOAP_TYPE_ns1__getSandboxDestURIResponse (230)
/* ns1:getSandboxDestURIResponse */
struct ns1__getSandboxDestURIResponse
{
public:
	ns1__StringList *_path;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:StringList */
};
#endif

#ifndef SOAP_TYPE_ns1__getSandboxDestURI
#define SOAP_TYPE_ns1__getSandboxDestURI (234)
/* ns1:getSandboxDestURI */
struct ns1__getSandboxDestURI
{
public:
	std::string _jobId;	/* required element of type xsd:string */
	std::string _protocol;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__getSandboxBulkDestURIResponse
#define SOAP_TYPE_ns1__getSandboxBulkDestURIResponse (235)
/* ns1:getSandboxBulkDestURIResponse */
struct ns1__getSandboxBulkDestURIResponse
{
public:
	ns1__DestURIsStructType *_DestURIsStructType;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:DestURIsStructType */
};
#endif

#ifndef SOAP_TYPE_ns1__getSandboxBulkDestURI
#define SOAP_TYPE_ns1__getSandboxBulkDestURI (239)
/* ns1:getSandboxBulkDestURI */
struct ns1__getSandboxBulkDestURI
{
public:
	std::string _jobId;	/* required element of type xsd:string */
	std::string _protocol;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__getTotalQuotaResponse
#define SOAP_TYPE_ns1__getTotalQuotaResponse (240)
/* ns1:getTotalQuotaResponse */
struct ns1__getTotalQuotaResponse
{
public:
	LONG64 softLimit;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:long */
	LONG64 hardLimit;	/* required element of type xsd:long */
};
#endif

#ifndef SOAP_TYPE_ns1__getTotalQuota
#define SOAP_TYPE_ns1__getTotalQuota (243)
/* ns1:getTotalQuota */
struct ns1__getTotalQuota
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns1__getFreeQuotaResponse
#define SOAP_TYPE_ns1__getFreeQuotaResponse (244)
/* ns1:getFreeQuotaResponse */
struct ns1__getFreeQuotaResponse
{
public:
	LONG64 softLimit;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:long */
	LONG64 hardLimit;	/* required element of type xsd:long */
};
#endif

#ifndef SOAP_TYPE_ns1__getFreeQuota
#define SOAP_TYPE_ns1__getFreeQuota (247)
/* ns1:getFreeQuota */
struct ns1__getFreeQuota
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns1__jobPurgeResponse
#define SOAP_TYPE_ns1__jobPurgeResponse (248)
/* ns1:jobPurgeResponse */
struct ns1__jobPurgeResponse
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns1__jobPurge
#define SOAP_TYPE_ns1__jobPurge (251)
/* ns1:jobPurge */
struct ns1__jobPurge
{
public:
	std::string _jobId;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__getOutputFileListResponse
#define SOAP_TYPE_ns1__getOutputFileListResponse (252)
/* ns1:getOutputFileListResponse */
struct ns1__getOutputFileListResponse
{
public:
	ns1__StringAndLongList *_OutputFileAndSizeList;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:StringAndLongList */
};
#endif

#ifndef SOAP_TYPE_ns1__getOutputFileList
#define SOAP_TYPE_ns1__getOutputFileList (256)
/* ns1:getOutputFileList */
struct ns1__getOutputFileList
{
public:
	std::string _jobId;	/* required element of type xsd:string */
	std::string _protocol;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__jobListMatchResponse
#define SOAP_TYPE_ns1__jobListMatchResponse (257)
/* ns1:jobListMatchResponse */
struct ns1__jobListMatchResponse
{
public:
	ns1__StringAndLongList *_CEIdAndRankList;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:StringAndLongList */
};
#endif

#ifndef SOAP_TYPE_ns1__jobListMatch
#define SOAP_TYPE_ns1__jobListMatch (260)
/* ns1:jobListMatch */
struct ns1__jobListMatch
{
public:
	std::string _jdl;	/* required element of type xsd:string */
	std::string _delegationId;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__jobListMatchJSDLResponse
#define SOAP_TYPE_ns1__jobListMatchJSDLResponse (261)
/* ns1:jobListMatchJSDLResponse */
struct ns1__jobListMatchJSDLResponse
{
public:
	ns1__StringAndLongList *_CEIdAndRankList;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:StringAndLongList */
};
#endif

#ifndef SOAP_TYPE_ns1__jobListMatchJSDL
#define SOAP_TYPE_ns1__jobListMatchJSDL (264)
/* ns1:jobListMatchJSDL */
struct ns1__jobListMatchJSDL
{
public:
	jsdl__JobDefinition_USCOREType *_jsdl;	/* optional element of type jsdl:JobDefinition_Type */
	std::string _delegationId;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__getJobTemplateResponse
#define SOAP_TYPE_ns1__getJobTemplateResponse (265)
/* ns1:getJobTemplateResponse */
struct ns1__getJobTemplateResponse
{
public:
	std::string _jdl;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__getJobTemplate
#define SOAP_TYPE_ns1__getJobTemplate (269)
/* ns1:getJobTemplate */
struct ns1__getJobTemplate
{
public:
	ns1__JobTypeList *_jobType;	/* optional element of type ns1:JobTypeList */
	std::string _executable;	/* required element of type xsd:string */
	std::string _arguments;	/* required element of type xsd:string */
	std::string _requirements;	/* required element of type xsd:string */
	std::string _rank;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__getDAGTemplateResponse
#define SOAP_TYPE_ns1__getDAGTemplateResponse (270)
/* ns1:getDAGTemplateResponse */
struct ns1__getDAGTemplateResponse
{
public:
	std::string _jdl;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__getDAGTemplate
#define SOAP_TYPE_ns1__getDAGTemplate (273)
/* ns1:getDAGTemplate */
struct ns1__getDAGTemplate
{
public:
	ns1__GraphStructType *_dependencies;	/* optional element of type ns1:GraphStructType */
	std::string _requirements;	/* required element of type xsd:string */
	std::string _rank;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__getCollectionTemplateResponse
#define SOAP_TYPE_ns1__getCollectionTemplateResponse (274)
/* ns1:getCollectionTemplateResponse */
struct ns1__getCollectionTemplateResponse
{
public:
	std::string _jdl;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__getCollectionTemplate
#define SOAP_TYPE_ns1__getCollectionTemplate (277)
/* ns1:getCollectionTemplate */
struct ns1__getCollectionTemplate
{
public:
	int _jobNumber;	/* required element of type xsd:int */
	std::string _requirements;	/* required element of type xsd:string */
	std::string _rank;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__getIntParametricJobTemplateResponse
#define SOAP_TYPE_ns1__getIntParametricJobTemplateResponse (278)
/* ns1:getIntParametricJobTemplateResponse */
struct ns1__getIntParametricJobTemplateResponse
{
public:
	std::string _jdl;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__getIntParametricJobTemplate
#define SOAP_TYPE_ns1__getIntParametricJobTemplate (281)
/* ns1:getIntParametricJobTemplate */
struct ns1__getIntParametricJobTemplate
{
public:
	ns1__StringList *_attributes;	/* optional element of type ns1:StringList */
	int _param;	/* required element of type xsd:int */
	int _parameterStart;	/* required element of type xsd:int */
	int _parameterStep;	/* required element of type xsd:int */
	std::string _requirements;	/* required element of type xsd:string */
	std::string _rank;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__getStringParametricJobTemplateResponse
#define SOAP_TYPE_ns1__getStringParametricJobTemplateResponse (282)
/* ns1:getStringParametricJobTemplateResponse */
struct ns1__getStringParametricJobTemplateResponse
{
public:
	std::string _jdl;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__getStringParametricJobTemplate
#define SOAP_TYPE_ns1__getStringParametricJobTemplate (285)
/* ns1:getStringParametricJobTemplate */
struct ns1__getStringParametricJobTemplate
{
public:
	ns1__StringList *_attributes;	/* optional element of type ns1:StringList */
	ns1__StringList *_param;	/* optional element of type ns1:StringList */
	std::string _requirements;	/* required element of type xsd:string */
	std::string _rank;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__getACLItemsResponse
#define SOAP_TYPE_ns1__getACLItemsResponse (286)
/* ns1:getACLItemsResponse */
struct ns1__getACLItemsResponse
{
public:
	ns1__StringList *_items;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:StringList */
};
#endif

#ifndef SOAP_TYPE_ns1__getACLItems
#define SOAP_TYPE_ns1__getACLItems (289)
/* ns1:getACLItems */
struct ns1__getACLItems
{
public:
	std::string _jobId;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__addACLItemsResponse
#define SOAP_TYPE_ns1__addACLItemsResponse (290)
/* ns1:addACLItemsResponse */
struct ns1__addACLItemsResponse
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns1__addACLItems
#define SOAP_TYPE_ns1__addACLItems (293)
/* ns1:addACLItems */
struct ns1__addACLItems
{
public:
	std::string _jobId;	/* required element of type xsd:string */
	ns1__StringList *_items;	/* optional element of type ns1:StringList */
};
#endif

#ifndef SOAP_TYPE_ns1__removeACLItemResponse
#define SOAP_TYPE_ns1__removeACLItemResponse (294)
/* ns1:removeACLItemResponse */
struct ns1__removeACLItemResponse
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns1__removeACLItem
#define SOAP_TYPE_ns1__removeACLItem (297)
/* ns1:removeACLItem */
struct ns1__removeACLItem
{
public:
	std::string _jobId;	/* required element of type xsd:string */
	std::string _item;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__getDelegatedProxyInfoResponse
#define SOAP_TYPE_ns1__getDelegatedProxyInfoResponse (298)
/* ns1:getDelegatedProxyInfoResponse */
struct ns1__getDelegatedProxyInfoResponse
{
public:
	ns1__ProxyInfoStructType *_items;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:ProxyInfoStructType */
};
#endif

#ifndef SOAP_TYPE_ns1__getDelegatedProxyInfo
#define SOAP_TYPE_ns1__getDelegatedProxyInfo (302)
/* ns1:getDelegatedProxyInfo */
struct ns1__getDelegatedProxyInfo
{
public:
	std::string _delegationID;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__getJobProxyInfoResponse
#define SOAP_TYPE_ns1__getJobProxyInfoResponse (303)
/* ns1:getJobProxyInfoResponse */
struct ns1__getJobProxyInfoResponse
{
public:
	ns1__ProxyInfoStructType *_items;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:ProxyInfoStructType */
};
#endif

#ifndef SOAP_TYPE_ns1__getJobProxyInfo
#define SOAP_TYPE_ns1__getJobProxyInfo (306)
/* ns1:getJobProxyInfo */
struct ns1__getJobProxyInfo
{
public:
	std::string _jobId;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__enableFilePerusalResponse
#define SOAP_TYPE_ns1__enableFilePerusalResponse (307)
/* ns1:enableFilePerusalResponse */
struct ns1__enableFilePerusalResponse
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns1__enableFilePerusal
#define SOAP_TYPE_ns1__enableFilePerusal (310)
/* ns1:enableFilePerusal */
struct ns1__enableFilePerusal
{
public:
	std::string _jobId;	/* required element of type xsd:string */
	ns1__StringList *_fileList;	/* optional element of type ns1:StringList */
};
#endif

#ifndef SOAP_TYPE_ns1__getPerusalFilesResponse
#define SOAP_TYPE_ns1__getPerusalFilesResponse (311)
/* ns1:getPerusalFilesResponse */
struct ns1__getPerusalFilesResponse
{
public:
	ns1__StringList *_fileList;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:StringList */
};
#endif

#ifndef SOAP_TYPE_ns1__getPerusalFiles
#define SOAP_TYPE_ns1__getPerusalFiles (314)
/* ns1:getPerusalFiles */
struct ns1__getPerusalFiles
{
public:
	std::string _jobId;	/* required element of type xsd:string */
	std::string _file;	/* required element of type xsd:string */
	bool _allChunks;	/* required element of type xsd:boolean */
	std::string _protocol;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_ns1__getTransferProtocolsResponse
#define SOAP_TYPE_ns1__getTransferProtocolsResponse (315)
/* ns1:getTransferProtocolsResponse */
struct ns1__getTransferProtocolsResponse
{
public:
	ns1__StringList *items;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:StringList */
};
#endif

#ifndef SOAP_TYPE_ns1__getTransferProtocols
#define SOAP_TYPE_ns1__getTransferProtocols (318)
/* ns1:getTransferProtocols */
struct ns1__getTransferProtocols
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_ns1__getJobStatusResponse
#define SOAP_TYPE_ns1__getJobStatusResponse (319)
/* ns1:getJobStatusResponse */
struct ns1__getJobStatusResponse
{
public:
	ns1__JobStatusStructType *JobStatusStruct;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:JobStatusStructType */
};
#endif

#ifndef SOAP_TYPE_ns1__getJobStatus
#define SOAP_TYPE_ns1__getJobStatus (322)
/* ns1:getJobStatus */
struct ns1__getJobStatus
{
public:
	std::string jobId;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (323)
/* SOAP Header: */
struct SOAP_ENV__Header
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (324)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (326)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (327)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE_xsd__ID
#define SOAP_TYPE_xsd__ID (9)
typedef std::string xsd__ID;
#endif

#ifndef SOAP_TYPE_xsd__NCName
#define SOAP_TYPE_xsd__NCName (10)
typedef std::string xsd__NCName;
#endif

#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (11)
typedef std::string xsd__anyURI;
#endif

#ifndef SOAP_TYPE_xsd__nonNegativeInteger
#define SOAP_TYPE_xsd__nonNegativeInteger (12)
typedef std::string xsd__nonNegativeInteger;
#endif

#ifndef SOAP_TYPE_xsd__normalizedString
#define SOAP_TYPE_xsd__normalizedString (13)
typedef std::string xsd__normalizedString;
#endif

#ifndef SOAP_TYPE_jsdl__Description_USCOREType
#define SOAP_TYPE_jsdl__Description_USCOREType (69)
typedef std::string jsdl__Description_USCOREType;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Server-Side Operations                                                     *
 *                                                                            *
\******************************************************************************/


SOAP_FMAC5 int SOAP_FMAC6 delegation1__getProxyReq(struct soap*, std::string _delegationID, struct delegation1__getProxyReqResponse &_param_1);

SOAP_FMAC5 int SOAP_FMAC6 delegation1__putProxy(struct soap*, std::string _delegationID, std::string _proxy, struct delegation1__putProxyResponse &_param_2);

SOAP_FMAC5 int SOAP_FMAC6 delegationns__getVersion(struct soap*, struct delegationns__getVersionResponse &_param_3);

SOAP_FMAC5 int SOAP_FMAC6 delegationns__getInterfaceVersion(struct soap*, struct delegationns__getInterfaceVersionResponse &_param_4);

SOAP_FMAC5 int SOAP_FMAC6 delegationns__getServiceMetadata(struct soap*, std::string _key, struct delegationns__getServiceMetadataResponse &_param_5);

SOAP_FMAC5 int SOAP_FMAC6 delegationns__getProxyReq(struct soap*, std::string _delegationID, struct delegationns__getProxyReqResponse &_param_6);

SOAP_FMAC5 int SOAP_FMAC6 delegationns__getNewProxyReq(struct soap*, struct delegationns__getNewProxyReqResponse &_param_7);

SOAP_FMAC5 int SOAP_FMAC6 delegationns__renewProxyReq(struct soap*, std::string _delegationID, struct delegationns__renewProxyReqResponse &_param_8);

SOAP_FMAC5 int SOAP_FMAC6 delegationns__putProxy(struct soap*, std::string _delegationID, std::string _proxy, struct delegationns__putProxyResponse &_param_9);

SOAP_FMAC5 int SOAP_FMAC6 delegationns__getTerminationTime(struct soap*, std::string _delegationID, struct delegationns__getTerminationTimeResponse &_param_10);

SOAP_FMAC5 int SOAP_FMAC6 delegationns__destroy(struct soap*, std::string _delegationID, struct delegationns__destroyResponse &_param_11);

SOAP_FMAC5 int SOAP_FMAC6 ns1__getProxyReq(struct soap*, std::string _delegationID, struct ns1__getProxyReqResponse &_param_12);

SOAP_FMAC5 int SOAP_FMAC6 ns1__putProxy(struct soap*, std::string _delegationID, std::string _proxy, struct ns1__putProxyResponse &_param_13);

SOAP_FMAC5 int SOAP_FMAC6 ns1__getVersion(struct soap*, struct ns1__getVersionResponse &_param_14);

SOAP_FMAC5 int SOAP_FMAC6 ns1__getJDL(struct soap*, std::string _jobId, enum ns1__JdlType _type, struct ns1__getJDLResponse &_param_15);

SOAP_FMAC5 int SOAP_FMAC6 ns1__jobRegister(struct soap*, std::string _jdl, std::string _delegationId, struct ns1__jobRegisterResponse &_param_16);

SOAP_FMAC5 int SOAP_FMAC6 ns1__jobRegisterJSDL(struct soap*, jsdl__JobDefinition_USCOREType *_jsdl, std::string _delegationId, struct ns1__jobRegisterJSDLResponse &_param_17);

SOAP_FMAC5 int SOAP_FMAC6 ns1__jobStart(struct soap*, std::string _jobId, struct ns1__jobStartResponse &_param_18);

SOAP_FMAC5 int SOAP_FMAC6 ns1__jobSubmit(struct soap*, std::string _jdl, std::string _delegationId, struct ns1__jobSubmitResponse &_param_19);

SOAP_FMAC5 int SOAP_FMAC6 ns1__jobSubmitJSDL(struct soap*, std::string _delegationId, jsdl__JobDefinition_USCOREType *_jsdl, struct ns1__jobSubmitJSDLResponse &_param_20);

SOAP_FMAC5 int SOAP_FMAC6 ns1__jobCancel(struct soap*, std::string _jobId, struct ns1__jobCancelResponse &_param_21);

SOAP_FMAC5 int SOAP_FMAC6 ns1__getMaxInputSandboxSize(struct soap*, struct ns1__getMaxInputSandboxSizeResponse &_param_22);

SOAP_FMAC5 int SOAP_FMAC6 ns1__getSandboxDestURI(struct soap*, std::string _jobId, std::string _protocol, struct ns1__getSandboxDestURIResponse &_param_23);

SOAP_FMAC5 int SOAP_FMAC6 ns1__getSandboxBulkDestURI(struct soap*, std::string _jobId, std::string _protocol, struct ns1__getSandboxBulkDestURIResponse &_param_24);

SOAP_FMAC5 int SOAP_FMAC6 ns1__getTotalQuota(struct soap*, struct ns1__getTotalQuotaResponse &_param_25);

SOAP_FMAC5 int SOAP_FMAC6 ns1__getFreeQuota(struct soap*, struct ns1__getFreeQuotaResponse &_param_26);

SOAP_FMAC5 int SOAP_FMAC6 ns1__jobPurge(struct soap*, std::string _jobId, struct ns1__jobPurgeResponse &_param_27);

SOAP_FMAC5 int SOAP_FMAC6 ns1__getOutputFileList(struct soap*, std::string _jobId, std::string _protocol, struct ns1__getOutputFileListResponse &_param_28);

SOAP_FMAC5 int SOAP_FMAC6 ns1__jobListMatch(struct soap*, std::string _jdl, std::string _delegationId, struct ns1__jobListMatchResponse &_param_29);

SOAP_FMAC5 int SOAP_FMAC6 ns1__jobListMatchJSDL(struct soap*, jsdl__JobDefinition_USCOREType *_jsdl, std::string _delegationId, struct ns1__jobListMatchJSDLResponse &_param_30);

SOAP_FMAC5 int SOAP_FMAC6 ns1__getJobTemplate(struct soap*, ns1__JobTypeList *_jobType, std::string _executable, std::string _arguments, std::string _requirements, std::string _rank, struct ns1__getJobTemplateResponse &_param_31);

SOAP_FMAC5 int SOAP_FMAC6 ns1__getDAGTemplate(struct soap*, ns1__GraphStructType *_dependencies, std::string _requirements, std::string _rank, struct ns1__getDAGTemplateResponse &_param_32);

SOAP_FMAC5 int SOAP_FMAC6 ns1__getCollectionTemplate(struct soap*, int _jobNumber, std::string _requirements, std::string _rank, struct ns1__getCollectionTemplateResponse &_param_33);

SOAP_FMAC5 int SOAP_FMAC6 ns1__getIntParametricJobTemplate(struct soap*, ns1__StringList *_attributes, int _param, int _parameterStart, int _parameterStep, std::string _requirements, std::string _rank, struct ns1__getIntParametricJobTemplateResponse &_param_34);

SOAP_FMAC5 int SOAP_FMAC6 ns1__getStringParametricJobTemplate(struct soap*, ns1__StringList *_attributes, ns1__StringList *_param, std::string _requirements, std::string _rank, struct ns1__getStringParametricJobTemplateResponse &_param_35);

SOAP_FMAC5 int SOAP_FMAC6 ns1__getACLItems(struct soap*, std::string _jobId, struct ns1__getACLItemsResponse &_param_36);

SOAP_FMAC5 int SOAP_FMAC6 ns1__addACLItems(struct soap*, std::string _jobId, ns1__StringList *_items, struct ns1__addACLItemsResponse &_param_37);

SOAP_FMAC5 int SOAP_FMAC6 ns1__removeACLItem(struct soap*, std::string _jobId, std::string _item, struct ns1__removeACLItemResponse &_param_38);

SOAP_FMAC5 int SOAP_FMAC6 ns1__getDelegatedProxyInfo(struct soap*, std::string _delegationID, struct ns1__getDelegatedProxyInfoResponse &_param_39);

SOAP_FMAC5 int SOAP_FMAC6 ns1__getJobProxyInfo(struct soap*, std::string _jobId, struct ns1__getJobProxyInfoResponse &_param_40);

SOAP_FMAC5 int SOAP_FMAC6 ns1__enableFilePerusal(struct soap*, std::string _jobId, ns1__StringList *_fileList, struct ns1__enableFilePerusalResponse &_param_41);

SOAP_FMAC5 int SOAP_FMAC6 ns1__getPerusalFiles(struct soap*, std::string _jobId, std::string _file, bool _allChunks, std::string _protocol, struct ns1__getPerusalFilesResponse &_param_42);

SOAP_FMAC5 int SOAP_FMAC6 ns1__getTransferProtocols(struct soap*, struct ns1__getTransferProtocolsResponse &_param_43);

SOAP_FMAC5 int SOAP_FMAC6 ns1__getJobStatus(struct soap*, std::string jobId, struct ns1__getJobStatusResponse &_param_44);

/******************************************************************************\
 *                                                                            *
 * Server-Side Skeletons to Invoke Service Operations                         *
 *                                                                            *
\******************************************************************************/

SOAP_FMAC5 int SOAP_FMAC6 soap_serve(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_request(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_delegation1__getProxyReq(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_delegation1__putProxy(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_delegationns__getVersion(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_delegationns__getInterfaceVersion(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_delegationns__getServiceMetadata(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_delegationns__getProxyReq(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_delegationns__getNewProxyReq(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_delegationns__renewProxyReq(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_delegationns__putProxy(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_delegationns__getTerminationTime(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_delegationns__destroy(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns1__getProxyReq(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns1__putProxy(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns1__getVersion(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns1__getJDL(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns1__jobRegister(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns1__jobRegisterJSDL(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns1__jobStart(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns1__jobSubmit(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns1__jobSubmitJSDL(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns1__jobCancel(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns1__getMaxInputSandboxSize(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns1__getSandboxDestURI(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns1__getSandboxBulkDestURI(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns1__getTotalQuota(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns1__getFreeQuota(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns1__jobPurge(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns1__getOutputFileList(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns1__jobListMatch(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns1__jobListMatchJSDL(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns1__getJobTemplate(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns1__getDAGTemplate(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns1__getCollectionTemplate(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns1__getIntParametricJobTemplate(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns1__getStringParametricJobTemplate(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns1__getACLItems(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns1__addACLItems(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns1__removeACLItem(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns1__getDelegatedProxyInfo(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns1__getJobProxyInfo(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns1__enableFilePerusal(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns1__getPerusalFiles(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns1__getTransferProtocols(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns1__getJobStatus(struct soap*);

/******************************************************************************\
 *                                                                            *
 * Client-Side Call Stubs                                                     *
 *                                                                            *
\******************************************************************************/


SOAP_FMAC5 int SOAP_FMAC6 soap_call_delegation1__getProxyReq(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string _delegationID, struct delegation1__getProxyReqResponse &_param_1);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_delegation1__putProxy(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string _delegationID, std::string _proxy, struct delegation1__putProxyResponse &_param_2);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_delegationns__getVersion(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct delegationns__getVersionResponse &_param_3);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_delegationns__getInterfaceVersion(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct delegationns__getInterfaceVersionResponse &_param_4);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_delegationns__getServiceMetadata(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string _key, struct delegationns__getServiceMetadataResponse &_param_5);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_delegationns__getProxyReq(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string _delegationID, struct delegationns__getProxyReqResponse &_param_6);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_delegationns__getNewProxyReq(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct delegationns__getNewProxyReqResponse &_param_7);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_delegationns__renewProxyReq(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string _delegationID, struct delegationns__renewProxyReqResponse &_param_8);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_delegationns__putProxy(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string _delegationID, std::string _proxy, struct delegationns__putProxyResponse &_param_9);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_delegationns__getTerminationTime(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string _delegationID, struct delegationns__getTerminationTimeResponse &_param_10);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_delegationns__destroy(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string _delegationID, struct delegationns__destroyResponse &_param_11);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__getProxyReq(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string _delegationID, struct ns1__getProxyReqResponse &_param_12);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__putProxy(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string _delegationID, std::string _proxy, struct ns1__putProxyResponse &_param_13);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__getVersion(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct ns1__getVersionResponse &_param_14);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__getJDL(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string _jobId, enum ns1__JdlType _type, struct ns1__getJDLResponse &_param_15);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__jobRegister(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string _jdl, std::string _delegationId, struct ns1__jobRegisterResponse &_param_16);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__jobRegisterJSDL(struct soap *soap, const char *soap_endpoint, const char *soap_action, jsdl__JobDefinition_USCOREType *_jsdl, std::string _delegationId, struct ns1__jobRegisterJSDLResponse &_param_17);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__jobStart(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string _jobId, struct ns1__jobStartResponse &_param_18);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__jobSubmit(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string _jdl, std::string _delegationId, struct ns1__jobSubmitResponse &_param_19);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__jobSubmitJSDL(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string _delegationId, jsdl__JobDefinition_USCOREType *_jsdl, struct ns1__jobSubmitJSDLResponse &_param_20);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__jobCancel(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string _jobId, struct ns1__jobCancelResponse &_param_21);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__getMaxInputSandboxSize(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct ns1__getMaxInputSandboxSizeResponse &_param_22);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__getSandboxDestURI(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string _jobId, std::string _protocol, struct ns1__getSandboxDestURIResponse &_param_23);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__getSandboxBulkDestURI(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string _jobId, std::string _protocol, struct ns1__getSandboxBulkDestURIResponse &_param_24);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__getTotalQuota(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct ns1__getTotalQuotaResponse &_param_25);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__getFreeQuota(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct ns1__getFreeQuotaResponse &_param_26);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__jobPurge(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string _jobId, struct ns1__jobPurgeResponse &_param_27);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__getOutputFileList(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string _jobId, std::string _protocol, struct ns1__getOutputFileListResponse &_param_28);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__jobListMatch(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string _jdl, std::string _delegationId, struct ns1__jobListMatchResponse &_param_29);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__jobListMatchJSDL(struct soap *soap, const char *soap_endpoint, const char *soap_action, jsdl__JobDefinition_USCOREType *_jsdl, std::string _delegationId, struct ns1__jobListMatchJSDLResponse &_param_30);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__getJobTemplate(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__JobTypeList *_jobType, std::string _executable, std::string _arguments, std::string _requirements, std::string _rank, struct ns1__getJobTemplateResponse &_param_31);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__getDAGTemplate(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__GraphStructType *_dependencies, std::string _requirements, std::string _rank, struct ns1__getDAGTemplateResponse &_param_32);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__getCollectionTemplate(struct soap *soap, const char *soap_endpoint, const char *soap_action, int _jobNumber, std::string _requirements, std::string _rank, struct ns1__getCollectionTemplateResponse &_param_33);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__getIntParametricJobTemplate(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__StringList *_attributes, int _param, int _parameterStart, int _parameterStep, std::string _requirements, std::string _rank, struct ns1__getIntParametricJobTemplateResponse &_param_34);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__getStringParametricJobTemplate(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__StringList *_attributes, ns1__StringList *_param, std::string _requirements, std::string _rank, struct ns1__getStringParametricJobTemplateResponse &_param_35);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__getACLItems(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string _jobId, struct ns1__getACLItemsResponse &_param_36);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__addACLItems(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string _jobId, ns1__StringList *_items, struct ns1__addACLItemsResponse &_param_37);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__removeACLItem(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string _jobId, std::string _item, struct ns1__removeACLItemResponse &_param_38);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__getDelegatedProxyInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string _delegationID, struct ns1__getDelegatedProxyInfoResponse &_param_39);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__getJobProxyInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string _jobId, struct ns1__getJobProxyInfoResponse &_param_40);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__enableFilePerusal(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string _jobId, ns1__StringList *_fileList, struct ns1__enableFilePerusalResponse &_param_41);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__getPerusalFiles(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string _jobId, std::string _file, bool _allChunks, std::string _protocol, struct ns1__getPerusalFilesResponse &_param_42);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__getTransferProtocols(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct ns1__getTransferProtocolsResponse &_param_43);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns1__getJobStatus(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string jobId, struct ns1__getJobStatusResponse &_param_44);

#endif

/* End of soapStub.h */
